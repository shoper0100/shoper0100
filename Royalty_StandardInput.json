{
    "language": "Solidity",
    "sources": {
        "contracts/Royalty.sol": {
            "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.20;\n\ninterface IRideBNB {\n    function userInfo(uint _userId) external view returns (\n        address account,\n        uint id,\n        uint referrer,\n        uint upline,\n        uint start,\n        uint level,\n        uint directTeam,\n        uint totalMatrixTeam,\n        bool exists\n    );\n    function userIncome(uint _userId) external view returns (\n        uint totalIncome,\n        uint totalDeposit,\n        uint royaltyIncome,\n        uint referralIncome,\n        uint levelIncome,\n        uint sponsorIncome\n    );\n}\n\ncontract Royalty {\n    address public owner;\n    IRideBNB public rideBNBContract;\n    uint public defaultRefer;\n    \n    // Royalty tracking\n    struct RoyaltyData {\n        uint userCount;\n        uint index;\n        uint distributionRound;\n        uint dividendPerShare;\n    }\n    \n    mapping(uint => RoyaltyData) public royaltyData;\n    mapping(uint => mapping(uint => uint[])) private pendingRoyaltyUsers;\n    mapping(uint => mapping(uint => uint)) public royaltyAmounts;\n    mapping(uint => mapping(uint => bool)) public royaltyTaken;\n    mapping(uint => mapping(uint => bool)) public royaltyActive;\n    mapping(uint => mapping(uint => uint)) private lastRoyaltyTime;\n    mapping(uint => mapping(uint => uint)) private lastClaimedDividend;\n    \n    bool private locked;\n    \n    uint[4] public royaltyPercent = [40, 30, 20, 10];\n    uint[4] public royaltyLvl = [10, 11, 12, 13];\n    uint public constant royaltyMaxPercent = 150;\n    uint public constant royaltyDistTime = 24 hours;\n    uint public startTime;\n    \n    event UserRegistered(uint indexed userId, uint indexed tier, uint timestamp);\n    event RoyaltyDistributed(uint indexed tier, uint amount, uint userCount, uint timestamp);\n    event RoyaltyClaimed(uint indexed userId, uint indexed tier, uint amount, uint timestamp);\n    event RideBNBContractSet(address indexed rideBNBContract, uint timestamp);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    \n    modifier nonReentrant() {\n        require(!locked, \"No reentrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n    \n    constructor(address _owner, uint _defaultRefer) {\n        owner = _owner;\n        defaultRefer = _defaultRefer;\n        startTime = block.timestamp;\n    }\n    \n    receive() external payable {}\n    \n    function setRideBNBContract(address _rideBNBContract) external onlyOwner {\n        rideBNBContract = IRideBNB(_rideBNBContract);\n        emit RideBNBContractSet(_rideBNBContract, block.timestamp);\n    }\n    \n    function registerUser(uint _userId, uint _level) external {\n        require(msg.sender == address(rideBNBContract), \"Only RideBNB contract\");\n        \n        for(uint i=0; i<4; i++) {\n            if(royaltyLvl[i] == _level) {\n                pendingRoyaltyUsers[i][0].push(_userId);\n                emit UserRegistered(_userId, i, block.timestamp);\n                break;\n            }\n        }\n    }\n    \n    function distRoyalty(uint _tier) external {\n        require(_tier < 4, \"Invalid tier\");\n        require((block.timestamp - startTime) / royaltyDistTime > royaltyData[_tier].distributionRound, \"Not yet\");\n        \n        uint _balance = address(this).balance;\n        uint _amt = (_balance * royaltyPercent[_tier]) / 100;\n        \n        require(_amt > 0, \"No funds to distribute\");\n        \n        uint currentIndex = royaltyData[_tier].index;\n        uint newUsers = 0;\n        \n        if(_tier == 0) {\n            for(uint i = currentIndex; i < pendingRoyaltyUsers[0][0].length; i++) {\n                uint _user = pendingRoyaltyUsers[0][0][i];\n                royaltyActive[_user][0] = true;\n                royaltyData[0].userCount++;\n                royaltyData[0].index++;\n                newUsers++;\n            }\n        }\n        \n        uint totalActiveUsers = royaltyData[_tier].userCount;\n        require(totalActiveUsers > 0, \"No active users\");\n        \n        uint dividendIncrease = (_amt * 1e18) / totalActiveUsers;\n        royaltyData[_tier].dividendPerShare += dividendIncrease;\n        \n        royaltyData[_tier].distributionRound++;\n        emit RoyaltyDistributed(_tier, _amt, totalActiveUsers, block.timestamp);\n    }\n    \n    function claimRoyalty(\n        uint _id, \n        uint _tier,\n        uint rootUserId,\n        uint userTotalIncome,\n        uint userTotalDeposit,\n        address userAccount\n    ) external nonReentrant returns (uint) {\n        require(msg.sender == userAccount || msg.sender == address(rideBNBContract), \"Unauthorized\");\n        require(_tier < 4, \"Invalid tier\");\n        require(royaltyActive[_id][_tier], \"Inactive\");\n        \n        uint currentDay = getCurRoyaltyDay();\n        require(lastRoyaltyTime[_id][_tier] < currentDay, \"Already claimed today\");\n        \n        bool isRoot = _id == rootUserId;\n        \n        if(!isRoot) {\n            require(userTotalIncome < (userTotalDeposit * royaltyMaxPercent / 100), \"Max cap reached\");\n        }\n        \n        uint totalDividendPerShare = royaltyData[_tier].dividendPerShare;\n        uint userLastClaimed = lastClaimedDividend[_id][_tier];\n        uint unclaimedDividend = totalDividendPerShare - userLastClaimed;\n        \n        uint _amt = unclaimedDividend / 1e18;\n        \n        require(_amt > 0, \"No royalty available\");\n        \n        lastClaimedDividend[_id][_tier] = totalDividendPerShare;\n        lastRoyaltyTime[_id][_tier] = currentDay;\n        \n        if(!isRoot) {\n            royaltyActive[_id][_tier] = false;\n        }\n        \n        (bool success, ) = payable(userAccount).call{value: _amt}(\"\");\n        require(success, \"Transfer failed\");\n        \n        emit RoyaltyClaimed(_id, _tier, _amt, block.timestamp);\n        return _amt;\n    }\n    \n    function getCurRoyaltyDay() public view returns(uint) {\n        return (block.timestamp - startTime) / royaltyDistTime;\n    }\n    \n    function getUserRoyaltyData(uint _userId, uint _tier) external view returns (uint amount, bool taken, bool active) {\n        return (royaltyAmounts[_userId][_tier], royaltyTaken[_userId][_tier], royaltyActive[_userId][_tier]);\n    }\n    \n    function getRoyaltyPercents() external view returns(uint[4] memory) {\n        return royaltyPercent;\n    }\n    \n    function getRoyaltyLevels() external view returns(uint[4] memory) {\n        return royaltyLvl;\n    }\n    \n    function getTierStats(uint _tier) external view returns(uint userCount, uint distributionRound, uint pendingUserCount) {\n        return (\n            royaltyData[_tier].userCount,\n            royaltyData[_tier].distributionRound,\n            pendingRoyaltyUsers[_tier][0].length - royaltyData[_tier].index\n        );\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "viaIR": true,
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "ast"
                ]
            }
        }
    }
}