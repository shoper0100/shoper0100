{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/FiveDollarRide_BNB_COMPLETE.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title FiveDollarRide - The $5 Opportunity Platform\r\n * @notice Revolutionary income platform starting at just $5 with USDT payments\r\n * @dev Owner-controlled smart contract with progressive decentralization capability\r\n * \r\n * Features:\r\n * - 13 Level progression ($5 to $20,480)\r\n * - Binary matrix tree structure  \r\n * - Multi-layer income distribution (20 layers)\r\n * - Sponsor commissions (13 levels)\r\n * - Royalty pool funding (5% per upgrade)\r\n * - USDT-based payments only\r\n * - Owner-controlled parameters (immutable after ownership renouncement)\r\n * - Full event-driven transparency\r\n * \r\n * Brand: FiveDollarRide - Your $5 Journey to Financial Freedom\r\n */\r\n// USDT Token Interface\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n// Royalty Contract Interface\r\ninterface IRoyalty {\r\n    function registerUser(uint _userId, uint _level, uint _directCount) external;\r\n    function claimRoyalty(\r\n        uint _id, \r\n        uint _tier,\r\n        uint rootUserId,\r\n        uint userTotalIncome,\r\n        uint userTotalDeposit,\r\n        address userAccount\r\n    ) external returns (uint);\r\n    function getUserRoyaltyData(uint _userId, uint _tier) external view returns (uint, bool, bool);\r\n    function getRoyaltyPercents() external view returns(uint[4] memory);\r\n    function getRoyaltyLevels() external view returns(uint[4] memory);\r\n    function getTierStats(uint _tier) external view returns(uint userCount, uint distributionRound, uint pendingUserCount);\r\n}\r\n\r\ncontract FiveDollarRide {\r\n    // ============ IMMUTABLE VALUES (SET AT DEPLOYMENT) ============\r\n    \r\n    address public immutable FEE_RECEIVER;\r\n    IERC20 public immutable USDT;\r\n    IRoyalty public immutable ROYALTY_ADDR;\r\n    uint private immutable DEFAULT_REFER;\r\n    uint public immutable START_TIME;\r\n    \r\n    // ============ CONSTANTS (HARDCODED FOREVER) ============\r\n    \r\n    // System constants\r\n    uint8 public constant MAX_LEVELS = 13;\r\n    uint8 public constant MAX_INCOME_LAYER = 13;  // Income distribution depth (matches 13 levels)\r\n    uint8 public constant MAX_PLACEMENT_DEPTH = 100;  // Placement search depth\r\n    // Note: If tree depth exceeds 100, placement falls back to root (DEFAULT_REFER)\r\n    // This prevents infinite loops but may cluster users under root in very large trees\r\n    \r\n    // Economic constants (adjustable by owner until renounced)\r\n    uint8 public constant ADMIN_FEE_PERCENT = 5;      // 5% admin fee\r\n    uint8 public constant ROYALTY_FUND_PERCENT = 5;   // 5% to royalty pool\r\n    \r\n    // Level costs (adjustable by owner, immutable after renounce)\r\n    // Starting costs: L1=$5, L2=$10, L3=$20... up to L13=$20,480 (hardcoded initially)\r\n    uint256[13] public levelCosts = [\r\n        5e18,      // L1: $5\r\n        10e18,     // L2: $10  \r\n        20e18,     // L3: $20\r\n        40e18,     // L4: $40\r\n        80e18,     // L5: $80\r\n        160e18,    // L6: $160\r\n        320e18,    // L7: $320\r\n        640e18,    // L8: $640\r\n        1280e18,   // L9: $1,280\r\n        2560e18,   // L10: $2,560\r\n        5120e18,   // L11: $5,120\r\n        10240e18,  // L12: $10,240\r\n        20480e18   // L13: $20,480\r\n    ];\r\n    \r\n    // Team & income constants\r\n    uint public constant DIRECT_REQUIRED = 2;\r\n    uint public constant MAX_REFERRAL_LAYERS = 1;\r\n    \r\n    // Sponsor commission (13 levels, total 5%)\r\n    uint8 private constant SPONSOR_LEVELS = 13;\r\n    \r\n    function _getSponsorPercentage(uint8 level) private pure returns (uint16) {\r\n        if (level == 0) return 100;   // L1: 1%\r\n        if (level == 1) return 80;    // L2: 0.8%\r\n        if (level == 2) return 60;    // L3: 0.6%\r\n        if (level == 3) return 50;    // L4: 0.5%\r\n        if (level == 4) return 50;    // L5: 0.5%\r\n        if (level == 5) return 40;    // L6: 0.4%\r\n        if (level == 6) return 30;    // L7: 0.3%\r\n        if (level == 7) return 25;    // L8: 0.25%\r\n        if (level == 8) return 20;    // L9: 0.2%\r\n        if (level == 9) return 15;    // L10: 0.15%\r\n        if (level == 10) return 10;   // L11: 0.1%\r\n        if (level == 11) return 10;   // L12: 0.1%\r\n        if (level == 12) return 10;   // L13: 0.1%\r\n        return 0;\r\n    }\r\n    \r\n    // Sponsor qualification thresholds\r\n    uint8 private constant MIN_DIRECTS_L6_8 = 2;\r\n    uint8 private constant MIN_DIRECTS_L9_10 = 3;\r\n    uint8 private constant MIN_DIRECTS_L11_13 = 5;\r\n    \r\n    \r\n    // ============ STATE VARIABLES ============\r\n    \r\n    // Owner (can renounce)\r\n    address public owner;\r\n    \r\n    // Emergency controls\r\n    bool public paused;\r\n    \r\n    // Reentrancy guard (improved pattern)\r\n    uint256 private unlocked = 1;\r\n    \r\n    // User tracking\r\n    uint public totalUsers;\r\n    uint private userIdCounter;\r\n    \r\n    // ============ DATA STRUCTURES ============\r\n    \r\n    struct User {\r\n        bool exists;\r\n        address account;\r\n        uint referrer;\r\n        uint upline;\r\n        uint level;\r\n        uint directTeam;\r\n        uint team;\r\n        uint registrationTime;\r\n    }\r\n    \r\n    struct UserIncome {\r\n        uint totalDeposit;\r\n        uint totalIncome;\r\n        uint referralIncome;\r\n        uint sponsorIncome;\r\n        uint levelIncome;\r\n    }\r\n    \r\n    struct Activity {\r\n        uint id;\r\n        uint level;\r\n        uint time;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => uint) public id;\r\n    mapping(uint => User) public userInfo;\r\n    mapping(uint => UserIncome) public userIncome;\r\n    mapping(uint => mapping(uint => uint[])) public teams;\r\n    mapping(uint => uint) public matrixDirect;\r\n    mapping(uint => uint) public lostIncome;\r\n    mapping(uint => uint[]) private directReferrals;  // NEW: O(1) direct team lookup\r\n    \r\n    uint[] private globalUsers;  // Changed to private (use events instead)\r\n    Activity[] private activity;  // Changed to private (use events instead)\r\n    \r\n    // ============ EVENTS ============\r\n    \r\n    // User lifecycle\r\n    event UserRegistered(uint indexed userId, address indexed account, uint indexed referrer, uint timestamp);\r\n    event UserUpgraded(uint indexed userId, uint newLevel, uint amount, uint timestamp);\r\n    event RootUserCreated(uint indexed rootUserId, address indexed rootAddress, uint timestamp);\r\n    \r\n    // Payments & income\r\n    event AdminFeePaid(uint amount, uint level, uint timestamp);\r\n    event ReferralPayment(uint indexed referrerId, uint indexed userId, uint amount, uint timestamp);\r\n    event SponsorCommissionPaid(uint indexed sponsorId, uint indexed fromUserId, uint amount, uint level, uint timestamp);\r\n    event MatrixPayment(uint indexed fromUserId, uint indexed toUserId, uint amount, uint level, uint layer, bool qualified, uint timestamp);\r\n    event IncomeLost(uint indexed userId, uint indexed fromUser, uint amount, string reason, uint timestamp);\r\n    event RoyaltyPoolFunded(uint indexed userId, uint amount, uint timestamp);\r\n    event RoyaltyClaimed(uint indexed userId, uint indexed royaltyLevel, uint amount, uint timestamp);\r\n    \r\n    // Ownership & Emergency\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipRenounced(address indexed previousOwner, uint timestamp);\r\n    event LevelCostUpdated(uint8 indexed level, uint256 oldCost, uint256 newCost, uint timestamp);\r\n    event ContractPaused(address indexed by, uint timestamp);\r\n    event ContractUnpaused(address indexed by, uint timestamp);\r\n    event RootFallbackIncome(uint amount, string source, uint timestamp);\r\n    \r\n    // ============ MODIFIERS ============\r\n    \r\n    modifier nonReentrant() {\r\n        require(unlocked == 1, \"Reentrancy detected\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n    \r\n    modifier validUser(uint _userId) {\r\n        require(_userId > 0 && userInfo[_userId].exists, \"Invalid user ID\");\r\n        _;\r\n    }\r\n    \r\n    // ============ CONSTRUCTOR ============\r\n    \r\n    constructor(\r\n        address _feeReceiver,\r\n        address _royalty,\r\n        address _rootUserAddress,\r\n        uint _rootUserId,\r\n        address _usdtToken\r\n    ) {\r\n        require(_feeReceiver != address(0), \"Invalid fee receiver\");\r\n        require(_royalty != address(0), \"Invalid royalty\");\r\n        require(_rootUserAddress != address(0), \"Invalid root address\");\r\n        require(_rootUserId > 0, \"Invalid root user ID\");\r\n        require(_usdtToken != address(0), \"Invalid USDT\");\r\n        \r\n        // Set immutables\r\n        FEE_RECEIVER = _feeReceiver;\r\n        ROYALTY_ADDR = IRoyalty(_royalty);\r\n        DEFAULT_REFER = _rootUserId;\r\n        START_TIME = block.timestamp;\r\n        USDT = IERC20(_usdtToken);\r\n        \r\n        // Set owner\r\n        owner = msg.sender;\r\n        \r\n        // Initialize root user\r\n        userIdCounter = DEFAULT_REFER;\r\n        id[_rootUserAddress] = DEFAULT_REFER;\r\n        _createUser(DEFAULT_REFER, _rootUserAddress, DEFAULT_REFER, DEFAULT_REFER, 12);\r\n        globalUsers.push(DEFAULT_REFER);\r\n        totalUsers = 1;\r\n        // Root user already has level 13 from _createUser (12 + 1)\r\n        \r\n        // Register root to all royalty tiers\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 10, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 11, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 12, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 13, 0);\r\n        \r\n        emit RootUserCreated(DEFAULT_REFER, _rootUserAddress, block.timestamp);\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n    \r\n    // ============ LEVEL COST HELPER ============\r\n    \r\n    /**\r\n     * @dev Get level cost in USDT (uses adjustable levelCosts array)\r\n     * @param _level Level index (0-12 for L1-L13)\r\n     * @return USDT cost in wei (18 decimals)\r\n     */\r\n    function _getLevelCost(uint _level) private view returns (uint) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        return levelCosts[_level];\r\n    }\r\n    \r\n    // ============ USER-FACING FUNCTIONS ============\r\n    \r\n    /**\r\n        if (_level == 7) return 320e18;     // $320\r\n        if (_level == 8) return 640e18;     // $640\r\n        if (_level == 9) return 1320e18;    // $1,320\r\n        if (_level == 10) return 2740e18;   // $2,740\r\n        if (_level == 11) return 5480e18;   // $5,480\r\n        if (_level == 12) return 10960e18;  // $10,960\r\n        revert(\"Invalid level\");\r\n    }\r\n    \r\n    // ============ USER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Register new user with USDT payment\r\n     * @param _ref Referrer user ID (0 = default)\r\n     * @param _newAcc New user wallet address\r\n     */\r\n    function register(uint _ref, address _newAcc) external nonReentrant whenNotPaused {\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly registration using referrer address\r\n     */\r\n    function registerMe(address _referrerAddress) external nonReentrant whenNotPaused {\r\n        uint _ref = (_referrerAddress == address(0)) ? 0 : id[_referrerAddress];\r\n        address _newAcc = msg.sender;\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice Upgrade user to higher levels with USDT\r\n     */\r\n    function upgrade(uint _id, uint _lvls) external nonReentrant whenNotPaused validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        require(userInfo[_id].level + _lvls <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        \r\n        // Calculate total cost\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        // Transfer USDT from user\r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        // Process each level\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[_id].level++;\r\n            userIncome[_id].totalDeposit += levelCost;\r\n            \r\n            // Pay admin fee\r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[_id].level - 1, block.timestamp);\r\n            }\r\n            \r\n            // Fund royalty pool (5% of levelCost)\r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n                emit RoyaltyPoolFunded(_id, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            // Distribute payments\r\n            uint remaining = _processSponsorCommission(_id, levelCost);\r\n            _distributeMatrixIncome(_id, userInfo[_id].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            // Register for royalty\r\n            ROYALTY_ADDR.registerUser(_id, userInfo[_id].level, userInfo[_id].directTeam);\r\n            \r\n            emit UserUpgraded(_id, userInfo[_id].level, levelCost, block.timestamp);\r\n            activity.push(Activity(_id, userInfo[_id].level, block.timestamp));\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly upgrade for caller\r\n     */\r\n    function upgradeMe(uint _levels) external nonReentrant whenNotPaused {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        require(msg.sender == userInfo[myId].account, \"Unauthorized\");\r\n        require(userInfo[myId].level + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[myId].level++;\r\n            userIncome[myId].totalDeposit += levelCost;\r\n            \r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[myId].level - 1, block.timestamp);\r\n            }\r\n            \r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");emit RoyaltyPoolFunded(myId, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            uint remaining = _processSponsorCommission(myId, levelCost);\r\n            _distributeMatrixIncome(myId, userInfo[myId].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            ROYALTY_ADDR.registerUser(myId, userInfo[myId].level, userInfo[myId].directTeam);\r\n            \r\n            emit UserUpgraded(myId, userInfo[myId].level, levelCost, block.timestamp);\r\n            activity.push(Activity(myId, userInfo[myId].level, block.timestamp));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim royalty reward\r\n     */\r\n    function claimRoyalty(uint _id, uint _royaltyLvl) external nonReentrant validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            _id,\r\n            _royaltyLvl,\r\n            DEFAULT_REFER,\r\n            userIncome[_id].totalIncome,\r\n            userIncome[_id].totalDeposit,\r\n            userInfo[_id].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(_id, _royaltyLvl, amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly royalty claim\r\n     */\r\n    function claimMyRoyalty(uint _tier) external nonReentrant {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            myId,\r\n            _tier,\r\n            DEFAULT_REFER,\r\n            userIncome[myId].totalIncome,\r\n            userIncome[myId].totalDeposit,\r\n            userInfo[myId].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(myId, _tier, amount, block.timestamp);\r\n    }\r\n    \r\n    // ============ OWNER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Renounce ownership - makes contract fully autonomous\r\n     * @dev IRREVERSIBLE - contract becomes ownerless forever\r\n     */\r\n    function renounceOwnership() external onlyOwner {\r\n        emit OwnershipRenounced(owner, block.timestamp);\r\n        owner = address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfer ownership to new address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Update level cost (owner only, before renouncing)\r\n     * @dev Allows flexibility during initial phase, becomes immutable after renounce\r\n     */\r\n    function setLevelCost(uint8 _level, uint256 _newCost) external onlyOwner {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        require(_newCost > 0, \"Cost must be positive\");\r\n        require(_newCost >= 1e18, \"Minimum cost is 1 USDT\");\r\n        require(_newCost <= 100000e18, \"Maximum cost is 100,000 USDT\");\r\n        \r\n        // Ensure costs are ascending (level n+1 > level n)\r\n        if (_level > 0) {\r\n            require(_newCost > levelCosts[_level - 1], \"Cost must increase\");\r\n        }\r\n        if (_level < MAX_LEVELS - 1) {\r\n            require(_newCost < levelCosts[_level + 1] || levelCosts[_level + 1] == 0, \"Cost must be less than next level\");\r\n        }\r\n        \r\n        uint256 oldCost = levelCosts[_level];\r\n        levelCosts[_level] = _newCost;\r\n        \r\n        emit LevelCostUpdated(_level, oldCost, _newCost, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Pause contract in case of emergency\r\n     * @dev Only owner can pause, prevents all user operations\r\n     */\r\n    function pauseContract() external onlyOwner {\r\n        require(!paused, \"Already paused\");\r\n        paused = true;\r\n        emit ContractPaused(msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Resume contract operations\r\n     */\r\n    function unpauseContract() external onlyOwner {\r\n        require(paused, \"Not paused\");\r\n        paused = false;\r\n        emit ContractUnpaused(msg.sender, block.timestamp);\r\n    }\r\n\r\n    \r\n    // ============ INTERNAL FUNCTIONS - PAYMENT DISTRIBUTION ============\r\n    \r\n    function _processRegistrationPayments(uint _newId, uint _levelCost, uint _adminFee) private {\r\n        // Pay admin fee (5%)\r\n        if (_adminFee > 0) {\r\n            require(USDT.transfer(FEE_RECEIVER, _adminFee), \"Admin fee failed\");\r\n            emit AdminFeePaid(_adminFee, 0, block.timestamp);\r\n        }\r\n        \r\n        // Fund royalty pool (5% of levelCost)\r\n        uint royaltyFundAmt = (_levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n        if (royaltyFundAmt > 0) {\r\n            require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n            emit RoyaltyPoolFunded(_newId, royaltyFundAmt, block.timestamp);\r\n        }\r\n        \r\n        // Referral income (95% = levelCost - royaltyFund)\r\n        uint _referrer = userInfo[_newId].referrer;\r\n        uint referralAmount = _levelCost - royaltyFundAmt;\r\n        \r\n        if (_referrer != 0 && userInfo[_referrer].exists) {\r\n            require(USDT.transfer(userInfo[_referrer].account, referralAmount), \"Referral failed\");\r\n            userIncome[_referrer].referralIncome += referralAmount;\r\n            userIncome[_referrer].totalIncome += referralAmount;\r\n            emit ReferralPayment(_referrer, _newId, referralAmount, block.timestamp);\r\n        } else {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, referralAmount), \"Default referral failed\");\r\n            userIncome[DEFAULT_REFER].referralIncome += referralAmount;\r\n            userIncome[DEFAULT_REFER].totalIncome += referralAmount;\r\n            emit ReferralPayment(DEFAULT_REFER, _newId, referralAmount, block.timestamp);\r\n        }\r\n        \r\n        // Note: For registration, income goes to Referrer, NOT matrix\r\n        // Matrix distribution only happens on upgrade\r\n    }\r\n\r\n    \r\n    function _processSponsorCommission(uint _id, uint _amount) private returns (uint) {\r\n        uint _referrer = userInfo[_id].referrer;\r\n        uint totalPaid = 0;\r\n        uint totalSponsorAllocation = (_amount * 500) / 10000;  // 5%\r\n        \r\n        // Distribute to up to 13 levels\r\n        for (uint8 level = 0; level < SPONSOR_LEVELS && _referrer != 0; level++) {\r\n            bool qualified = _isQualifiedForSponsorLevel(_referrer, level);\r\n            uint reward = (_amount * _getSponsorPercentage(level)) / 10000;\r\n            \r\n            if (qualified && reward > 0) {\r\n                bool success = USDT.transfer(userInfo[_referrer].account, reward);\r\n                if (success) {\r\n                    userIncome[_referrer].sponsorIncome += reward;\r\n                    userIncome[_referrer].totalIncome += reward;\r\n                    totalPaid += reward;\r\n                    \r\n                    emit SponsorCommissionPaid(_referrer, _id, reward, level + 1, block.timestamp);\r\n                }\r\n            } else if (reward > 0) {\r\n                // Track lost income only if upline exists\r\n                if (userInfo[_referrer].exists) {\r\n                    lostIncome[_referrer] += reward;\r\n                    \r\n                    string memory reason;\r\n                    if (level < 5) {\r\n                        reason = \"Not active (need Level 1+)\";\r\n                    } else if (level >= 5 && level < 8) {\r\n                        reason = \"Need 2+ direct referrals for L6-L8\";\r\n                    } else if (level >= 8 && level < 10) {\r\n                        reason = \"Need 3+ direct referrals for L9-L10\";\r\n                    } else {\r\n                        reason = \"Need 5+ direct referrals for L11-L13\";\r\n                    }\r\n                    \r\n                    emit IncomeLost(_referrer, _id,reward, reason, block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _referrer = userInfo[_referrer].referrer;\r\n        }\r\n        \r\n        // Fallback to root for unpaid commission\r\n        if (totalPaid < totalSponsorAllocation) {\r\n            uint unpaid = totalSponsorAllocation - totalPaid;\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, unpaid), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].sponsorIncome += unpaid;\r\n            userIncome[DEFAULT_REFER].totalIncome += unpaid;\r\n            emit RootFallbackIncome(unpaid, \"sponsor_commission\", block.timestamp);\r\n            totalPaid = totalSponsorAllocation;\r\n        }\r\n        \r\n        return _amount - totalPaid;  // Returns 95%\r\n    }\r\n    \r\n    \r\n    function _distributeMatrixIncome(uint _userId, uint _level, uint _amount, bool ignoreQualification) private {\r\n        uint _upline = userInfo[_userId].upline;\r\n        bool paid = false;\r\n        \r\n        // Search up to 13 levels for qualified upline\r\n        for (uint i = 0; i < MAX_INCOME_LAYER && _upline != 0; i++) {\r\n            bool qualified = ignoreQualification || \r\n                            (userInfo[_upline].level > _level && userInfo[_upline].directTeam >= DIRECT_REQUIRED);\r\n            \r\n            if (qualified) {\r\n                // Give FULL remaining amount (90%) to first qualified upline\r\n                bool success = USDT.transfer(userInfo[_upline].account, _amount);\r\n                if (success) {\r\n                    userIncome[_upline].levelIncome += _amount;\r\n                    userIncome[_upline].totalIncome += _amount;\r\n                    paid = true;\r\n                    \r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, true, block.timestamp);\r\n                }\r\n                break;  // Stop after first qualified upline gets paid\r\n            } else {\r\n                // Emit events for transparency, but DON'T track lostIncome\r\n                // (winner-takes-all model - only first qualified gets paid, so no real \"share\" lost)\r\n                if (userInfo[_upline].exists) {\r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, false, block.timestamp);\r\n                    emit IncomeLost(_upline, _userId, _amount, \"Not qualified for matrix\", block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _upline = userInfo[_upline].upline;\r\n        }\r\n        \r\n        // Fallback to root if no qualified upline found\r\n        if (!paid && _amount > 0) {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, _amount), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].levelIncome += _amount;\r\n            userIncome[DEFAULT_REFER].totalIncome += _amount;\r\n            emit RootFallbackIncome(_amount, \"matrix_income\", block.timestamp);\r\n        }\r\n    }\r\n\r\n    \r\n    function _isQualifiedForSponsorLevel(uint _userId, uint8 level) private view returns (bool) {\r\n        User storage user = userInfo[_userId];\r\n        \r\n        if (!user.exists || user.level < 1) return false;\r\n        \r\n        if (level < 5) {\r\n            return true;  // L1-L5: Just need Level 1+\r\n        } else if (level >= 5 && level < 8) {\r\n            return user.directTeam >= MIN_DIRECTS_L6_8;  // L6-L8: 2+ directs\r\n        } else if (level >= 8 && level < 10) {\r\n            return user.directTeam >= MIN_DIRECTS_L9_10;  // L9-L10: 3+ directs\r\n        } else {\r\n            return user.directTeam >= MIN_DIRECTS_L11_13;  // L11-L13: 5+ directs\r\n        }\r\n    }\r\n    \r\n    // ============ INTERNAL FUNCTIONS - USER & MATRIX ============\r\n    \r\n    function _createUser(uint _userId, address _account, uint _referrer, uint _upline, uint _level) private {\r\n        userInfo[_userId] = User({\r\n            exists: true,\r\n            account: _account,\r\n            referrer: _referrer,\r\n            upline: _upline,\r\n            level: _level + 1,\r\n            directTeam: 0,\r\n            team: 0,\r\n            registrationTime: block.timestamp\r\n        });\r\n        \r\n        userIncome[_userId] = UserIncome({\r\n            totalDeposit: 0,\r\n            totalIncome: 0,\r\n            referralIncome: 0,\r\n            sponsorIncome: 0,\r\n            levelIncome: 0\r\n        });\r\n        \r\n        if (_referrer != 0 && _referrer != _userId) {\r\n            userInfo[_referrer].directTeam++;\r\n            directReferrals[_referrer].push(_userId);  // Store in mapping for O(1) lookup\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Place new user in binary matrix using breadth-first search\r\n     * @param _newId ID of new user to place\r\n     * @param _ref Starting point (usually referrer)\r\n     * \r\n     * Searches for available spot (max 2 children per node) within MAX_PLACEMENT_DEPTH.\r\n     * If no spot found within depth limit, falls back to placing under root.\r\n     * This prevents infinite loops but may cluster users in very deep trees.\r\n     */\r\n    function _placeInBinaryMatrix(uint _newId, uint _ref) private {\r\n        uint[] memory queue = new uint[](MAX_PLACEMENT_DEPTH);\r\n        uint front = 0;\r\n        uint back = 0;\r\n        queue[back++] = _ref;\r\n        \r\n        bool placed = false;\r\n        uint iterations = 0;\r\n        \r\n        while (front < back && iterations < MAX_PLACEMENT_DEPTH) {\r\n            uint _upline = queue[front++];\r\n            iterations++;\r\n            \r\n            if (teams[_upline][0].length < 2) {\r\n                teams[_upline][0].push(_newId);\r\n                userInfo[_newId].upline = _upline;\r\n                matrixDirect[_upline]++;\r\n                placed = true;\r\n                break;\r\n            }\r\n            \r\n            for (uint i = 0; i < teams[_upline][0].length && back < MAX_PLACEMENT_DEPTH; i++) {\r\n                queue[back++] = teams[_upline][0][i];\r\n            }\r\n        }\r\n        \r\n        // Fallback to referrer if no spot found within depth limit\r\n        if (!placed) {\r\n            teams[_ref][0].push(_newId);\r\n            userInfo[_newId].upline = _ref;\r\n            matrixDirect[_ref]++;\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Update team counts - FIXED: Only increment once per new user\r\n     * Previously this was over-counting by incrementing multiple times\r\n     */\r\n    function _updateTeamCounts(uint _userId) private {\r\n        uint _upline = userInfo[_userId].referrer;\r\n        uint depth = 0;\r\n        \r\n        // Walk up referral chain and increment team count for each upline\r\n        // Each new user adds +1 to all uplines' team counts\r\n        while (_upline != 0 && depth < MAX_PLACEMENT_DEPTH) {\r\n            userInfo[_upline].team++;\r\n            _upline = userInfo[_upline].referrer;\r\n            depth++;\r\n        }\r\n    }\r\n    \r\n    // ============ VIEW FUNCTIONS ============\r\n    \r\n    function isAutonomous() external view returns (bool) {\r\n        return owner == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get user account address by ID (used by Royalty contract)\r\n     */\r\n    function getUserAccount(uint _userId) external view returns (address) {\r\n        return userInfo[_userId].account;\r\n    }\r\n    \r\n    function getLevelCost(uint _level) external view returns (uint cost, uint adminFee, uint total) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        cost = _getLevelCost(_level);\r\n        adminFee = (cost * ADMIN_FEE_PERCENT) / 100;\r\n        total = cost + adminFee;\r\n    }\r\n    \r\n    function getAllLevelCosts() external view returns (\r\n        uint[13] memory costs,\r\n        uint[13] memory fees,\r\n        uint[13] memory totals\r\n    ) {\r\n        for (uint i = 0; i < 13; i++) {\r\n            costs[i] = _getLevelCost(i);\r\n            fees[i] = (costs[i] * ADMIN_FEE_PERCENT) / 100;\r\n            totals[i] = costs[i] + fees[i];\r\n        }\r\n    }\r\n    \r\n    function getRegistrationCost() external view returns (uint cost, uint levelCost, uint adminFee) {\r\n        levelCost = _getLevelCost(0);\r\n        adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        cost = levelCost + adminFee;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for caller (for dApp use)\r\n     * @dev This version uses msg.sender - DOES NOT WORK on BSCScan Read Contract!\r\n     *      Use getUpgradeCostFor() on BSCScan instead\r\n     */\r\n    function getUpgradeCost(uint _levels) external view returns (uint totalCost, uint[] memory breakdown) {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[myId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);  // FIX: targetLevel is 1-13, need index 0-12\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for specific user (BSCScan-friendly!)\r\n     * @param _userAddress Address of the user to check\r\n     * @param _levels Number of levels to upgrade\r\n     * @return totalCost Total USDT cost (including admin fee)\r\n     * @return breakdown Cost breakdown per level\r\n     */\r\n    function getUpgradeCostFor(address _userAddress, uint _levels) \r\n        external view returns (uint totalCost, uint[] memory breakdown) \r\n    {\r\n        uint userId = id[_userAddress];\r\n        require(userId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[userId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    function getMyInfo() external view returns (\r\n        uint userId,\r\n        uint level,\r\n        uint team,\r\n        uint directTeam,\r\n        uint totalIncome,\r\n        uint referrerId,\r\n        uint uplineId,\r\n        uint registrationTime\r\n    ) {\r\n        userId = id[msg.sender];\r\n        if (userId == 0) return (0, 0, 0, 0, 0, 0, 0, 0);\r\n        \r\n        User storage user = userInfo[userId];\r\n        UserIncome storage income = userIncome[userId];\r\n        \r\n        return (\r\n            userId,\r\n            user.level,\r\n            user.team,\r\n            user.directTeam,\r\n            income.totalIncome,\r\n            user.referrer,\r\n            user.upline,\r\n            user.registrationTime\r\n        );\r\n    }\r\n    \r\n    function getMyIncomeBreakdown() external view returns (\r\n        uint totalDeposit,\r\n        uint totalIncome,\r\n        uint referralIncome,\r\n        uint sponsorIncome,\r\n        uint levelIncome,\r\n        uint lostAmount\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, 0, 0, 0, 0);\r\n        \r\n        UserIncome storage income = userIncome[myId];\r\n        return (\r\n            income.totalDeposit,\r\n            income.totalIncome,\r\n            income.referralIncome,\r\n            income.sponsorIncome,\r\n            income.levelIncome,\r\n            lostIncome[myId]\r\n        );\r\n    }\r\n    \r\n    function getMyTeam() external view returns (\r\n        uint teamSize,\r\n        uint directCount,\r\n        uint[] memory directReferralIds,\r\n        address[] memory directReferralAddresses\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, new uint[](0), new address[](0));\r\n        \r\n        User storage user = userInfo[myId];\r\n        teamSize = user.team;\r\n        directCount = user.directTeam;\r\n        \r\n        // Use mapping for O(1) lookup instead of O(N) loop\r\n        directReferralIds = directReferrals[myId];\r\n        \r\n        // Build addresses array\r\n        directReferralAddresses = new address[](directReferralIds.length);\r\n        for (uint i = 0; i < directReferralIds.length; i++) {\r\n            directReferralAddresses[i] = userInfo[directReferralIds[i]].account;\r\n        }\r\n    }\r\n    \r\n    function getMyRoyaltyStatus() external view returns (\r\n        uint[4] memory claimableAmounts,\r\n        bool[4] memory isEligible,\r\n        bool[4] memory hasClaimed\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (claimableAmounts, isEligible, hasClaimed);\r\n        \r\n        for (uint i = 0; i < 4; i++) {\r\n            (claimableAmounts[i], isEligible[i], hasClaimed[i]) = ROYALTY_ADDR.getUserRoyaltyData(myId, i);\r\n        }\r\n    }\r\n    \r\n    function isRegistered(address _address) external view returns (bool) {\r\n        return id[_address] > 0;\r\n    }\r\n    \r\n    function getContractBalance() external view returns (uint) {\r\n        return USDT.balanceOf(address(this));\r\n    }\r\n}\r\n"
    },
    "contracts/FiveDollarRide_BNB_Manual.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title FiveDollarRide - The $5 Opportunity Platform\r\n * @notice Revolutionary income platform starting at just $5 with USDT payments\r\n * @dev Owner-controlled smart contract with progressive decentralization capability\r\n * \r\n * Features:\r\n * - 13 Level progression ($5 to $20,480)\r\n * - Binary matrix tree structure  \r\n * - Multi-layer income distribution (20 layers)\r\n * - Sponsor commissions (13 levels)\r\n * - Royalty pool funding (5% per upgrade)\r\n * - USDT-based payments only\r\n * - Owner-controlled parameters (immutable after ownership renouncement)\r\n * - Full event-driven transparency\r\n * \r\n * Brand: FiveDollarRide - Your $5 Journey to Financial Freedom\r\n */\r\n// USDT Token Interface\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n// Royalty Contract Interface\r\ninterface IRoyalty {\r\n    function registerUser(uint _userId, uint _level, uint _directCount) external;\r\n    function claimRoyalty(\r\n        uint _id, \r\n        uint _tier,\r\n        uint rootUserId,\r\n        uint userTotalIncome,\r\n        uint userTotalDeposit,\r\n        address userAccount\r\n    ) external returns (uint);\r\n    function getUserRoyaltyData(uint _userId, uint _tier) external view returns (uint, bool, bool);\r\n    function getRoyaltyPercents() external view returns(uint[4] memory);\r\n    function getRoyaltyLevels() external view returns(uint[4] memory);\r\n    function getTierStats(uint _tier) external view returns(uint userCount, uint distributionRound, uint pendingUserCount);\r\n}\r\n\r\ncontract FiveDollarRide {\r\n    // ============ IMMUTABLE VALUES (SET AT DEPLOYMENT) ============\r\n    \r\n    address public immutable FEE_RECEIVER;\r\n    IERC20 public immutable USDT;\r\n    IRoyalty public immutable ROYALTY_ADDR;\r\n    uint private immutable DEFAULT_REFER;\r\n    uint public immutable START_TIME;\r\n    \r\n    // ============ CONSTANTS (HARDCODED FOREVER) ============\r\n    \r\n    // System constants\r\n    uint8 public constant MAX_LEVELS = 13;\r\n    uint8 public constant MAX_INCOME_LAYER = 13;  // Income distribution depth (matches 13 levels)\r\n    uint8 public constant MAX_PLACEMENT_DEPTH = 100;  // Placement search depth\r\n    // Note: If tree depth exceeds 100, placement falls back to root (DEFAULT_REFER)\r\n    // This prevents infinite loops but may cluster users under root in very large trees\r\n    \r\n    // Economic constants (adjustable by owner until renounced)\r\n    uint8 public constant ADMIN_FEE_PERCENT = 5;      // 5% admin fee\r\n    uint8 public constant ROYALTY_FUND_PERCENT = 5;   // 5% to royalty pool\r\n    \r\n    // Level costs (adjustable by owner, immutable after renounce)\r\n    // Starting costs: L1=$5, L2=$10, L3=$20... up to L13=$20,480 (hardcoded initially)\r\n    uint256[13] public levelCosts = [\r\n        5e18,      // L1: $5\r\n        10e18,     // L2: $10  \r\n        20e18,     // L3: $20\r\n        40e18,     // L4: $40\r\n        80e18,     // L5: $80\r\n        160e18,    // L6: $160\r\n        320e18,    // L7: $320\r\n        640e18,    // L8: $640\r\n        1280e18,   // L9: $1,280\r\n        2560e18,   // L10: $2,560\r\n        5120e18,   // L11: $5,120\r\n        10240e18,  // L12: $10,240\r\n        20480e18   // L13: $20,480\r\n    ];\r\n    \r\n    // Team & income constants\r\n    uint public constant DIRECT_REQUIRED = 2;\r\n    uint public constant MAX_REFERRAL_LAYERS = 1;\r\n    \r\n    // Sponsor commission (13 levels, total 5%)\r\n    uint8 private constant SPONSOR_LEVELS = 13;\r\n    \r\n    function _getSponsorPercentage(uint8 level) private pure returns (uint16) {\r\n        if (level == 0) return 100;   // L1: 1%\r\n        if (level == 1) return 80;    // L2: 0.8%\r\n        if (level == 2) return 60;    // L3: 0.6%\r\n        if (level == 3) return 50;    // L4: 0.5%\r\n        if (level == 4) return 50;    // L5: 0.5%\r\n        if (level == 5) return 40;    // L6: 0.4%\r\n        if (level == 6) return 30;    // L7: 0.3%\r\n        if (level == 7) return 25;    // L8: 0.25%\r\n        if (level == 8) return 20;    // L9: 0.2%\r\n        if (level == 9) return 15;    // L10: 0.15%\r\n        if (level == 10) return 10;   // L11: 0.1%\r\n        if (level == 11) return 10;   // L12: 0.1%\r\n        if (level == 12) return 10;   // L13: 0.1%\r\n        return 0;\r\n    }\r\n    \r\n    // Sponsor qualification thresholds\r\n    uint8 private constant MIN_DIRECTS_L6_8 = 2;\r\n    uint8 private constant MIN_DIRECTS_L9_10 = 3;\r\n    uint8 private constant MIN_DIRECTS_L11_13 = 5;\r\n    \r\n    \r\n    // ============ STATE VARIABLES ============\r\n    \r\n    // Owner (can renounce)\r\n    address public owner;\r\n    \r\n    // Emergency controls\r\n    bool public paused;\r\n    \r\n    // Reentrancy guard (improved pattern)\r\n    uint256 private unlocked = 1;\r\n    \r\n    // User tracking\r\n    uint public totalUsers;\r\n    uint private userIdCounter;\r\n    \r\n    // ============ DATA STRUCTURES ============\r\n    \r\n    struct User {\r\n        bool exists;\r\n        address account;\r\n        uint referrer;\r\n        uint upline;\r\n        uint level;\r\n        uint directTeam;\r\n        uint team;\r\n        uint registrationTime;\r\n    }\r\n    \r\n    struct UserIncome {\r\n        uint totalDeposit;\r\n        uint totalIncome;\r\n        uint referralIncome;\r\n        uint sponsorIncome;\r\n        uint levelIncome;\r\n    }\r\n    \r\n    struct Activity {\r\n        uint id;\r\n        uint level;\r\n        uint time;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => uint) public id;\r\n    mapping(uint => User) public userInfo;\r\n    mapping(uint => UserIncome) public userIncome;\r\n    mapping(uint => mapping(uint => uint[])) public teams;\r\n    mapping(uint => uint) public matrixDirect;\r\n    mapping(uint => uint) public lostIncome;\r\n    mapping(uint => uint[]) private directReferrals;  // NEW: O(1) direct team lookup\r\n    \r\n    uint[] private globalUsers;  // Changed to private (use events instead)\r\n    Activity[] private activity;  // Changed to private (use events instead)\r\n    \r\n    // ============ EVENTS ============\r\n    \r\n    // User lifecycle\r\n    event UserRegistered(uint indexed userId, address indexed account, uint indexed referrer, uint timestamp);\r\n    event UserUpgraded(uint indexed userId, uint newLevel, uint amount, uint timestamp);\r\n    event RootUserCreated(uint indexed rootUserId, address indexed rootAddress, uint timestamp);\r\n    \r\n    // Payments & income\r\n    event AdminFeePaid(uint amount, uint level, uint timestamp);\r\n    event ReferralPayment(uint indexed referrerId, uint indexed userId, uint amount, uint timestamp);\r\n    event SponsorCommissionPaid(uint indexed sponsorId, uint indexed fromUserId, uint amount, uint level, uint timestamp);\r\n    event MatrixPayment(uint indexed fromUserId, uint indexed toUserId, uint amount, uint level, uint layer, bool qualified, uint timestamp);\r\n    event IncomeLost(uint indexed userId, uint indexed fromUser, uint amount, string reason, uint timestamp);\r\n    event RoyaltyPoolFunded(uint indexed userId, uint amount, uint timestamp);\r\n    event RoyaltyClaimed(uint indexed userId, uint indexed royaltyLevel, uint amount, uint timestamp);\r\n    \r\n    // Ownership & Emergency\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipRenounced(address indexed previousOwner, uint timestamp);\r\n    event LevelCostUpdated(uint8 indexed level, uint256 oldCost, uint256 newCost, uint timestamp);\r\n    event ContractPaused(address indexed by, uint timestamp);\r\n    event ContractUnpaused(address indexed by, uint timestamp);\r\n    event RootFallbackIncome(uint amount, string source, uint timestamp);\r\n    \r\n    // ============ MODIFIERS ============\r\n    \r\n    modifier nonReentrant() {\r\n        require(unlocked == 1, \"Reentrancy detected\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n    \r\n    modifier validUser(uint _userId) {\r\n        require(_userId > 0 && userInfo[_userId].exists, \"Invalid user ID\");\r\n        _;\r\n    }\r\n    \r\n    // ============ CONSTRUCTOR ============\r\n    \r\n    constructor(\r\n        address _feeReceiver,\r\n        address _royalty,\r\n        address _rootUserAddress,\r\n        uint _rootUserId,\r\n        address _usdtToken\r\n    ) {\r\n        require(_feeReceiver != address(0), \"Invalid fee receiver\");\r\n        require(_royalty != address(0), \"Invalid royalty\");\r\n        require(_rootUserAddress != address(0), \"Invalid root address\");\r\n        require(_rootUserId > 0, \"Invalid root user ID\");\r\n        require(_usdtToken != address(0), \"Invalid USDT\");\r\n        \r\n        // Set immutables\r\n        FEE_RECEIVER = _feeReceiver;\r\n        ROYALTY_ADDR = IRoyalty(_royalty);\r\n        DEFAULT_REFER = _rootUserId;\r\n        START_TIME = block.timestamp;\r\n        USDT = IERC20(_usdtToken);\r\n        \r\n        // Set owner\r\n        owner = msg.sender;\r\n        \r\n        // Initialize root user\r\n        userIdCounter = DEFAULT_REFER;\r\n        id[_rootUserAddress] = DEFAULT_REFER;\r\n        _createUser(DEFAULT_REFER, _rootUserAddress, DEFAULT_REFER, DEFAULT_REFER, 12);\r\n        globalUsers.push(DEFAULT_REFER);\r\n        totalUsers = 1;\r\n        // Root user already has level 13 from _createUser (12 + 1)\r\n        \r\n        // Register root to all royalty tiers\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 10, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 11, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 12, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 13, 0);\r\n        \r\n        emit RootUserCreated(DEFAULT_REFER, _rootUserAddress, block.timestamp);\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n    \r\n    // ============ LEVEL COST HELPER ============\r\n    \r\n    /**\r\n     * @dev Get level cost in USDT (uses adjustable levelCosts array)\r\n     * @param _level Level index (0-12 for L1-L13)\r\n     * @return USDT cost in wei (18 decimals)\r\n     */\r\n    function _getLevelCost(uint _level) private view returns (uint) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        return levelCosts[_level];\r\n    }\r\n    \r\n    // ============ USER-FACING FUNCTIONS ============\r\n    \r\n    /**\r\n        if (_level == 7) return 320e18;     // $320\r\n        if (_level == 8) return 640e18;     // $640\r\n        if (_level == 9) return 1320e18;    // $1,320\r\n        if (_level == 10) return 2740e18;   // $2,740\r\n        if (_level == 11) return 5480e18;   // $5,480\r\n        if (_level == 12) return 10960e18;  // $10,960\r\n        revert(\"Invalid level\");\r\n    }\r\n    \r\n    // ============ USER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Register new user with USDT payment\r\n     * @param _ref Referrer user ID (0 = default)\r\n     * @param _newAcc New user wallet address\r\n     */\r\n    function register(uint _ref, address _newAcc) external nonReentrant whenNotPaused {\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly registration using referrer address\r\n     */\r\n    function registerMe(address _referrerAddress) external nonReentrant whenNotPaused {\r\n        uint _ref = (_referrerAddress == address(0)) ? 0 : id[_referrerAddress];\r\n        address _newAcc = msg.sender;\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice Upgrade user to higher levels with USDT\r\n     */\r\n    function upgrade(uint _id, uint _lvls) external nonReentrant whenNotPaused validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        require(userInfo[_id].level + _lvls <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        \r\n        // Calculate total cost\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        // Transfer USDT from user\r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        // Process each level\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[_id].level++;\r\n            userIncome[_id].totalDeposit += levelCost;\r\n            \r\n            // Pay admin fee\r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[_id].level - 1, block.timestamp);\r\n            }\r\n            \r\n            // Fund royalty pool (5% of levelCost)\r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n                emit RoyaltyPoolFunded(_id, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            // Distribute payments\r\n            uint remaining = _processSponsorCommission(_id, levelCost);\r\n            _distributeMatrixIncome(_id, userInfo[_id].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            // Register for royalty\r\n            ROYALTY_ADDR.registerUser(_id, userInfo[_id].level, userInfo[_id].directTeam);\r\n            \r\n            emit UserUpgraded(_id, userInfo[_id].level, levelCost, block.timestamp);\r\n            activity.push(Activity(_id, userInfo[_id].level, block.timestamp));\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly upgrade for caller\r\n     */\r\n    function upgradeMe(uint _levels) external nonReentrant whenNotPaused {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        require(msg.sender == userInfo[myId].account, \"Unauthorized\");\r\n        require(userInfo[myId].level + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[myId].level++;\r\n            userIncome[myId].totalDeposit += levelCost;\r\n            \r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[myId].level - 1, block.timestamp);\r\n            }\r\n            \r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");emit RoyaltyPoolFunded(myId, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            uint remaining = _processSponsorCommission(myId, levelCost);\r\n            _distributeMatrixIncome(myId, userInfo[myId].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            ROYALTY_ADDR.registerUser(myId, userInfo[myId].level, userInfo[myId].directTeam);\r\n            \r\n            emit UserUpgraded(myId, userInfo[myId].level, levelCost, block.timestamp);\r\n            activity.push(Activity(myId, userInfo[myId].level, block.timestamp));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim royalty reward\r\n     */\r\n    function claimRoyalty(uint _id, uint _royaltyLvl) external nonReentrant validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            _id,\r\n            _royaltyLvl,\r\n            DEFAULT_REFER,\r\n            userIncome[_id].totalIncome,\r\n            userIncome[_id].totalDeposit,\r\n            userInfo[_id].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(_id, _royaltyLvl, amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly royalty claim\r\n     */\r\n    function claimMyRoyalty(uint _tier) external nonReentrant {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            myId,\r\n            _tier,\r\n            DEFAULT_REFER,\r\n            userIncome[myId].totalIncome,\r\n            userIncome[myId].totalDeposit,\r\n            userInfo[myId].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(myId, _tier, amount, block.timestamp);\r\n    }\r\n    \r\n    // ============ OWNER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Renounce ownership - makes contract fully autonomous\r\n     * @dev IRREVERSIBLE - contract becomes ownerless forever\r\n     */\r\n    function renounceOwnership() external onlyOwner {\r\n        emit OwnershipRenounced(owner, block.timestamp);\r\n        owner = address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfer ownership to new address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Update level cost (owner only, before renouncing)\r\n     * @dev Allows flexibility during initial phase, becomes immutable after renounce\r\n     */\r\n    function setLevelCost(uint8 _level, uint256 _newCost) external onlyOwner {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        require(_newCost > 0, \"Cost must be positive\");\r\n        require(_newCost >= 1e18, \"Minimum cost is 1 USDT\");\r\n        require(_newCost <= 100000e18, \"Maximum cost is 100,000 USDT\");\r\n        \r\n        // Ensure costs are ascending (level n+1 > level n)\r\n        if (_level > 0) {\r\n            require(_newCost > levelCosts[_level - 1], \"Cost must increase\");\r\n        }\r\n        if (_level < MAX_LEVELS - 1) {\r\n            require(_newCost < levelCosts[_level + 1] || levelCosts[_level + 1] == 0, \"Cost must be less than next level\");\r\n        }\r\n        \r\n        uint256 oldCost = levelCosts[_level];\r\n        levelCosts[_level] = _newCost;\r\n        \r\n        emit LevelCostUpdated(_level, oldCost, _newCost, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Pause contract in case of emergency\r\n     * @dev Only owner can pause, prevents all user operations\r\n     */\r\n    function pauseContract() external onlyOwner {\r\n        require(!paused, \"Already paused\");\r\n        paused = true;\r\n        emit ContractPaused(msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Resume contract operations\r\n     */\r\n    function unpauseContract() external onlyOwner {\r\n        require(paused, \"Not paused\");\r\n        paused = false;\r\n        emit ContractUnpaused(msg.sender, block.timestamp);\r\n    }\r\n\r\n    \r\n    // ============ INTERNAL FUNCTIONS - PAYMENT DISTRIBUTION ============\r\n    \r\n    function _processRegistrationPayments(uint _newId, uint _levelCost, uint _adminFee) private {\r\n        // Pay admin fee (5%)\r\n        if (_adminFee > 0) {\r\n            require(USDT.transfer(FEE_RECEIVER, _adminFee), \"Admin fee failed\");\r\n            emit AdminFeePaid(_adminFee, 0, block.timestamp);\r\n        }\r\n        \r\n        // Fund royalty pool (5% of levelCost)\r\n        uint royaltyFundAmt = (_levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n        if (royaltyFundAmt > 0) {\r\n            require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n            emit RoyaltyPoolFunded(_newId, royaltyFundAmt, block.timestamp);\r\n        }\r\n        \r\n        // Referral income (95% = levelCost - royaltyFund)\r\n        uint _referrer = userInfo[_newId].referrer;\r\n        uint referralAmount = _levelCost - royaltyFundAmt;\r\n        \r\n        if (_referrer != 0 && userInfo[_referrer].exists) {\r\n            require(USDT.transfer(userInfo[_referrer].account, referralAmount), \"Referral failed\");\r\n            userIncome[_referrer].referralIncome += referralAmount;\r\n            userIncome[_referrer].totalIncome += referralAmount;\r\n            emit ReferralPayment(_referrer, _newId, referralAmount, block.timestamp);\r\n        } else {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, referralAmount), \"Default referral failed\");\r\n            userIncome[DEFAULT_REFER].referralIncome += referralAmount;\r\n            userIncome[DEFAULT_REFER].totalIncome += referralAmount;\r\n            emit ReferralPayment(DEFAULT_REFER, _newId, referralAmount, block.timestamp);\r\n        }\r\n        \r\n        // Note: For registration, income goes to Referrer, NOT matrix\r\n        // Matrix distribution only happens on upgrade\r\n    }\r\n\r\n    \r\n    function _processSponsorCommission(uint _id, uint _amount) private returns (uint) {\r\n        uint _referrer = userInfo[_id].referrer;\r\n        uint totalPaid = 0;\r\n        uint totalSponsorAllocation = (_amount * 500) / 10000;  // 5%\r\n        \r\n        // Distribute to up to 13 levels\r\n        for (uint8 level = 0; level < SPONSOR_LEVELS && _referrer != 0; level++) {\r\n            bool qualified = _isQualifiedForSponsorLevel(_referrer, level);\r\n            uint reward = (_amount * _getSponsorPercentage(level)) / 10000;\r\n            \r\n            if (qualified && reward > 0) {\r\n                bool success = USDT.transfer(userInfo[_referrer].account, reward);\r\n                if (success) {\r\n                    userIncome[_referrer].sponsorIncome += reward;\r\n                    userIncome[_referrer].totalIncome += reward;\r\n                    totalPaid += reward;\r\n                    \r\n                    emit SponsorCommissionPaid(_referrer, _id, reward, level + 1, block.timestamp);\r\n                }\r\n            } else if (reward > 0) {\r\n                // Track lost income only if upline exists\r\n                if (userInfo[_referrer].exists) {\r\n                    lostIncome[_referrer] += reward;\r\n                    \r\n                    string memory reason;\r\n                    if (level < 5) {\r\n                        reason = \"Not active (need Level 1+)\";\r\n                    } else if (level >= 5 && level < 8) {\r\n                        reason = \"Need 2+ direct referrals for L6-L8\";\r\n                    } else if (level >= 8 && level < 10) {\r\n                        reason = \"Need 3+ direct referrals for L9-L10\";\r\n                    } else {\r\n                        reason = \"Need 5+ direct referrals for L11-L13\";\r\n                    }\r\n                    \r\n                    emit IncomeLost(_referrer, _id,reward, reason, block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _referrer = userInfo[_referrer].referrer;\r\n        }\r\n        \r\n        // Fallback to root for unpaid commission\r\n        if (totalPaid < totalSponsorAllocation) {\r\n            uint unpaid = totalSponsorAllocation - totalPaid;\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, unpaid), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].sponsorIncome += unpaid;\r\n            userIncome[DEFAULT_REFER].totalIncome += unpaid;\r\n            emit RootFallbackIncome(unpaid, \"sponsor_commission\", block.timestamp);\r\n            totalPaid = totalSponsorAllocation;\r\n        }\r\n        \r\n        return _amount - totalPaid;  // Returns 95%\r\n    }\r\n    \r\n    \r\n    function _distributeMatrixIncome(uint _userId, uint _level, uint _amount, bool ignoreQualification) private {\r\n        uint _upline = userInfo[_userId].upline;\r\n        bool paid = false;\r\n        \r\n        // Search up to 13 levels for qualified upline\r\n        for (uint i = 0; i < MAX_INCOME_LAYER && _upline != 0; i++) {\r\n            bool qualified = ignoreQualification || \r\n                            (userInfo[_upline].level > _level && userInfo[_upline].directTeam >= DIRECT_REQUIRED);\r\n            \r\n            if (qualified) {\r\n                // Give FULL remaining amount (90%) to first qualified upline\r\n                bool success = USDT.transfer(userInfo[_upline].account, _amount);\r\n                if (success) {\r\n                    userIncome[_upline].levelIncome += _amount;\r\n                    userIncome[_upline].totalIncome += _amount;\r\n                    paid = true;\r\n                    \r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, true, block.timestamp);\r\n                }\r\n                break;  // Stop after first qualified upline gets paid\r\n            } else {\r\n                // Emit events for transparency, but DON'T track lostIncome\r\n                // (winner-takes-all model - only first qualified gets paid, so no real \"share\" lost)\r\n                if (userInfo[_upline].exists) {\r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, false, block.timestamp);\r\n                    emit IncomeLost(_upline, _userId, _amount, \"Not qualified for matrix\", block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _upline = userInfo[_upline].upline;\r\n        }\r\n        \r\n        // Fallback to root if no qualified upline found\r\n        if (!paid && _amount > 0) {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, _amount), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].levelIncome += _amount;\r\n            userIncome[DEFAULT_REFER].totalIncome += _amount;\r\n            emit RootFallbackIncome(_amount, \"matrix_income\", block.timestamp);\r\n        }\r\n    }\r\n\r\n    \r\n    function _isQualifiedForSponsorLevel(uint _userId, uint8 level) private view returns (bool) {\r\n        User storage user = userInfo[_userId];\r\n        \r\n        if (!user.exists || user.level < 1) return false;\r\n        \r\n        if (level < 5) {\r\n            return true;  // L1-L5: Just need Level 1+\r\n        } else if (level >= 5 && level < 8) {\r\n            return user.directTeam >= MIN_DIRECTS_L6_8;  // L6-L8: 2+ directs\r\n        } else if (level >= 8 && level < 10) {\r\n            return user.directTeam >= MIN_DIRECTS_L9_10;  // L9-L10: 3+ directs\r\n        } else {\r\n            return user.directTeam >= MIN_DIRECTS_L11_13;  // L11-L13: 5+ directs\r\n        }\r\n    }\r\n    \r\n    // ============ INTERNAL FUNCTIONS - USER & MATRIX ============\r\n    \r\n    function _createUser(uint _userId, address _account, uint _referrer, uint _upline, uint _level) private {\r\n        userInfo[_userId] = User({\r\n            exists: true,\r\n            account: _account,\r\n            referrer: _referrer,\r\n            upline: _upline,\r\n            level: _level + 1,\r\n            directTeam: 0,\r\n            team: 0,\r\n            registrationTime: block.timestamp\r\n        });\r\n        \r\n        userIncome[_userId] = UserIncome({\r\n            totalDeposit: 0,\r\n            totalIncome: 0,\r\n            referralIncome: 0,\r\n            sponsorIncome: 0,\r\n            levelIncome: 0\r\n        });\r\n        \r\n        if (_referrer != 0 && _referrer != _userId) {\r\n            userInfo[_referrer].directTeam++;\r\n            directReferrals[_referrer].push(_userId);  // Store in mapping for O(1) lookup\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Place new user in binary matrix using breadth-first search\r\n     * @param _newId ID of new user to place\r\n     * @param _ref Starting point (usually referrer)\r\n     * \r\n     * Searches for available spot (max 2 children per node) within MAX_PLACEMENT_DEPTH.\r\n     * If no spot found within depth limit, falls back to placing under root.\r\n     * This prevents infinite loops but may cluster users in very deep trees.\r\n     */\r\n    function _placeInBinaryMatrix(uint _newId, uint _ref) private {\r\n        uint[] memory queue = new uint[](MAX_PLACEMENT_DEPTH);\r\n        uint front = 0;\r\n        uint back = 0;\r\n        queue[back++] = _ref;\r\n        \r\n        bool placed = false;\r\n        uint iterations = 0;\r\n        \r\n        while (front < back && iterations < MAX_PLACEMENT_DEPTH) {\r\n            uint _upline = queue[front++];\r\n            iterations++;\r\n            \r\n            if (teams[_upline][0].length < 2) {\r\n                teams[_upline][0].push(_newId);\r\n                userInfo[_newId].upline = _upline;\r\n                matrixDirect[_upline]++;\r\n                placed = true;\r\n                break;\r\n            }\r\n            \r\n            for (uint i = 0; i < teams[_upline][0].length && back < MAX_PLACEMENT_DEPTH; i++) {\r\n                queue[back++] = teams[_upline][0][i];\r\n            }\r\n        }\r\n        \r\n        // Fallback to referrer if no spot found within depth limit\r\n        if (!placed) {\r\n            teams[_ref][0].push(_newId);\r\n            userInfo[_newId].upline = _ref;\r\n            matrixDirect[_ref]++;\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Update team counts - FIXED: Only increment once per new user\r\n     * Previously this was over-counting by incrementing multiple times\r\n     */\r\n    function _updateTeamCounts(uint _userId) private {\r\n        uint _upline = userInfo[_userId].referrer;\r\n        uint depth = 0;\r\n        \r\n        // Walk up referral chain and increment team count for each upline\r\n        // Each new user adds +1 to all uplines' team counts\r\n        while (_upline != 0 && depth < MAX_PLACEMENT_DEPTH) {\r\n            userInfo[_upline].team++;\r\n            _upline = userInfo[_upline].referrer;\r\n            depth++;\r\n        }\r\n    }\r\n    \r\n    // ============ VIEW FUNCTIONS ============\r\n    \r\n    function isAutonomous() external view returns (bool) {\r\n        return owner == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get user account address by ID (used by Royalty contract)\r\n     */\r\n    function getUserAccount(uint _userId) external view returns (address) {\r\n        return userInfo[_userId].account;\r\n    }\r\n    \r\n    function getLevelCost(uint _level) external view returns (uint cost, uint adminFee, uint total) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        cost = _getLevelCost(_level);\r\n        adminFee = (cost * ADMIN_FEE_PERCENT) / 100;\r\n        total = cost + adminFee;\r\n    }\r\n    \r\n    function getAllLevelCosts() external view returns (\r\n        uint[13] memory costs,\r\n        uint[13] memory fees,\r\n        uint[13] memory totals\r\n    ) {\r\n        for (uint i = 0; i < 13; i++) {\r\n            costs[i] = _getLevelCost(i);\r\n            fees[i] = (costs[i] * ADMIN_FEE_PERCENT) / 100;\r\n            totals[i] = costs[i] + fees[i];\r\n        }\r\n    }\r\n    \r\n    function getRegistrationCost() external view returns (uint cost, uint levelCost, uint adminFee) {\r\n        levelCost = _getLevelCost(0);\r\n        adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        cost = levelCost + adminFee;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for caller (for dApp use)\r\n     * @dev This version uses msg.sender - DOES NOT WORK on BSCScan Read Contract!\r\n     *      Use getUpgradeCostFor() on BSCScan instead\r\n     */\r\n    function getUpgradeCost(uint _levels) external view returns (uint totalCost, uint[] memory breakdown) {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[myId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);  // FIX: targetLevel is 1-13, need index 0-12\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for specific user (BSCScan-friendly!)\r\n     * @param _userAddress Address of the user to check\r\n     * @param _levels Number of levels to upgrade\r\n     * @return totalCost Total USDT cost (including admin fee)\r\n     * @return breakdown Cost breakdown per level\r\n     */\r\n    function getUpgradeCostFor(address _userAddress, uint _levels) \r\n        external view returns (uint totalCost, uint[] memory breakdown) \r\n    {\r\n        uint userId = id[_userAddress];\r\n        require(userId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[userId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    function getMyInfo() external view returns (\r\n        uint userId,\r\n        uint level,\r\n        uint team,\r\n        uint directTeam,\r\n        uint totalIncome,\r\n        uint referrerId,\r\n        uint uplineId,\r\n        uint registrationTime\r\n    ) {\r\n        userId = id[msg.sender];\r\n        if (userId == 0) return (0, 0, 0, 0, 0, 0, 0, 0);\r\n        \r\n        User storage user = userInfo[userId];\r\n        UserIncome storage income = userIncome[userId];\r\n        \r\n        return (\r\n            userId,\r\n            user.level,\r\n            user.team,\r\n            user.directTeam,\r\n            income.totalIncome,\r\n            user.referrer,\r\n            user.upline,\r\n            user.registrationTime\r\n        );\r\n    }\r\n    \r\n    function getMyIncomeBreakdown() external view returns (\r\n        uint totalDeposit,\r\n        uint totalIncome,\r\n        uint referralIncome,\r\n        uint sponsorIncome,\r\n        uint levelIncome,\r\n        uint lostAmount\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, 0, 0, 0, 0);\r\n        \r\n        UserIncome storage income = userIncome[myId];\r\n        return (\r\n            income.totalDeposit,\r\n            income.totalIncome,\r\n            income.referralIncome,\r\n            income.sponsorIncome,\r\n            income.levelIncome,\r\n            lostIncome[myId]\r\n        );\r\n    }\r\n    \r\n    function getMyTeam() external view returns (\r\n        uint teamSize,\r\n        uint directCount,\r\n        uint[] memory directReferralIds,\r\n        address[] memory directReferralAddresses\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, new uint[](0), new address[](0));\r\n        \r\n        User storage user = userInfo[myId];\r\n        teamSize = user.team;\r\n        directCount = user.directTeam;\r\n        \r\n        // Use mapping for O(1) lookup instead of O(N) loop\r\n        directReferralIds = directReferrals[myId];\r\n        \r\n        // Build addresses array\r\n        directReferralAddresses = new address[](directReferralIds.length);\r\n        for (uint i = 0; i < directReferralIds.length; i++) {\r\n            directReferralAddresses[i] = userInfo[directReferralIds[i]].account;\r\n        }\r\n    }\r\n    \r\n    function getMyRoyaltyStatus() external view returns (\r\n        uint[4] memory claimableAmounts,\r\n        bool[4] memory isEligible,\r\n        bool[4] memory hasClaimed\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (claimableAmounts, isEligible, hasClaimed);\r\n        \r\n        for (uint i = 0; i < 4; i++) {\r\n            (claimableAmounts[i], isEligible[i], hasClaimed[i]) = ROYALTY_ADDR.getUserRoyaltyData(myId, i);\r\n        }\r\n    }\r\n    \r\n    function isRegistered(address _address) external view returns (bool) {\r\n        return id[_address] > 0;\r\n    }\r\n    \r\n    function getContractBalance() external view returns (uint) {\r\n        return USDT.balanceOf(address(this));\r\n    }\r\n}\r\n"
    },
    "contracts/FiveDollarRide_BNB_Pure.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title FiveDollarRide - The $5 Opportunity Platform\r\n * @notice Revolutionary income platform starting at just $5 with BNB payments\r\n * @dev Owner-controlled smart contract with progressive decentralization capability\r\n * \r\n * Features:\r\n * - 13 Level progression ($5 to $20,480 in BNB)\r\n * - Binary matrix tree structure  \r\n * - Multi-layer income distribution (20 layers)\r\n * - Sponsor commissions (13 levels)\r\n * - Royalty pool funding (5% per upgrade)\r\n * - Native BNB payments (no token approvals needed)\r\n * - Owner-controlled parameters (immutable after ownership renouncement)\r\n * - Full event-driven transparency\r\n * \r\n * Brand: FiveDollarRide - Your $5 Journey to Financial Freedom\r\n */\r\n\r\n\r\n// Royalty Contract Interface\r\ninterface IRoyalty {\r\n    function registerUser(uint _userId, uint _level, uint _directCount) external;\r\n    function claimRoyalty(\r\n        uint _id, \r\n        uint _tier,\r\n        uint rootUserId,\r\n        uint userTotalIncome,\r\n        uint userTotalDeposit,\r\n        address userAccount\r\n    ) external returns (uint);\r\n    function getUserRoyaltyData(uint _userId, uint _tier) external view returns (uint, bool, bool);\r\n    function getRoyaltyPercents() external view returns(uint[4] memory);\r\n    function getRoyaltyLevels() external view returns(uint[4] memory);\r\n    function getTierStats(uint _tier) external view returns(uint userCount, uint distributionRound, uint pendingUserCount);\r\n}\r\n\r\ncontract FiveDollarRide {\r\n    // ============ IMMUTABLE VALUES (SET AT DEPLOYMENT) ============\r\n    \r\n    address public immutable FEE_RECEIVER;\r\n\r\n    IRoyalty public immutable ROYALTY_ADDR;\r\n    uint private immutable DEFAULT_REFER;\r\n    uint public immutable START_TIME;\r\n    \r\n    // ============ CONSTANTS (HARDCODED FOREVER) ============\r\n    \r\n    // System constants\r\n    uint8 public constant MAX_LEVELS = 13;\r\n    uint8 public constant MAX_INCOME_LAYER = 13;  // Income distribution depth (matches 13 levels)\r\n    uint8 public constant MAX_PLACEMENT_DEPTH = 100;  // Placement search depth\r\n    // Note: If tree depth exceeds 100, placement falls back to root (DEFAULT_REFER)\r\n    // This prevents infinite loops but may cluster users under root in very large trees\r\n    \r\n    // Dynamic Pricing\r\n    uint256 public bnbPrice = 600e18; // Default $600 (Updated by owner)\r\n    \r\n    // Economic constants (adjustable by owner until renounced)\r\n    uint8 public constant ADMIN_FEE_PERCENT = 5;      // 5% admin fee\r\n    uint8 public constant ROYALTY_FUND_PERCENT = 5;   // 5% to royalty pool\r\n    \r\n    // Level costs (adjustable by owner, immutable after renounce)\r\n    // Starting costs: L1=$5, L2=$10, L3=$20... up to L13=$20,480 (hardcoded initially)\r\n    uint256[13] public levelCosts = [\r\n        5e18,      // L1: $5\r\n        10e18,     // L2: $10  \r\n        20e18,     // L3: $20\r\n        40e18,     // L4: $40\r\n        80e18,     // L5: $80\r\n        160e18,    // L6: $160\r\n        320e18,    // L7: $320\r\n        640e18,    // L8: $640\r\n        1280e18,   // L9: $1,280\r\n        2560e18,   // L10: $2,560\r\n        5120e18,   // L11: $5,120\r\n        10240e18,  // L12: $10,240\r\n        20480e18   // L13: $20,480\r\n    ];\r\n    \r\n    // Team & income constants\r\n    uint public constant DIRECT_REQUIRED = 2;\r\n    uint public constant MAX_REFERRAL_LAYERS = 1;\r\n    \r\n    // Sponsor commission (13 levels, total 5%)\r\n    uint8 private constant SPONSOR_LEVELS = 13;\r\n    \r\n    function _getSponsorPercentage(uint8 level) private pure returns (uint16) {\r\n        if (level == 0) return 100;   // L1: 1%\r\n        if (level == 1) return 80;    // L2: 0.8%\r\n        if (level == 2) return 60;    // L3: 0.6%\r\n        if (level == 3) return 50;    // L4: 0.5%\r\n        if (level == 4) return 50;    // L5: 0.5%\r\n        if (level == 5) return 40;    // L6: 0.4%\r\n        if (level == 6) return 30;    // L7: 0.3%\r\n        if (level == 7) return 25;    // L8: 0.25%\r\n        if (level == 8) return 20;    // L9: 0.2%\r\n        if (level == 9) return 15;    // L10: 0.15%\r\n        if (level == 10) return 10;   // L11: 0.1%\r\n        if (level == 11) return 10;   // L12: 0.1%\r\n        if (level == 12) return 10;   // L13: 0.1%\r\n        return 0;\r\n    }\r\n    \r\n    // Sponsor qualification thresholds\r\n    uint8 private constant MIN_DIRECTS_L6_8 = 2;\r\n    uint8 private constant MIN_DIRECTS_L9_10 = 3;\r\n    uint8 private constant MIN_DIRECTS_L11_13 = 5;\r\n    \r\n    \r\n    // ============ STATE VARIABLES ============\r\n    \r\n    // Owner (can renounce)\r\n    address public owner;\r\n    \r\n    // Emergency controls\r\n    bool public paused;\r\n    \r\n    // Reentrancy guard (improved pattern)\r\n    uint256 private unlocked = 1;\r\n    \r\n    // User tracking\r\n    uint public totalUsers;\r\n    uint private userIdCounter;\r\n    \r\n    // ============ DATA STRUCTURES ============\r\n    \r\n    struct User {\r\n        bool exists;\r\n        address account;\r\n        uint referrer;\r\n        uint upline;\r\n        uint level;\r\n        uint directTeam;\r\n        uint team;\r\n        uint registrationTime;\r\n    }\r\n    \r\n    struct UserIncome {\r\n        uint totalDeposit;\r\n        uint totalIncome;\r\n        uint referralIncome;\r\n        uint sponsorIncome;\r\n        uint levelIncome;\r\n    }\r\n    \r\n    struct Activity {\r\n        uint id;\r\n        uint level;\r\n        uint time;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => uint) public id;\r\n    mapping(uint => User) public userInfo;\r\n    mapping(uint => UserIncome) public userIncome;\r\n    mapping(uint => mapping(uint => uint[])) public teams;\r\n    mapping(uint => uint) public matrixDirect;\r\n    mapping(uint => uint) public lostIncome;\r\n    mapping(uint => uint[]) private directReferrals;  // NEW: O(1) direct team lookup\r\n    \r\n    uint[] private globalUsers;  // Changed to private (use events instead)\r\n    Activity[] private activity;  // Changed to private (use events instead)\r\n    \r\n    // ============ EVENTS ============\r\n    \r\n    // User lifecycle\r\n    event UserRegistered(uint indexed userId, address indexed account, uint indexed referrer, uint timestamp);\r\n    event UserUpgraded(uint indexed userId, uint newLevel, uint amount, uint timestamp);\r\n    event RootUserCreated(uint indexed rootUserId, address indexed rootAddress, uint timestamp);\r\n    \r\n    // Payments & income\r\n    event AdminFeePaid(uint amount, uint level, uint timestamp);\r\n    event ReferralPayment(uint indexed referrerId, uint indexed userId, uint amount, uint timestamp);\r\n    event SponsorCommissionPaid(uint indexed sponsorId, uint indexed fromUserId, uint amount, uint level, uint timestamp);\r\n    event MatrixPayment(uint indexed fromUserId, uint indexed toUserId, uint amount, uint level, uint layer, bool qualified, uint timestamp);\r\n    event IncomeLost(uint indexed userId, uint indexed fromUser, uint amount, string reason, uint timestamp);\r\n    event RoyaltyPoolFunded(uint indexed userId, uint amount, uint timestamp);\r\n    event RoyaltyClaimed(uint indexed userId, uint indexed royaltyLevel, uint amount, uint timestamp);\r\n    \r\n    // Ownership & Emergency\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipRenounced(address indexed previousOwner, uint timestamp);\r\n    event LevelCostUpdated(uint8 indexed level, uint256 oldCost, uint256 newCost, uint timestamp);\r\n    event ContractPaused(address indexed by, uint timestamp);\r\n    event ContractUnpaused(address indexed by, uint timestamp);\r\n    event RootFallbackIncome(uint amount, string source, uint timestamp);\r\n    event BNBPriceUpdated(uint oldPrice, uint newPrice, uint timestamp);\r\n    \r\n    // ============ MODIFIERS ============\r\n    \r\n    modifier nonReentrant() {\r\n        require(unlocked == 1, \"Reentrancy detected\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n    \r\n    modifier validUser(uint _userId) {\r\n        require(_userId > 0 && userInfo[_userId].exists, \"Invalid user ID\");\r\n        _;\r\n    }\r\n    \r\n    \r\n    // ============ RECEIVE FUNCTION ============\r\n    \r\n    /**\r\n     * @notice Accept BNB payments\r\n     */\r\n    receive() external payable {}\r\n    \r\n// ============ CONSTRUCTOR ============\r\n    \r\n    constructor(\r\n        address _feeReceiver,\r\n        address _royalty,\r\n        address _rootUserAddress,\r\n        uint _rootUserId\r\n    ) {\r\n        require(_feeReceiver != address(0), \"Invalid fee receiver\");\r\n        require(_royalty != address(0), \"Invalid royalty\");\r\n        require(_rootUserAddress != address(0), \"Invalid root address\");\r\n        require(_rootUserId > 0, \"Invalid root user ID\");\r\n\r\n        \r\n        // Set immutables\r\n        FEE_RECEIVER = _feeReceiver;\r\n        ROYALTY_ADDR = IRoyalty(_royalty);\r\n        DEFAULT_REFER = _rootUserId;\r\n        START_TIME = block.timestamp;\r\n\r\n        \r\n        // Set owner\r\n        owner = msg.sender;\r\n        \r\n        // Initialize root user\r\n        userIdCounter = DEFAULT_REFER;\r\n        id[_rootUserAddress] = DEFAULT_REFER;\r\n        _createUser(DEFAULT_REFER, _rootUserAddress, DEFAULT_REFER, DEFAULT_REFER, 12);\r\n        globalUsers.push(DEFAULT_REFER);\r\n        totalUsers = 1;\r\n        // Root user already has level 13 from _createUser (12 + 1)\r\n        \r\n        // NOTE: Royalty registration moved to initializeRoyalty() function\r\n        // This must be called after deployment when contracts are connected\r\n        \r\n        emit RootUserCreated(DEFAULT_REFER, _rootUserAddress, block.timestamp);\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @notice Initialize root user in royalty tiers (call after deployment)\r\n     * @dev Must be called once after both contracts are deployed and connected\r\n     */\r\n    function initializeRoyalty() external onlyOwner {\r\n        require(userInfo[DEFAULT_REFER].level == 13, \"Root not at max level\");\r\n        \r\n        // Register root to all royalty tiers\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 10, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 11, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 12, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 13, 0);\r\n    }\r\n    \r\n    // ============ LEVEL COST HELPER ============\r\n    \r\n    /**\r\n     * @dev Get level cost in USDT (uses adjustable levelCosts array)\r\n     * @param _level Level index (0-12 for L1-L13)\r\n     * @return BNB cost in wei (18 decimals)\r\n     */\r\n    /**\r\n     * @dev Get level cost in BNB based on USD price and current BNB rate\r\n     * @param _level Level index (0-12 for L1-L13)\r\n     * @return BNB cost in wei\r\n     */\r\n    function getLevelCost(uint _level) public view returns (uint) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        // Convert USD cost to BNB: (USD_Cost * 1e18) / BNB_Price\r\n        return (levelCosts[_level] * 1e18) / bnbPrice;\r\n    }\r\n\r\n    function _getLevelCost(uint _level) private view returns (uint) {\r\n        return getLevelCost(_level);\r\n    }\r\n    \r\n    // ============ USER-FACING FUNCTIONS ============\r\n    \r\n    /**\r\n        if (_level == 7) return 320e18;     // $320\r\n        if (_level == 8) return 640e18;     // $640\r\n        if (_level == 9) return 1320e18;    // $1,320\r\n        if (_level == 10) return 2740e18;   // $2,740\r\n        if (_level == 11) return 5480e18;   // $5,480\r\n        if (_level == 12) return 10960e18;  // $10,960\r\n        revert(\"Invalid level\");\r\n    }\r\n    \r\n    // ============ USER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Register new user with BNB payment\r\n     * @param _ref Referrer user ID (0 = default)\r\n     * @param _newAcc New user wallet address\r\n     */\r\n    function register(uint _ref, address _newAcc) external payable nonReentrant whenNotPaused {\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(msg.value >= requiredAmount, \"Insufficient BNB sent\");\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n\r\n        // Refund excess BNB\r\n        if (msg.value > requiredAmount) {\r\n            (bool success, ) = payable(msg.sender).call{value: msg.value - requiredAmount}(\"\");\r\n            // If refund fails, it stays in contract for owner recovery\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly registration using referrer address\r\n     */\r\n    function registerMe(address _referrerAddress) external payable nonReentrant whenNotPaused {\r\n        uint _ref = (_referrerAddress == address(0)) ? 0 : id[_referrerAddress];\r\n        address _newAcc = msg.sender;\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(msg.value >= requiredAmount, \"Insufficient BNB sent\");\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n\r\n        // Refund excess BNB\r\n        if (msg.value > requiredAmount) {\r\n            (bool success, ) = payable(msg.sender).call{value: msg.value - requiredAmount}(\"\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Upgrade user to higher levels with BNB\r\n     */\r\n    function upgrade(uint _id, uint _lvls) external payable nonReentrant whenNotPaused validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        require(userInfo[_id].level + _lvls <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        \r\n        // Calculate total cost\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        // Transfer USDT from user\r\n        require(msg.value >= totalCost, \"Insufficient BNB\");\r\n        \r\n        // Process each level\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[_id].level++;\r\n            userIncome[_id].totalDeposit += levelCost;\r\n            \r\n            // Pay admin fee\r\n            if (adminFee > 0) {\r\n                (bool success, ) = payable(FEE_RECEIVER).call{value: adminFee}(\"\");\r\n                require(success, \"Fee transfer failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[_id].level - 1, block.timestamp);\r\n            }\r\n            \r\n            // Fund royalty pool (5% of levelCost)\r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                (bool success, ) = payable(address(ROYALTY_ADDR)).call{value: royaltyFundAmt}(\"\");\r\n                require(success, \"Royalty transfer failed\");\r\n                emit RoyaltyPoolFunded(_id, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            // Distribute payments\r\n            uint remaining = _processSponsorCommission(_id, levelCost);\r\n            _distributeMatrixIncome(_id, userInfo[_id].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            // Register for royalty\r\n            ROYALTY_ADDR.registerUser(_id, userInfo[_id].level, userInfo[_id].directTeam);\r\n            \r\n            emit UserUpgraded(_id, userInfo[_id].level, levelCost, block.timestamp);\r\n            activity.push(Activity(_id, userInfo[_id].level, block.timestamp));\r\n\r\n        }\r\n\r\n        // Refund excess BNB\r\n        if (msg.value > totalCost) {\r\n            (bool success, ) = payable(msg.sender).call{value: msg.value - totalCost}(\"\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly upgrade for caller\r\n     */\r\n    function upgradeMe(uint _levels) external payable nonReentrant whenNotPaused {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        require(msg.sender == userInfo[myId].account, \"Unauthorized\");\r\n        require(userInfo[myId].level + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        require(msg.value >= totalCost, \"Insufficient BNB\");\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[myId].level++;\r\n            userIncome[myId].totalDeposit += levelCost;\r\n            \r\n            if (adminFee > 0) {\r\n                (bool success, ) = payable(FEE_RECEIVER).call{value: adminFee}(\"\");\r\n                require(success, \"Fee transfer failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[myId].level - 1, block.timestamp);\r\n            }\r\n            \r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                (bool success, ) = payable(address(ROYALTY_ADDR)).call{value: royaltyFundAmt}(\"\");\r\n                require(success, \"Royalty transfer failed\");\r\n                emit RoyaltyPoolFunded(myId, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            uint remaining = _processSponsorCommission(myId, levelCost);\r\n            _distributeMatrixIncome(myId, userInfo[myId].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            ROYALTY_ADDR.registerUser(myId, userInfo[myId].level, userInfo[myId].directTeam);\r\n            \r\n            emit UserUpgraded(myId, userInfo[myId].level, levelCost, block.timestamp);\r\n            activity.push(Activity(myId, userInfo[myId].level, block.timestamp));\r\n        }\r\n\r\n        // Refund excess BNB\r\n        if (msg.value > totalCost) {\r\n            (bool success, ) = payable(msg.sender).call{value: msg.value - totalCost}(\"\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim royalty reward\r\n     */\r\n    function claimRoyalty(uint _id, uint _royaltyLvl) external nonReentrant validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            _id,\r\n            _royaltyLvl,\r\n            DEFAULT_REFER,\r\n            userIncome[_id].totalIncome,\r\n            userIncome[_id].totalDeposit,\r\n            userInfo[_id].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(_id, _royaltyLvl, amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly royalty claim\r\n     */\r\n    function claimMyRoyalty(uint _tier) external nonReentrant {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            myId,\r\n            _tier,\r\n            DEFAULT_REFER,\r\n            userIncome[myId].totalIncome,\r\n            userIncome[myId].totalDeposit,\r\n            userInfo[myId].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(myId, _tier, amount, block.timestamp);\r\n    }\r\n    \r\n    // ============ OWNER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Renounce ownership - makes contract fully autonomous\r\n     * @dev IRREVERSIBLE - contract becomes ownerless forever\r\n     */\r\n    function renounceOwnership() external onlyOwner {\r\n        emit OwnershipRenounced(owner, block.timestamp);\r\n        owner = address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfer ownership to new address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Update level cost (owner only, before renouncing)\r\n     * @dev Allows flexibility during initial phase, becomes immutable after renounce\r\n     */\r\n    function setLevelCost(uint8 _level, uint256 _newCost) external onlyOwner {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        require(_newCost > 0, \"Cost must be positive\");\r\n        require(_newCost >= 1e18, \"Minimum cost is 1 BNB\");\r\n        require(_newCost <= 100000e18, \"Maximum cost is 100,000 BNB\");\r\n        \r\n        // Ensure costs are ascending (level n+1 > level n)\r\n        if (_level > 0) {\r\n            require(_newCost > levelCosts[_level - 1], \"Cost must increase\");\r\n        }\r\n        if (_level < MAX_LEVELS - 1) {\r\n            require(_newCost < levelCosts[_level + 1] || levelCosts[_level + 1] == 0, \"Cost must be less than next level\");\r\n        }\r\n        \r\n        uint256 oldCost = levelCosts[_level];\r\n        levelCosts[_level] = _newCost;\r\n        \r\n        emit LevelCostUpdated(_level, oldCost, _newCost, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Pause contract in case of emergency\r\n     * @dev Only owner can pause, prevents all user operations\r\n     */\r\n    function pauseContract() external onlyOwner {\r\n        require(!paused, \"Already paused\");\r\n        paused = true;\r\n        emit ContractPaused(msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Resume contract operations\r\n     */\r\n    function unpauseContract() external onlyOwner {\r\n        require(paused, \"Not paused\");\r\n        paused = false;\r\n        emit ContractUnpaused(msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Recover stuck BNB (e.g., from failed transfers)\r\n     */\r\n    function recoverBNB() external onlyOwner {\r\n        uint balance = address(this).balance;\r\n        require(balance > 0, \"No BNB to recover\");\r\n        (bool success, ) = payable(owner).call{value: balance}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Update BNB Price for dynamic cost calculation (Owner only)\r\n     * @param _price New BNB price in 18 decimals (e.g., 600e18 for $600)\r\n     */\r\n    function updateBNBPrice(uint _price) external onlyOwner {\r\n        require(_price > 0, \"Invalid price\");\r\n        uint oldPrice = bnbPrice;\r\n        bnbPrice = _price;\r\n        emit BNBPriceUpdated(oldPrice, _price, block.timestamp);\r\n    }\r\n\r\n    // Helper to pay root with checks\r\n    function payRoot(uint amount, string memory reason) private {\r\n        (bool success, ) = payable(userInfo[DEFAULT_REFER].account).call{value: amount}(\"\");\r\n         if (success) {\r\n            userIncome[DEFAULT_REFER].referralIncome += amount;\r\n            userIncome[DEFAULT_REFER].totalIncome += amount;\r\n            emit RootFallbackIncome(amount, reason, block.timestamp);\r\n        }\r\n    }\r\n\r\n    \r\n    // ============ INTERNAL FUNCTIONS - PAYMENT DISTRIBUTION ============\r\n    \r\n    function _processRegistrationPayments(uint _newId, uint _levelCost, uint _adminFee) private {\r\n        // Pay admin fee (5%)\r\n        if (_adminFee > 0) {\r\n            (bool success, ) = payable(FEE_RECEIVER).call{value: _adminFee}(\"\");\r\n            require(success, \"Fee transfer failed\");\r\n            emit AdminFeePaid(_adminFee, 0, block.timestamp);\r\n        }\r\n        \r\n        // Fund royalty pool (5% of levelCost)\r\n        uint royaltyFundAmt = (_levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n        if (royaltyFundAmt > 0) {\r\n            (bool success, ) = payable(address(ROYALTY_ADDR)).call{value: royaltyFundAmt}(\"\");\r\n            require(success, \"Royalty transfer failed\");\r\n            emit RoyaltyPoolFunded(_newId, royaltyFundAmt, block.timestamp);\r\n        }\r\n        \r\n        // Referral income (95% = levelCost - royaltyFund)\r\n        uint _referrer = userInfo[_newId].referrer;\r\n        uint referralAmount = _levelCost - royaltyFundAmt;\r\n        \r\n        if (_referrer != 0 && userInfo[_referrer].exists) {\r\n            (bool success, ) = payable(userInfo[_referrer].account).call{value: referralAmount}(\"\");\r\n            if (success) {\r\n                userIncome[_referrer].referralIncome += referralAmount;\r\n                userIncome[_referrer].totalIncome += referralAmount;\r\n                emit ReferralPayment(_referrer, _newId, referralAmount, block.timestamp);\r\n            } else {\r\n                // Transfer failed - refund to sender\r\n                (bool refund, ) = payable(userInfo[_newId].account).call{value: referralAmount}(\"\");\r\n                require(refund, \"Refund failed\");\r\n            }\r\n        } else {\r\n            // No valid referrer - send to Root\r\n            payRoot(referralAmount, \"no_valid_referrer\");\r\n        }\r\n        \r\n        // Note: For registration, income goes to Referrer, NOT matrix\r\n        // Matrix distribution only happens on upgrade\r\n    }\r\n\r\n    \r\n    function _processSponsorCommission(uint _id, uint _amount) private returns (uint) {\r\n        uint _referrer = userInfo[_id].referrer;\r\n        uint totalPaid = 0;\r\n        uint totalSponsorAllocation = (_amount * 500) / 10000;  // 5%\r\n        \r\n        // Distribute to up to 13 levels\r\n        for (uint8 level = 0; level < SPONSOR_LEVELS && _referrer != 0; level++) {\r\n            bool qualified = _isQualifiedForSponsorLevel(_referrer, level);\r\n            uint reward = (_amount * _getSponsorPercentage(level)) / 10000;\r\n            \r\n            if (qualified && reward > 0) {\r\n                (bool success, ) = payable(userInfo[_referrer].account).call{value: reward}(\"\");\r\n                if (success) {\r\n                    userIncome[_referrer].sponsorIncome += reward;\r\n                    userIncome[_referrer].totalIncome += reward;\r\n                    totalPaid += reward;\r\n                    \r\n                    emit SponsorCommissionPaid(_referrer, _id, reward, level + 1, block.timestamp);\r\n                }\r\n            } else if (reward > 0) {\r\n                // Track lost income only if upline exists\r\n                if (userInfo[_referrer].exists) {\r\n                    lostIncome[_referrer] += reward;\r\n                    \r\n                    string memory reason;\r\n                    if (level < 5) {\r\n                        reason = \"Not active (need Level 1+)\";\r\n                    } else if (level >= 5 && level < 8) {\r\n                        reason = \"Need 2+ direct referrals for L6-L8\";\r\n                    } else if (level >= 8 && level < 10) {\r\n                        reason = \"Need 3+ direct referrals for L9-L10\";\r\n                    } else {\r\n                        reason = \"Need 5+ direct referrals for L11-L13\";\r\n                    }\r\n                    \r\n                    emit IncomeLost(_referrer, _id,reward, reason, block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _referrer = userInfo[_referrer].referrer;\r\n        }\r\n        \r\n        // Unpaid commission goes to Root (no eligible sponsors)\r\n        if (totalPaid < totalSponsorAllocation) {\r\n            uint unpaid = totalSponsorAllocation - totalPaid;\r\n            payRoot(unpaid, \"sponsor_no_eligible\");\r\n            totalPaid = totalSponsorAllocation;\r\n        }\r\n        \r\n        return _amount - totalPaid;  // Returns 95%\r\n    }\r\n    \r\n    \r\n    function _distributeMatrixIncome(uint _userId, uint _level, uint _amount, bool ignoreQualification) private {\r\n        uint _upline = userInfo[_userId].upline;\r\n        bool paid = false;\r\n        \r\n        // Search up to 13 levels for qualified upline\r\n        for (uint i = 0; i < MAX_INCOME_LAYER && _upline != 0; i++) {\r\n            bool qualified = ignoreQualification || \r\n                            (userInfo[_upline].level > _level && userInfo[_upline].directTeam >= DIRECT_REQUIRED);\r\n            \r\n            if (qualified) {\r\n                // Give FULL remaining amount (90%) to first qualified upline\r\n                (bool success, ) = payable(userInfo[_upline].account).call{value: _amount}(\"\");\r\n                if (success) {\r\n                    userIncome[_upline].levelIncome += _amount;\r\n                    userIncome[_upline].totalIncome += _amount;\r\n                    paid = true;\r\n                    \r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, true, block.timestamp);\r\n                } else {\r\n                    // Transfer failed - refund to sender\r\n                    (bool refund, ) = payable(userInfo[_userId].account).call{value: _amount}(\"\");\r\n                    require(refund, \"Matrix refund failed\");\r\n                    paid = true; // Mark as handled\r\n                }\r\n                break;  // Stop after first qualified upline\r\n            } else {\r\n                // Emit events for transparency, but DON'T track lostIncome\r\n                // (winner-takes-all model - only first qualified gets paid, so no real \"share\" lost)\r\n                if (userInfo[_upline].exists) {\r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, false, block.timestamp);\r\n                    emit IncomeLost(_upline, _userId, _amount, \"Not qualified for matrix\", block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _upline = userInfo[_upline].upline;\r\n        }\r\n        \r\n        // No qualified upline found - send to Root\r\n        if (!paid && _amount > 0) {\r\n            payRoot(_amount, \"matrix_no_qualified\");\r\n        }\r\n    }\r\n\r\n    \r\n    function _isQualifiedForSponsorLevel(uint _userId, uint8 level) private view returns (bool) {\r\n        User storage user = userInfo[_userId];\r\n        \r\n        if (!user.exists || user.level < 1) return false;\r\n        \r\n        if (level < 5) {\r\n            return true;  // L1-L5: Just need Level 1+\r\n        } else if (level >= 5 && level < 8) {\r\n            return user.directTeam >= MIN_DIRECTS_L6_8;  // L6-L8: 2+ directs\r\n        } else if (level >= 8 && level < 10) {\r\n            return user.directTeam >= MIN_DIRECTS_L9_10;  // L9-L10: 3+ directs\r\n        } else {\r\n            return user.directTeam >= MIN_DIRECTS_L11_13;  // L11-L13: 5+ directs\r\n        }\r\n    }\r\n    \r\n    // ============ INTERNAL FUNCTIONS - USER & MATRIX ============\r\n    \r\n    function _createUser(uint _userId, address _account, uint _referrer, uint _upline, uint _level) private {\r\n        userInfo[_userId] = User({\r\n            exists: true,\r\n            account: _account,\r\n            referrer: _referrer,\r\n            upline: _upline,\r\n            level: _level + 1,\r\n            directTeam: 0,\r\n            team: 0,\r\n            registrationTime: block.timestamp\r\n        });\r\n        \r\n        userIncome[_userId] = UserIncome({\r\n            totalDeposit: 0,\r\n            totalIncome: 0,\r\n            referralIncome: 0,\r\n            sponsorIncome: 0,\r\n            levelIncome: 0\r\n        });\r\n        \r\n        if (_referrer != 0 && _referrer != _userId) {\r\n            userInfo[_referrer].directTeam++;\r\n            directReferrals[_referrer].push(_userId);  // Store in mapping for O(1) lookup\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Place new user in binary matrix using breadth-first search\r\n     * @param _newId ID of new user to place\r\n     * @param _ref Starting point (usually referrer)\r\n     * \r\n     * Searches for available spot (max 2 children per node) within MAX_PLACEMENT_DEPTH.\r\n     * If no spot found, searches up sponsor chain (max 13 levels).\r\n     * Final fallback: places under root.\r\n     */\r\n    function _placeInBinaryMatrix(uint _newId, uint _ref) private {\r\n        uint _upline = 0;\r\n        uint currentSponsor = _ref;\r\n        \r\n        // Try to find spot in sponsor chain (up to 13 levels)\r\n        for (uint sponsorLevel = 0; sponsorLevel < 13 && currentSponsor != 0; sponsorLevel++) {\r\n            _upline = _findSpotInTree(currentSponsor);\r\n            if (_upline != 0) break;\r\n            \r\n            // Move to next sponsor up the chain\r\n            currentSponsor = userInfo[currentSponsor].referrer;\r\n        }\r\n        \r\n        // Final fallback to root if no spot found in entire sponsor chain\r\n        if (_upline == 0) {\r\n            _upline = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Place user\r\n        teams[_upline][0].push(_newId);\r\n        userInfo[_newId].upline = _upline;\r\n        matrixDirect[_upline]++;\r\n    }\r\n    \r\n    /**\r\n     * @dev Search for available spot in a specific user's tree\r\n     * @param _root Starting point for BFS\r\n     * @return ID of upline with available spot, or 0 if none found\r\n     */\r\n    function _findSpotInTree(uint _root) private view returns (uint) {\r\n        uint[] memory queue = new uint[](MAX_PLACEMENT_DEPTH);\r\n        uint front = 0;\r\n        uint back = 0;\r\n        queue[back++] = _root;\r\n        \r\n        uint iterations = 0;\r\n        \r\n        while (front < back && iterations < MAX_PLACEMENT_DEPTH) {\r\n            uint currentNode = queue[front++];\r\n            iterations++;\r\n            \r\n            // Check if this node has space\r\n            if (teams[currentNode][0].length < 2) {\r\n                return currentNode;\r\n            }\r\n            \r\n            // Add children to queue\r\n            for (uint i = 0; i < teams[currentNode][0].length && back < MAX_PLACEMENT_DEPTH; i++) {\r\n                queue[back++] = teams[currentNode][0][i];\r\n            }\r\n        }\r\n        \r\n        return 0; // No spot found\r\n    }\r\n    \r\n    /**\r\n     * @dev Update team counts - FIXED: Only increment once per new user\r\n     * Previously this was over-counting by incrementing multiple times\r\n     */\r\n    function _updateTeamCounts(uint _userId) private {\r\n        uint _upline = userInfo[_userId].referrer;\r\n        uint depth = 0;\r\n        \r\n        // Walk up referral chain and increment team count for each upline\r\n        // Each new user adds +1 to all uplines' team counts\r\n        while (_upline != 0 && depth < MAX_PLACEMENT_DEPTH) {\r\n            userInfo[_upline].team++;\r\n            _upline = userInfo[_upline].referrer;\r\n            depth++;\r\n        }\r\n    }\r\n    \r\n    // ============ VIEW FUNCTIONS ============\r\n    \r\n    function isAutonomous() external view returns (bool) {\r\n        return owner == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get user account address by ID (used by Royalty contract)\r\n     */\r\n    function getUserAccount(uint _userId) external view returns (address) {\r\n        return userInfo[_userId].account;\r\n    }\r\n    \r\n    function getLevelCostWithFee(uint _level) external view returns (uint cost, uint adminFee, uint total) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        cost = _getLevelCost(_level);\r\n        adminFee = (cost * ADMIN_FEE_PERCENT) / 100;\r\n        total = cost + adminFee;\r\n    }\r\n    \r\n    function getAllLevelCosts() external view returns (\r\n        uint[13] memory costs,\r\n        uint[13] memory fees,\r\n        uint[13] memory totals\r\n    ) {\r\n        for (uint i = 0; i < 13; i++) {\r\n            costs[i] = _getLevelCost(i);\r\n            fees[i] = (costs[i] * ADMIN_FEE_PERCENT) / 100;\r\n            totals[i] = costs[i] + fees[i];\r\n        }\r\n    }\r\n    \r\n    function getRegistrationCost() external view returns (uint cost, uint levelCost, uint adminFee) {\r\n        levelCost = _getLevelCost(0);\r\n        adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        cost = levelCost + adminFee;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for caller (for dApp use)\r\n     * @dev This version uses msg.sender - DOES NOT WORK on BSCScan Read Contract!\r\n     *      Use getUpgradeCostFor() on BSCScan instead\r\n     */\r\n    function getUpgradeCost(uint _levels) external view returns (uint totalCost, uint[] memory breakdown) {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[myId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);  // FIX: targetLevel is 1-13, need index 0-12\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for specific user (BSCScan-friendly!)\r\n     * @param _userAddress Address of the user to check\r\n     * @param _levels Number of levels to upgrade\r\n     * @return totalCost Total USDT cost (including admin fee)\r\n     * @return breakdown Cost breakdown per level\r\n     */\r\n    function getUpgradeCostFor(address _userAddress, uint _levels) \r\n        external view returns (uint totalCost, uint[] memory breakdown) \r\n    {\r\n        uint userId = id[_userAddress];\r\n        require(userId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[userId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    function getMyInfo() external view returns (\r\n        uint userId,\r\n        uint level,\r\n        uint team,\r\n        uint directTeam,\r\n        uint totalIncome,\r\n        uint referrerId,\r\n        uint uplineId,\r\n        uint registrationTime\r\n    ) {\r\n        userId = id[msg.sender];\r\n        if (userId == 0) return (0, 0, 0, 0, 0, 0, 0, 0);\r\n        \r\n        User storage user = userInfo[userId];\r\n        UserIncome storage income = userIncome[userId];\r\n        \r\n        return (\r\n            userId,\r\n            user.level,\r\n            user.team,\r\n            user.directTeam,\r\n            income.totalIncome,\r\n            user.referrer,\r\n            user.upline,\r\n            user.registrationTime\r\n        );\r\n    }\r\n    \r\n    function getMyIncomeBreakdown() external view returns (\r\n        uint totalDeposit,\r\n        uint totalIncome,\r\n        uint referralIncome,\r\n        uint sponsorIncome,\r\n        uint levelIncome,\r\n        uint lostAmount\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, 0, 0, 0, 0);\r\n        \r\n        UserIncome storage income = userIncome[myId];\r\n        return (\r\n            income.totalDeposit,\r\n            income.totalIncome,\r\n            income.referralIncome,\r\n            income.sponsorIncome,\r\n            income.levelIncome,\r\n            lostIncome[myId]\r\n        );\r\n    }\r\n    \r\n    function getMyTeam() external view returns (\r\n        uint teamSize,\r\n        uint directCount,\r\n        uint[] memory directReferralIds,\r\n        address[] memory directReferralAddresses\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, new uint[](0), new address[](0));\r\n        \r\n        User storage user = userInfo[myId];\r\n        teamSize = user.team;\r\n        directCount = user.directTeam;\r\n        \r\n        // Use mapping for O(1) lookup instead of O(N) loop\r\n        directReferralIds = directReferrals[myId];\r\n        \r\n        // Build addresses array\r\n        directReferralAddresses = new address[](directReferralIds.length);\r\n        for (uint i = 0; i < directReferralIds.length; i++) {\r\n            directReferralAddresses[i] = userInfo[directReferralIds[i]].account;\r\n        }\r\n    }\r\n    \r\n    function getMyRoyaltyStatus() external view returns (\r\n        uint[4] memory claimableAmounts,\r\n        bool[4] memory isEligible,\r\n        bool[4] memory hasClaimed\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (claimableAmounts, isEligible, hasClaimed);\r\n        \r\n        for (uint i = 0; i < 4; i++) {\r\n            (claimableAmounts[i], isEligible[i], hasClaimed[i]) = ROYALTY_ADDR.getUserRoyaltyData(myId, i);\r\n        }\r\n    }\r\n    \r\n    function isRegistered(address _address) external view returns (bool) {\r\n        return id[_address] > 0;\r\n    }\r\n    \r\n    function getContractBalance() external view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n}\r\n"
    },
    "contracts/FiveDollarRide_BNB_temp.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\n// Full contract code too large - using copy paste method\r\n// User should manually paste the provided code into FiveDollarRide_BNB.sol\r\n"
    },
    "contracts/FiveDollarRide_USDT_Enhanced.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title FiveDollarRide - The $5 Opportunity Platform\r\n * @notice Revolutionary income platform starting at just $5 with USDT payments\r\n * @dev Owner-controlled smart contract with progressive decentralization capability\r\n * \r\n * Features:\r\n * - 13 Level progression ($5 to $20,480)\r\n * - Binary matrix tree structure  \r\n * - Multi-layer income distribution (20 layers)\r\n * - Sponsor commissions (13 levels)\r\n * - Royalty pool funding (5% per upgrade)\r\n * - USDT-based payments only\r\n * - Owner-controlled parameters (immutable after ownership renouncement)\r\n * - Full event-driven transparency\r\n * \r\n * Brand: FiveDollarRide - Your $5 Journey to Financial Freedom\r\n */\r\n// USDT Token Interface\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n// Royalty Contract Interface\r\ninterface IRoyalty {\r\n    function registerUser(uint _userId, uint _level, uint _directCount) external;\r\n    function claimRoyalty(\r\n        uint _id, \r\n        uint _tier,\r\n        uint rootUserId,\r\n        uint userTotalIncome,\r\n        uint userTotalDeposit,\r\n        address userAccount\r\n    ) external returns (uint);\r\n    function getUserRoyaltyData(uint _userId, uint _tier) external view returns (uint, bool, bool);\r\n    function getRoyaltyPercents() external view returns(uint[4] memory);\r\n    function getRoyaltyLevels() external view returns(uint[4] memory);\r\n    function getTierStats(uint _tier) external view returns(uint userCount, uint distributionRound, uint pendingUserCount);\r\n}\r\n\r\ncontract FiveDollarRide {\r\n    // ============ IMMUTABLE VALUES (SET AT DEPLOYMENT) ============\r\n    \r\n    address public immutable FEE_RECEIVER;\r\n    IERC20 public immutable USDT;\r\n    IRoyalty public immutable ROYALTY_ADDR;\r\n    uint private immutable DEFAULT_REFER;\r\n    uint public immutable START_TIME;\r\n    \r\n    // ============ CONSTANTS (HARDCODED FOREVER) ============\r\n    \r\n    // System constants\r\n    uint8 public constant MAX_LEVELS = 13;\r\n    uint8 public constant MAX_INCOME_LAYER = 13;  // Income distribution depth (matches 13 levels)\r\n    uint8 public constant MAX_PLACEMENT_DEPTH = 100;  // Placement search depth\r\n    // Note: If tree depth exceeds 100, placement falls back to root (DEFAULT_REFER)\r\n    // This prevents infinite loops but may cluster users under root in very large trees\r\n    \r\n    // Economic constants (adjustable by owner until renounced)\r\n    uint8 public constant ADMIN_FEE_PERCENT = 5;      // 5% admin fee\r\n    uint8 public constant ROYALTY_FUND_PERCENT = 5;   // 5% to royalty pool\r\n    \r\n    // Level costs (adjustable by owner, immutable after renounce)\r\n    // Starting costs: L1=$5, L2=$10, L3=$20... up to L13=$20,480 (hardcoded initially)\r\n    uint256[13] public levelCosts = [\r\n        5e18,      // L1: $5\r\n        10e18,     // L2: $10  \r\n        20e18,     // L3: $20\r\n        40e18,     // L4: $40\r\n        80e18,     // L5: $80\r\n        160e18,    // L6: $160\r\n        320e18,    // L7: $320\r\n        640e18,    // L8: $640\r\n        1280e18,   // L9: $1,280\r\n        2560e18,   // L10: $2,560\r\n        5120e18,   // L11: $5,120\r\n        10240e18,  // L12: $10,240\r\n        20480e18   // L13: $20,480\r\n    ];\r\n    \r\n    // Team & income constants\r\n    uint public constant DIRECT_REQUIRED = 2;\r\n    uint public constant MAX_REFERRAL_LAYERS = 1;\r\n    \r\n    // Sponsor commission (13 levels, total 5%)\r\n    uint8 private constant SPONSOR_LEVELS = 13;\r\n    \r\n    function _getSponsorPercentage(uint8 level) private pure returns (uint16) {\r\n        if (level == 0) return 100;   // L1: 1%\r\n        if (level == 1) return 80;    // L2: 0.8%\r\n        if (level == 2) return 60;    // L3: 0.6%\r\n        if (level == 3) return 50;    // L4: 0.5%\r\n        if (level == 4) return 50;    // L5: 0.5%\r\n        if (level == 5) return 40;    // L6: 0.4%\r\n        if (level == 6) return 30;    // L7: 0.3%\r\n        if (level == 7) return 25;    // L8: 0.25%\r\n        if (level == 8) return 20;    // L9: 0.2%\r\n        if (level == 9) return 15;    // L10: 0.15%\r\n        if (level == 10) return 10;   // L11: 0.1%\r\n        if (level == 11) return 10;   // L12: 0.1%\r\n        if (level == 12) return 10;   // L13: 0.1%\r\n        return 0;\r\n    }\r\n    \r\n    // Sponsor qualification thresholds\r\n    uint8 private constant MIN_DIRECTS_L6_8 = 2;\r\n    uint8 private constant MIN_DIRECTS_L9_10 = 3;\r\n    uint8 private constant MIN_DIRECTS_L11_13 = 5;\r\n    \r\n    \r\n    // ============ STATE VARIABLES ============\r\n    \r\n    // Owner (can renounce)\r\n    address public owner;\r\n    \r\n    // Emergency controls\r\n    bool public paused;\r\n    \r\n    // Reentrancy guard (improved pattern)\r\n    uint256 private unlocked = 1;\r\n    \r\n    // User tracking\r\n    uint public totalUsers;\r\n    uint private userIdCounter;\r\n    \r\n    // ============ DATA STRUCTURES ============\r\n    \r\n    struct User {\r\n        bool exists;\r\n        address account;\r\n        uint referrer;\r\n        uint upline;\r\n        uint level;\r\n        uint directTeam;\r\n        uint team;\r\n        uint registrationTime;\r\n    }\r\n    \r\n    struct UserIncome {\r\n        uint totalDeposit;\r\n        uint totalIncome;\r\n        uint referralIncome;\r\n        uint sponsorIncome;\r\n        uint levelIncome;\r\n    }\r\n    \r\n    struct Activity {\r\n        uint id;\r\n        uint level;\r\n        uint time;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => uint) public id;\r\n    mapping(uint => User) public userInfo;\r\n    mapping(uint => UserIncome) public userIncome;\r\n    mapping(uint => mapping(uint => uint[])) public teams;\r\n    mapping(uint => uint) public matrixDirect;\r\n    mapping(uint => uint) public lostIncome;\r\n    mapping(uint => uint[]) private directReferrals;  // NEW: O(1) direct team lookup\r\n    \r\n    uint[] private globalUsers;  // Changed to private (use events instead)\r\n    Activity[] private activity;  // Changed to private (use events instead)\r\n    \r\n    // ============ EVENTS ============\r\n    \r\n    // User lifecycle\r\n    event UserRegistered(uint indexed userId, address indexed account, uint indexed referrer, uint timestamp);\r\n    event UserUpgraded(uint indexed userId, uint newLevel, uint amount, uint timestamp);\r\n    event RootUserCreated(uint indexed rootUserId, address indexed rootAddress, uint timestamp);\r\n    \r\n    // Payments & income\r\n    event AdminFeePaid(uint amount, uint level, uint timestamp);\r\n    event ReferralPayment(uint indexed referrerId, uint indexed userId, uint amount, uint timestamp);\r\n    event SponsorCommissionPaid(uint indexed sponsorId, uint indexed fromUserId, uint amount, uint level, uint timestamp);\r\n    event MatrixPayment(uint indexed fromUserId, uint indexed toUserId, uint amount, uint level, uint layer, bool qualified, uint timestamp);\r\n    event IncomeLost(uint indexed userId, uint indexed fromUser, uint amount, string reason, uint timestamp);\r\n    event RoyaltyPoolFunded(uint indexed userId, uint amount, uint timestamp);\r\n    event RoyaltyClaimed(uint indexed userId, uint indexed royaltyLevel, uint amount, uint timestamp);\r\n    \r\n    // Ownership & Emergency\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipRenounced(address indexed previousOwner, uint timestamp);\r\n    event LevelCostUpdated(uint8 indexed level, uint256 oldCost, uint256 newCost, uint timestamp);\r\n    event ContractPaused(address indexed by, uint timestamp);\r\n    event ContractUnpaused(address indexed by, uint timestamp);\r\n    event RootFallbackIncome(uint amount, string source, uint timestamp);\r\n    \r\n    // ============ MODIFIERS ============\r\n    \r\n    modifier nonReentrant() {\r\n        require(unlocked == 1, \"Reentrancy detected\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n    \r\n    modifier validUser(uint _userId) {\r\n        require(_userId > 0 && userInfo[_userId].exists, \"Invalid user ID\");\r\n        _;\r\n    }\r\n    \r\n    // ============ CONSTRUCTOR ============\r\n    \r\n    constructor(\r\n        address _feeReceiver,\r\n        address _royalty,\r\n        address _rootUserAddress,\r\n        uint _rootUserId,\r\n        address _usdtToken\r\n    ) {\r\n        require(_feeReceiver != address(0), \"Invalid fee receiver\");\r\n        require(_royalty != address(0), \"Invalid royalty\");\r\n        require(_rootUserAddress != address(0), \"Invalid root address\");\r\n        require(_rootUserId > 0, \"Invalid root user ID\");\r\n        require(_usdtToken != address(0), \"Invalid USDT\");\r\n        \r\n        // Set immutables\r\n        FEE_RECEIVER = _feeReceiver;\r\n        ROYALTY_ADDR = IRoyalty(_royalty);\r\n        DEFAULT_REFER = _rootUserId;\r\n        START_TIME = block.timestamp;\r\n        USDT = IERC20(_usdtToken);\r\n        \r\n        // Set owner\r\n        owner = msg.sender;\r\n        \r\n        // Initialize root user\r\n        userIdCounter = DEFAULT_REFER;\r\n        id[_rootUserAddress] = DEFAULT_REFER;\r\n        _createUser(DEFAULT_REFER, _rootUserAddress, DEFAULT_REFER, DEFAULT_REFER, 12);\r\n        globalUsers.push(DEFAULT_REFER);\r\n        totalUsers = 1;\r\n        // Root user already has level 13 from _createUser (12 + 1)\r\n        \r\n        // Register root to all royalty tiers\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 10, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 11, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 12, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 13, 0);\r\n        \r\n        emit RootUserCreated(DEFAULT_REFER, _rootUserAddress, block.timestamp);\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n    \r\n    // ============ LEVEL COST HELPER ============\r\n    \r\n    /**\r\n     * @dev Get level cost in USDT (uses adjustable levelCosts array)\r\n     * @param _level Level index (0-12 for L1-L13)\r\n     * @return USDT cost in wei (18 decimals)\r\n     */\r\n    function _getLevelCost(uint _level) private view returns (uint) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        return levelCosts[_level];\r\n    }\r\n    \r\n    // ============ USER-FACING FUNCTIONS ============\r\n    \r\n    /**\r\n        if (_level == 7) return 320e18;     // $320\r\n        if (_level == 8) return 640e18;     // $640\r\n        if (_level == 9) return 1320e18;    // $1,320\r\n        if (_level == 10) return 2740e18;   // $2,740\r\n        if (_level == 11) return 5480e18;   // $5,480\r\n        if (_level == 12) return 10960e18;  // $10,960\r\n        revert(\"Invalid level\");\r\n    }\r\n    \r\n    // ============ USER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Register new user with USDT payment\r\n     * @param _ref Referrer user ID (0 = default)\r\n     * @param _newAcc New user wallet address\r\n     */\r\n    function register(uint _ref, address _newAcc) external nonReentrant whenNotPaused {\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly registration using referrer address\r\n     */\r\n    function registerMe(address _referrerAddress) external nonReentrant whenNotPaused {\r\n        uint _ref = (_referrerAddress == address(0)) ? 0 : id[_referrerAddress];\r\n        address _newAcc = msg.sender;\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice Upgrade user to higher levels with USDT\r\n     */\r\n    function upgrade(uint _id, uint _lvls) external nonReentrant whenNotPaused validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        require(userInfo[_id].level + _lvls <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        \r\n        // Calculate total cost\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        // Transfer USDT from user\r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        // Process each level\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[_id].level++;\r\n            userIncome[_id].totalDeposit += levelCost;\r\n            \r\n            // Pay admin fee\r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[_id].level - 1, block.timestamp);\r\n            }\r\n            \r\n            // Fund royalty pool (5% of levelCost)\r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n                emit RoyaltyPoolFunded(_id, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            // Distribute payments\r\n            uint remaining = _processSponsorCommission(_id, levelCost);\r\n            _distributeMatrixIncome(_id, userInfo[_id].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            // Register for royalty\r\n            ROYALTY_ADDR.registerUser(_id, userInfo[_id].level, userInfo[_id].directTeam);\r\n            \r\n            emit UserUpgraded(_id, userInfo[_id].level, levelCost, block.timestamp);\r\n            activity.push(Activity(_id, userInfo[_id].level, block.timestamp));\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly upgrade for caller\r\n     */\r\n    function upgradeMe(uint _levels) external nonReentrant whenNotPaused {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        require(msg.sender == userInfo[myId].account, \"Unauthorized\");\r\n        require(userInfo[myId].level + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[myId].level++;\r\n            userIncome[myId].totalDeposit += levelCost;\r\n            \r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[myId].level - 1, block.timestamp);\r\n            }\r\n            \r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");emit RoyaltyPoolFunded(myId, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            uint remaining = _processSponsorCommission(myId, levelCost);\r\n            _distributeMatrixIncome(myId, userInfo[myId].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            ROYALTY_ADDR.registerUser(myId, userInfo[myId].level, userInfo[myId].directTeam);\r\n            \r\n            emit UserUpgraded(myId, userInfo[myId].level, levelCost, block.timestamp);\r\n            activity.push(Activity(myId, userInfo[myId].level, block.timestamp));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim royalty reward\r\n     */\r\n    function claimRoyalty(uint _id, uint _royaltyLvl) external nonReentrant validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            _id,\r\n            _royaltyLvl,\r\n            DEFAULT_REFER,\r\n            userIncome[_id].totalIncome,\r\n            userIncome[_id].totalDeposit,\r\n            userInfo[_id].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(_id, _royaltyLvl, amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly royalty claim\r\n     */\r\n    function claimMyRoyalty(uint _tier) external nonReentrant {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            myId,\r\n            _tier,\r\n            DEFAULT_REFER,\r\n            userIncome[myId].totalIncome,\r\n            userIncome[myId].totalDeposit,\r\n            userInfo[myId].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(myId, _tier, amount, block.timestamp);\r\n    }\r\n    \r\n    // ============ OWNER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Renounce ownership - makes contract fully autonomous\r\n     * @dev IRREVERSIBLE - contract becomes ownerless forever\r\n     */\r\n    function renounceOwnership() external onlyOwner {\r\n        emit OwnershipRenounced(owner, block.timestamp);\r\n        owner = address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfer ownership to new address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Update level cost (owner only, before renouncing)\r\n     * @dev Allows flexibility during initial phase, becomes immutable after renounce\r\n     */\r\n    function setLevelCost(uint8 _level, uint256 _newCost) external onlyOwner {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        require(_newCost > 0, \"Cost must be positive\");\r\n        require(_newCost >= 1e18, \"Minimum cost is 1 USDT\");\r\n        require(_newCost <= 100000e18, \"Maximum cost is 100,000 USDT\");\r\n        \r\n        // Ensure costs are ascending (level n+1 > level n)\r\n        if (_level > 0) {\r\n            require(_newCost > levelCosts[_level - 1], \"Cost must increase\");\r\n        }\r\n        if (_level < MAX_LEVELS - 1) {\r\n            require(_newCost < levelCosts[_level + 1] || levelCosts[_level + 1] == 0, \"Cost must be less than next level\");\r\n        }\r\n        \r\n        uint256 oldCost = levelCosts[_level];\r\n        levelCosts[_level] = _newCost;\r\n        \r\n        emit LevelCostUpdated(_level, oldCost, _newCost, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Pause contract in case of emergency\r\n     * @dev Only owner can pause, prevents all user operations\r\n     */\r\n    function pauseContract() external onlyOwner {\r\n        require(!paused, \"Already paused\");\r\n        paused = true;\r\n        emit ContractPaused(msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Resume contract operations\r\n     */\r\n    function unpauseContract() external onlyOwner {\r\n        require(paused, \"Not paused\");\r\n        paused = false;\r\n        emit ContractUnpaused(msg.sender, block.timestamp);\r\n    }\r\n\r\n    \r\n    // ============ INTERNAL FUNCTIONS - PAYMENT DISTRIBUTION ============\r\n    \r\n    function _processRegistrationPayments(uint _newId, uint _levelCost, uint _adminFee) private {\r\n        // Pay admin fee (5%)\r\n        if (_adminFee > 0) {\r\n            require(USDT.transfer(FEE_RECEIVER, _adminFee), \"Admin fee failed\");\r\n            emit AdminFeePaid(_adminFee, 0, block.timestamp);\r\n        }\r\n        \r\n        // Fund royalty pool (5% of levelCost)\r\n        uint royaltyFundAmt = (_levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n        if (royaltyFundAmt > 0) {\r\n            require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n            emit RoyaltyPoolFunded(_newId, royaltyFundAmt, block.timestamp);\r\n        }\r\n        \r\n        // Referral income (95% = levelCost - royaltyFund)\r\n        uint _referrer = userInfo[_newId].referrer;\r\n        uint referralAmount = _levelCost - royaltyFundAmt;\r\n        \r\n        if (_referrer != 0 && userInfo[_referrer].exists) {\r\n            require(USDT.transfer(userInfo[_referrer].account, referralAmount), \"Referral failed\");\r\n            userIncome[_referrer].referralIncome += referralAmount;\r\n            userIncome[_referrer].totalIncome += referralAmount;\r\n            emit ReferralPayment(_referrer, _newId, referralAmount, block.timestamp);\r\n        } else {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, referralAmount), \"Default referral failed\");\r\n            userIncome[DEFAULT_REFER].referralIncome += referralAmount;\r\n            userIncome[DEFAULT_REFER].totalIncome += referralAmount;\r\n            emit ReferralPayment(DEFAULT_REFER, _newId, referralAmount, block.timestamp);\r\n        }\r\n        \r\n        // Note: For registration, income goes to Referrer, NOT matrix\r\n        // Matrix distribution only happens on upgrade\r\n    }\r\n\r\n    \r\n    function _processSponsorCommission(uint _id, uint _amount) private returns (uint) {\r\n        uint _referrer = userInfo[_id].referrer;\r\n        uint totalPaid = 0;\r\n        uint totalSponsorAllocation = (_amount * 500) / 10000;  // 5%\r\n        \r\n        // Distribute to up to 13 levels\r\n        for (uint8 level = 0; level < SPONSOR_LEVELS && _referrer != 0; level++) {\r\n            bool qualified = _isQualifiedForSponsorLevel(_referrer, level);\r\n            uint reward = (_amount * _getSponsorPercentage(level)) / 10000;\r\n            \r\n            if (qualified && reward > 0) {\r\n                bool success = USDT.transfer(userInfo[_referrer].account, reward);\r\n                if (success) {\r\n                    userIncome[_referrer].sponsorIncome += reward;\r\n                    userIncome[_referrer].totalIncome += reward;\r\n                    totalPaid += reward;\r\n                    \r\n                    emit SponsorCommissionPaid(_referrer, _id, reward, level + 1, block.timestamp);\r\n                }\r\n            } else if (reward > 0) {\r\n                // Track lost income only if upline exists\r\n                if (userInfo[_referrer].exists) {\r\n                    lostIncome[_referrer] += reward;\r\n                    \r\n                    string memory reason;\r\n                    if (level < 5) {\r\n                        reason = \"Not active (need Level 1+)\";\r\n                    } else if (level >= 5 && level < 8) {\r\n                        reason = \"Need 2+ direct referrals for L6-L8\";\r\n                    } else if (level >= 8 && level < 10) {\r\n                        reason = \"Need 3+ direct referrals for L9-L10\";\r\n                    } else {\r\n                        reason = \"Need 5+ direct referrals for L11-L13\";\r\n                    }\r\n                    \r\n                    emit IncomeLost(_referrer, _id,reward, reason, block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _referrer = userInfo[_referrer].referrer;\r\n        }\r\n        \r\n        // Fallback to root for unpaid commission\r\n        if (totalPaid < totalSponsorAllocation) {\r\n            uint unpaid = totalSponsorAllocation - totalPaid;\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, unpaid), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].sponsorIncome += unpaid;\r\n            userIncome[DEFAULT_REFER].totalIncome += unpaid;\r\n            emit RootFallbackIncome(unpaid, \"sponsor_commission\", block.timestamp);\r\n            totalPaid = totalSponsorAllocation;\r\n        }\r\n        \r\n        return _amount - totalPaid;  // Returns 95%\r\n    }\r\n    \r\n    \r\n    function _distributeMatrixIncome(uint _userId, uint _level, uint _amount, bool ignoreQualification) private {\r\n        uint _upline = userInfo[_userId].upline;\r\n        bool paid = false;\r\n        \r\n        // Search up to 13 levels for qualified upline\r\n        for (uint i = 0; i < MAX_INCOME_LAYER && _upline != 0; i++) {\r\n            bool qualified = ignoreQualification || \r\n                            (userInfo[_upline].level > _level && userInfo[_upline].directTeam >= DIRECT_REQUIRED);\r\n            \r\n            if (qualified) {\r\n                // Give FULL remaining amount (90%) to first qualified upline\r\n                bool success = USDT.transfer(userInfo[_upline].account, _amount);\r\n                if (success) {\r\n                    userIncome[_upline].levelIncome += _amount;\r\n                    userIncome[_upline].totalIncome += _amount;\r\n                    paid = true;\r\n                    \r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, true, block.timestamp);\r\n                }\r\n                break;  // Stop after first qualified upline gets paid\r\n            } else {\r\n                // Emit events for transparency, but DON'T track lostIncome\r\n                // (winner-takes-all model - only first qualified gets paid, so no real \"share\" lost)\r\n                if (userInfo[_upline].exists) {\r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, false, block.timestamp);\r\n                    emit IncomeLost(_upline, _userId, _amount, \"Not qualified for matrix\", block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _upline = userInfo[_upline].upline;\r\n        }\r\n        \r\n        // Fallback to root if no qualified upline found\r\n        if (!paid && _amount > 0) {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, _amount), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].levelIncome += _amount;\r\n            userIncome[DEFAULT_REFER].totalIncome += _amount;\r\n            emit RootFallbackIncome(_amount, \"matrix_income\", block.timestamp);\r\n        }\r\n    }\r\n\r\n    \r\n    function _isQualifiedForSponsorLevel(uint _userId, uint8 level) private view returns (bool) {\r\n        User storage user = userInfo[_userId];\r\n        \r\n        if (!user.exists || user.level < 1) return false;\r\n        \r\n        if (level < 5) {\r\n            return true;  // L1-L5: Just need Level 1+\r\n        } else if (level >= 5 && level < 8) {\r\n            return user.directTeam >= MIN_DIRECTS_L6_8;  // L6-L8: 2+ directs\r\n        } else if (level >= 8 && level < 10) {\r\n            return user.directTeam >= MIN_DIRECTS_L9_10;  // L9-L10: 3+ directs\r\n        } else {\r\n            return user.directTeam >= MIN_DIRECTS_L11_13;  // L11-L13: 5+ directs\r\n        }\r\n    }\r\n    \r\n    // ============ INTERNAL FUNCTIONS - USER & MATRIX ============\r\n    \r\n    function _createUser(uint _userId, address _account, uint _referrer, uint _upline, uint _level) private {\r\n        userInfo[_userId] = User({\r\n            exists: true,\r\n            account: _account,\r\n            referrer: _referrer,\r\n            upline: _upline,\r\n            level: _level + 1,\r\n            directTeam: 0,\r\n            team: 0,\r\n            registrationTime: block.timestamp\r\n        });\r\n        \r\n        userIncome[_userId] = UserIncome({\r\n            totalDeposit: 0,\r\n            totalIncome: 0,\r\n            referralIncome: 0,\r\n            sponsorIncome: 0,\r\n            levelIncome: 0\r\n        });\r\n        \r\n        if (_referrer != 0 && _referrer != _userId) {\r\n            userInfo[_referrer].directTeam++;\r\n            directReferrals[_referrer].push(_userId);  // Store in mapping for O(1) lookup\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Place new user in binary matrix using breadth-first search\r\n     * @param _newId ID of new user to place\r\n     * @param _ref Starting point (usually referrer)\r\n     * \r\n     * Searches for available spot (max 2 children per node) within MAX_PLACEMENT_DEPTH.\r\n     * If no spot found within depth limit, falls back to placing under root.\r\n     * This prevents infinite loops but may cluster users in very deep trees.\r\n     */\r\n    function _placeInBinaryMatrix(uint _newId, uint _ref) private {\r\n        uint[] memory queue = new uint[](MAX_PLACEMENT_DEPTH);\r\n        uint front = 0;\r\n        uint back = 0;\r\n        queue[back++] = _ref;\r\n        \r\n        bool placed = false;\r\n        uint iterations = 0;\r\n        \r\n        while (front < back && iterations < MAX_PLACEMENT_DEPTH) {\r\n            uint _upline = queue[front++];\r\n            iterations++;\r\n            \r\n            if (teams[_upline][0].length < 2) {\r\n                teams[_upline][0].push(_newId);\r\n                userInfo[_newId].upline = _upline;\r\n                matrixDirect[_upline]++;\r\n                placed = true;\r\n                break;\r\n            }\r\n            \r\n            for (uint i = 0; i < teams[_upline][0].length && back < MAX_PLACEMENT_DEPTH; i++) {\r\n                queue[back++] = teams[_upline][0][i];\r\n            }\r\n        }\r\n        \r\n        // Fallback to referrer if no spot found within depth limit\r\n        if (!placed) {\r\n            teams[_ref][0].push(_newId);\r\n            userInfo[_newId].upline = _ref;\r\n            matrixDirect[_ref]++;\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Update team counts - FIXED: Only increment once per new user\r\n     * Previously this was over-counting by incrementing multiple times\r\n     */\r\n    function _updateTeamCounts(uint _userId) private {\r\n        uint _upline = userInfo[_userId].referrer;\r\n        uint depth = 0;\r\n        \r\n        // Walk up referral chain and increment team count for each upline\r\n        // Each new user adds +1 to all uplines' team counts\r\n        while (_upline != 0 && depth < MAX_PLACEMENT_DEPTH) {\r\n            userInfo[_upline].team++;\r\n            _upline = userInfo[_upline].referrer;\r\n            depth++;\r\n        }\r\n    }\r\n    \r\n    // ============ VIEW FUNCTIONS ============\r\n    \r\n    function isAutonomous() external view returns (bool) {\r\n        return owner == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get user account address by ID (used by Royalty contract)\r\n     */\r\n    function getUserAccount(uint _userId) external view returns (address) {\r\n        return userInfo[_userId].account;\r\n    }\r\n    \r\n    function getLevelCost(uint _level) external view returns (uint cost, uint adminFee, uint total) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        cost = _getLevelCost(_level);\r\n        adminFee = (cost * ADMIN_FEE_PERCENT) / 100;\r\n        total = cost + adminFee;\r\n    }\r\n    \r\n    function getAllLevelCosts() external view returns (\r\n        uint[13] memory costs,\r\n        uint[13] memory fees,\r\n        uint[13] memory totals\r\n    ) {\r\n        for (uint i = 0; i < 13; i++) {\r\n            costs[i] = _getLevelCost(i);\r\n            fees[i] = (costs[i] * ADMIN_FEE_PERCENT) / 100;\r\n            totals[i] = costs[i] + fees[i];\r\n        }\r\n    }\r\n    \r\n    function getRegistrationCost() external view returns (uint cost, uint levelCost, uint adminFee) {\r\n        levelCost = _getLevelCost(0);\r\n        adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        cost = levelCost + adminFee;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for caller (for dApp use)\r\n     * @dev This version uses msg.sender - DOES NOT WORK on BSCScan Read Contract!\r\n     *      Use getUpgradeCostFor() on BSCScan instead\r\n     */\r\n    function getUpgradeCost(uint _levels) external view returns (uint totalCost, uint[] memory breakdown) {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[myId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);  // FIX: targetLevel is 1-13, need index 0-12\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for specific user (BSCScan-friendly!)\r\n     * @param _userAddress Address of the user to check\r\n     * @param _levels Number of levels to upgrade\r\n     * @return totalCost Total USDT cost (including admin fee)\r\n     * @return breakdown Cost breakdown per level\r\n     */\r\n    function getUpgradeCostFor(address _userAddress, uint _levels) \r\n        external view returns (uint totalCost, uint[] memory breakdown) \r\n    {\r\n        uint userId = id[_userAddress];\r\n        require(userId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[userId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    function getMyInfo() external view returns (\r\n        uint userId,\r\n        uint level,\r\n        uint team,\r\n        uint directTeam,\r\n        uint totalIncome,\r\n        uint referrerId,\r\n        uint uplineId,\r\n        uint registrationTime\r\n    ) {\r\n        userId = id[msg.sender];\r\n        if (userId == 0) return (0, 0, 0, 0, 0, 0, 0, 0);\r\n        \r\n        User storage user = userInfo[userId];\r\n        UserIncome storage income = userIncome[userId];\r\n        \r\n        return (\r\n            userId,\r\n            user.level,\r\n            user.team,\r\n            user.directTeam,\r\n            income.totalIncome,\r\n            user.referrer,\r\n            user.upline,\r\n            user.registrationTime\r\n        );\r\n    }\r\n    \r\n    function getMyIncomeBreakdown() external view returns (\r\n        uint totalDeposit,\r\n        uint totalIncome,\r\n        uint referralIncome,\r\n        uint sponsorIncome,\r\n        uint levelIncome,\r\n        uint lostAmount\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, 0, 0, 0, 0);\r\n        \r\n        UserIncome storage income = userIncome[myId];\r\n        return (\r\n            income.totalDeposit,\r\n            income.totalIncome,\r\n            income.referralIncome,\r\n            income.sponsorIncome,\r\n            income.levelIncome,\r\n            lostIncome[myId]\r\n        );\r\n    }\r\n    \r\n    function getMyTeam() external view returns (\r\n        uint teamSize,\r\n        uint directCount,\r\n        uint[] memory directReferralIds,\r\n        address[] memory directReferralAddresses\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, new uint[](0), new address[](0));\r\n        \r\n        User storage user = userInfo[myId];\r\n        teamSize = user.team;\r\n        directCount = user.directTeam;\r\n        \r\n        // Use mapping for O(1) lookup instead of O(N) loop\r\n        directReferralIds = directReferrals[myId];\r\n        \r\n        // Build addresses array\r\n        directReferralAddresses = new address[](directReferralIds.length);\r\n        for (uint i = 0; i < directReferralIds.length; i++) {\r\n            directReferralAddresses[i] = userInfo[directReferralIds[i]].account;\r\n        }\r\n    }\r\n    \r\n    function getMyRoyaltyStatus() external view returns (\r\n        uint[4] memory claimableAmounts,\r\n        bool[4] memory isEligible,\r\n        bool[4] memory hasClaimed\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (claimableAmounts, isEligible, hasClaimed);\r\n        \r\n        for (uint i = 0; i < 4; i++) {\r\n            (claimableAmounts[i], isEligible[i], hasClaimed[i]) = ROYALTY_ADDR.getUserRoyaltyData(myId, i);\r\n        }\r\n    }\r\n    \r\n    function isRegistered(address _address) external view returns (bool) {\r\n        return id[_address] > 0;\r\n    }\r\n    \r\n    function getContractBalance() external view returns (uint) {\r\n        return USDT.balanceOf(address(this));\r\n    }\r\n}\r\n"
    },
    "contracts/FiveDollarRide_USDT.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title FiveDollarRide - The $5 Opportunity Platform\r\n * @notice Revolutionary income platform starting at just $5 with USDT payments\r\n * @dev Owner-controlled smart contract with progressive decentralization capability\r\n * \r\n * Features:\r\n * - 13 Level progression ($5 to $20,480)\r\n * - Binary matrix tree structure  \r\n * - Multi-layer income distribution (20 layers)\r\n * - Sponsor commissions (13 levels)\r\n * - Royalty pool funding (5% per upgrade)\r\n * - USDT-based payments only\r\n * - Owner-controlled parameters (immutable after ownership renouncement)\r\n * - Full event-driven transparency\r\n * \r\n * Brand: FiveDollarRide - Your $5 Journey to Financial Freedom\r\n */\r\n\r\n// Royalty Contract Interface\r\ninterface IRoyalty {\r\n    function registerUser(uint _userId, uint _level, uint _directCount) external;\r\n    function claimRoyalty(\r\n        uint _id, \r\n        uint _tier,\r\n        uint rootUserId,\r\n        uint userTotalIncome,\r\n        uint userTotalDeposit,\r\n        address userAccount\r\n    ) external returns (uint);\r\n    function getUserRoyaltyData(uint _userId, uint _tier) external view returns (uint, bool, bool);\r\n    function getRoyaltyPercents() external view returns(uint[4] memory);\r\n    function getRoyaltyLevels() external view returns(uint[4] memory);\r\n    function getTierStats(uint _tier) external view returns(uint userCount, uint distributionRound, uint pendingUserCount);\r\n}\r\n\r\ncontract FiveDollarRide {\r\n    using SafeERC20 for IERC20;\r\n    \r\n    // ============ IMMUTABLE VALUES (SET AT DEPLOYMENT) ============\r\n    \r\n    address public immutable FEE_RECEIVER;\r\n    IERC20 public immutable USDT;\r\n    IRoyalty public immutable ROYALTY_ADDR;\r\n    uint private immutable DEFAULT_REFER;\r\n    uint public immutable START_TIME;\r\n    \r\n    // ============ CONSTANTS (HARDCODED FOREVER) ============\r\n    \r\n    // System constants\r\n    uint8 public constant MAX_LEVELS = 13;\r\n    uint8 public constant MAX_INCOME_LAYER = 13;  // Income distribution depth (matches 13 levels)\r\n    uint8 public constant MAX_PLACEMENT_DEPTH = 100;  // Placement search depth\r\n    // Note: If tree depth exceeds 100, placement falls back to root (DEFAULT_REFER)\r\n    // This prevents infinite loops but may cluster users under root in very large trees\r\n    \r\n    // Economic constants (adjustable by owner until renounced)\r\n    uint8 public constant ADMIN_FEE_PERCENT = 5;      // 5% admin fee\r\n    uint8 public constant ROYALTY_FUND_PERCENT = 5;   // 5% to royalty pool\r\n    \r\n    // Level costs (adjustable by owner, immutable after renounce)\r\n    // Starting costs: L1=$5, L2=$10, L3=$20... up to L13=$20,480 (hardcoded initially)\r\n    uint256[13] public levelCosts = [\r\n        5e18,      // L1: $5\r\n        10e18,     // L2: $10  \r\n        20e18,     // L3: $20\r\n        40e18,     // L4: $40\r\n        80e18,     // L5: $80\r\n        160e18,    // L6: $160\r\n        320e18,    // L7: $320\r\n        640e18,    // L8: $640\r\n        1280e18,   // L9: $1,280\r\n        2560e18,   // L10: $2,560\r\n        5120e18,   // L11: $5,120\r\n        10240e18,  // L12: $10,240\r\n        20480e18   // L13: $20,480\r\n    ];\r\n    \r\n    // Team & income constants\r\n    uint public constant DIRECT_REQUIRED = 2;\r\n    uint public constant MAX_REFERRAL_LAYERS = 1;\r\n    \r\n    // Sponsor commission (13 levels, total 5%)\r\n    uint8 private constant SPONSOR_LEVELS = 13;\r\n    \r\n    function _getSponsorPercentage(uint8 level) private pure returns (uint16) {\r\n        if (level == 0) return 100;   // L1: 1%\r\n        if (level == 1) return 80;    // L2: 0.8%\r\n        if (level == 2) return 60;    // L3: 0.6%\r\n        if (level == 3) return 50;    // L4: 0.5%\r\n        if (level == 4) return 50;    // L5: 0.5%\r\n        if (level == 5) return 40;    // L6: 0.4%\r\n        if (level == 6) return 30;    // L7: 0.3%\r\n        if (level == 7) return 25;    // L8: 0.25%\r\n        if (level == 8) return 20;    // L9: 0.2%\r\n        if (level == 9) return 15;    // L10: 0.15%\r\n        if (level == 10) return 10;   // L11: 0.1%\r\n        if (level == 11) return 10;   // L12: 0.1%\r\n        if (level == 12) return 10;   // L13: 0.1%\r\n        return 0;\r\n    }\r\n    \r\n    // Sponsor qualification thresholds\r\n    uint8 private constant MIN_DIRECTS_L6_8 = 2;\r\n    uint8 private constant MIN_DIRECTS_L9_10 = 3;\r\n    uint8 private constant MIN_DIRECTS_L11_13 = 5;\r\n    \r\n    \r\n    // ============ STATE VARIABLES ============\r\n    \r\n    // Owner (can renounce)\r\n    address public owner;\r\n    \r\n    // Emergency controls\r\n    bool public paused;\r\n    \r\n    // Reentrancy guard (improved pattern)\r\n    uint256 private unlocked = 1;\r\n    \r\n    // User tracking\r\n    uint public totalUsers;\r\n    uint private userIdCounter;\r\n    \r\n    // ============ DATA STRUCTURES ============\r\n    \r\n    struct User {\r\n        bool exists;\r\n        address account;\r\n        uint referrer;\r\n        uint upline;\r\n        uint level;\r\n        uint directTeam;\r\n        uint team;\r\n        uint registrationTime;\r\n    }\r\n    \r\n    struct UserIncome {\r\n        uint totalDeposit;\r\n        uint totalIncome;\r\n        uint referralIncome;\r\n        uint sponsorIncome;\r\n        uint levelIncome;\r\n    }\r\n    \r\n    struct Activity {\r\n        uint id;\r\n        uint level;\r\n        uint time;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => uint) public id;\r\n    mapping(uint => User) public userInfo;\r\n    mapping(uint => UserIncome) public userIncome;\r\n    mapping(uint => mapping(uint => uint[])) public teams;\r\n    mapping(uint => uint) public matrixDirect;\r\n    mapping(uint => uint) public lostIncome;\r\n    mapping(uint => uint[]) private directReferrals;  // NEW: O(1) direct team lookup\r\n    \r\n    uint[] private globalUsers;  // Changed to private (use events instead)\r\n    Activity[] private activity;  // Changed to private (use events instead)\r\n    \r\n    // ============ EVENTS ============\r\n    \r\n    // User lifecycle\r\n    event UserRegistered(uint indexed userId, address indexed account, uint indexed referrer, uint timestamp);\r\n    event UserUpgraded(uint indexed userId, uint newLevel, uint amount, uint timestamp);\r\n    event RootUserCreated(uint indexed rootUserId, address indexed rootAddress, uint timestamp);\r\n    \r\n    // Payments & income\r\n    event AdminFeePaid(uint amount, uint level, uint timestamp);\r\n    event ReferralPayment(uint indexed referrerId, uint indexed userId, uint amount, uint timestamp);\r\n    event SponsorCommissionPaid(uint indexed sponsorId, uint indexed fromUserId, uint amount, uint level, uint timestamp);\r\n    event MatrixPayment(uint indexed fromUserId, uint indexed toUserId, uint amount, uint level, uint layer, bool qualified, uint timestamp);\r\n    event IncomeLost(uint indexed userId, uint indexed fromUser, uint amount, string reason, uint timestamp);\r\n    event RoyaltyPoolFunded(uint indexed userId, uint amount, uint timestamp);\r\n    event RoyaltyClaimed(uint indexed userId, uint indexed royaltyLevel, uint amount, uint timestamp);\r\n    \r\n    // Ownership & Emergency\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipRenounced(address indexed previousOwner, uint timestamp);\r\n    event LevelCostUpdated(uint8 indexed level, uint256 oldCost, uint256 newCost, uint timestamp);\r\n    event ContractPaused(address indexed by, uint timestamp);\r\n    event ContractUnpaused(address indexed by, uint timestamp);\r\n    event RootFallbackIncome(uint amount, string source, uint timestamp);\r\n    \r\n    // ============ MODIFIERS ============\r\n    \r\n    modifier nonReentrant() {\r\n        require(unlocked == 1, \"Reentrancy detected\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n    \r\n    modifier validUser(uint _userId) {\r\n        require(_userId > 0 && userInfo[_userId].exists, \"Invalid user ID\");\r\n        _;\r\n    }\r\n    \r\n    // ============ CONSTRUCTOR ============\r\n    \r\n    constructor(\r\n        address _feeReceiver,\r\n        address _royalty,\r\n        address _rootUserAddress,\r\n        uint _rootUserId,\r\n        address _usdtToken\r\n    ) {\r\n        require(_feeReceiver != address(0), \"Invalid fee receiver\");\r\n        require(_royalty != address(0), \"Invalid royalty\");\r\n        require(_rootUserAddress != address(0), \"Invalid root address\");\r\n        require(_rootUserId > 0, \"Invalid root user ID\");\r\n        require(_usdtToken != address(0), \"Invalid USDT\");\r\n        \r\n        // Set immutables\r\n        FEE_RECEIVER = _feeReceiver;\r\n        ROYALTY_ADDR = IRoyalty(_royalty);\r\n        DEFAULT_REFER = _rootUserId;\r\n        START_TIME = block.timestamp;\r\n        USDT = IERC20(_usdtToken);\r\n        \r\n        // Set owner\r\n        owner = msg.sender;\r\n        \r\n        // Initialize root user\r\n        userIdCounter = DEFAULT_REFER;\r\n        id[_rootUserAddress] = DEFAULT_REFER;\r\n        _createUser(DEFAULT_REFER, _rootUserAddress, DEFAULT_REFER, DEFAULT_REFER, 12);\r\n        globalUsers.push(DEFAULT_REFER);\r\n        totalUsers = 1;\r\n        // Root user already has level 13 from _createUser (12 + 1)\r\n        \r\n        // Register root to all royalty tiers\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 10, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 11, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 12, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 13, 0);\r\n        \r\n        emit RootUserCreated(DEFAULT_REFER, _rootUserAddress, block.timestamp);\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n    \r\n    // ============ LEVEL COST HELPER ============\r\n    \r\n    /**\r\n     * @dev Get level cost in USDT (uses adjustable levelCosts array)\r\n     * @param _level Level index (0-12 for L1-L13)\r\n     * @return USDT cost in wei (18 decimals)\r\n     */\r\n    function _getLevelCost(uint _level) private view returns (uint) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        return levelCosts[_level];\r\n    }\r\n    \r\n    // ============ USER FUNCTIONS ============\r\n    \r\n    \r\n    /**\r\n     * @notice Register new user with USDT payment  \r\n     * @param _ref Referrer user ID (0 = default)\r\n     * @param _newAcc New user wallet address\r\n     */\r\n    function register(uint _ref, address _newAcc) external nonReentrant whenNotPaused {\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly registration using referrer address\r\n     */\r\n    function registerMe(address _referrerAddress) external nonReentrant whenNotPaused {\r\n        uint _ref = (_referrerAddress == address(0)) ? 0 : id[_referrerAddress];\r\n        address _newAcc = msg.sender;\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice Upgrade user to higher levels with USDT\r\n     */\r\n    function upgrade(uint _id, uint _lvls) external nonReentrant whenNotPaused validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        require(userInfo[_id].level + _lvls <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        \r\n        // Calculate total cost\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        // Transfer USDT from user\r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        // Process each level\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[_id].level++;\r\n            userIncome[_id].totalDeposit += levelCost;\r\n            \r\n            // Pay admin fee\r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[_id].level - 1, block.timestamp);\r\n            }\r\n            \r\n            // Fund royalty pool (5% of levelCost)\r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n                emit RoyaltyPoolFunded(_id, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            // Distribute payments\r\n            uint remaining = _processSponsorCommission(_id, levelCost);\r\n            _distributeMatrixIncome(_id, userInfo[_id].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            // Register for royalty\r\n            ROYALTY_ADDR.registerUser(_id, userInfo[_id].level, userInfo[_id].directTeam);\r\n            \r\n            emit UserUpgraded(_id, userInfo[_id].level, levelCost, block.timestamp);\r\n            activity.push(Activity(_id, userInfo[_id].level, block.timestamp));\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly upgrade for caller\r\n     */\r\n    function upgradeMe(uint _levels) external nonReentrant whenNotPaused {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        require(msg.sender == userInfo[myId].account, \"Unauthorized\");\r\n        require(userInfo[myId].level + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[myId].level++;\r\n            userIncome[myId].totalDeposit += levelCost;\r\n            \r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[myId].level - 1, block.timestamp);\r\n            }\r\n            \r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");emit RoyaltyPoolFunded(myId, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            uint remaining = _processSponsorCommission(myId, levelCost);\r\n            _distributeMatrixIncome(myId, userInfo[myId].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            ROYALTY_ADDR.registerUser(myId, userInfo[myId].level, userInfo[myId].directTeam);\r\n            \r\n            emit UserUpgraded(myId, userInfo[myId].level, levelCost, block.timestamp);\r\n            activity.push(Activity(myId, userInfo[myId].level, block.timestamp));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim royalty reward\r\n     */\r\n    function claimRoyalty(uint _id, uint _royaltyLvl) external nonReentrant validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            _id,\r\n            _royaltyLvl,\r\n            DEFAULT_REFER,\r\n            userIncome[_id].totalIncome,\r\n            userIncome[_id].totalDeposit,\r\n            userInfo[_id].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(_id, _royaltyLvl, amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly royalty claim\r\n     */\r\n    function claimMyRoyalty(uint _tier) external nonReentrant {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            myId,\r\n            _tier,\r\n            DEFAULT_REFER,\r\n            userIncome[myId].totalIncome,\r\n            userIncome[myId].totalDeposit,\r\n            userInfo[myId].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(myId, _tier, amount, block.timestamp);\r\n    }\r\n    \r\n    // ============ OWNER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Renounce ownership - makes contract fully autonomous\r\n     * @dev IRREVERSIBLE - contract becomes ownerless forever\r\n     */\r\n    function renounceOwnership() external onlyOwner {\r\n        emit OwnershipRenounced(owner, block.timestamp);\r\n        owner = address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfer ownership to new address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Update level cost (owner only, before renouncing)\r\n     * @dev Allows flexibility during initial phase, becomes immutable after renounce\r\n     */\r\n    function setLevelCost(uint8 _level, uint256 _newCost) external onlyOwner {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        require(_newCost > 0, \"Cost must be positive\");\r\n        require(_newCost >= 1e18, \"Minimum cost is 1 USDT\");\r\n        require(_newCost <= 100000e18, \"Maximum cost is 100,000 USDT\");\r\n        \r\n        // Ensure costs are ascending (level n+1 > level n)\r\n        if (_level > 0) {\r\n            require(_newCost > levelCosts[_level - 1], \"Cost must increase\");\r\n        }\r\n        if (_level < MAX_LEVELS - 1) {\r\n            require(_newCost < levelCosts[_level + 1] || levelCosts[_level + 1] == 0, \"Cost must be less than next level\");\r\n        }\r\n        \r\n        uint256 oldCost = levelCosts[_level];\r\n        levelCosts[_level] = _newCost;\r\n        \r\n        emit LevelCostUpdated(_level, oldCost, _newCost, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Pause contract in case of emergency\r\n     * @dev Only owner can pause, prevents all user operations\r\n     */\r\n    function pauseContract() external onlyOwner {\r\n        require(!paused, \"Already paused\");\r\n        paused = true;\r\n        emit ContractPaused(msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Resume contract operations\r\n     */\r\n    function unpauseContract() external onlyOwner {\r\n        require(paused, \"Not paused\");\r\n        paused = false;\r\n        emit ContractUnpaused(msg.sender, block.timestamp);\r\n    }\r\n\r\n    \r\n    // ============ INTERNAL FUNCTIONS - PAYMENT DISTRIBUTION ============\r\n    \r\n    function _processRegistrationPayments(uint _newId, uint _levelCost, uint _adminFee) private {\r\n        // Pay admin fee (5%)\r\n        if (_adminFee > 0) {\r\n            require(USDT.transfer(FEE_RECEIVER, _adminFee), \"Admin fee failed\");\r\n            emit AdminFeePaid(_adminFee, 0, block.timestamp);\r\n        }\r\n        \r\n        // Fund royalty pool (5% of levelCost)\r\n        uint royaltyFundAmt = (_levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n        if (royaltyFundAmt > 0) {\r\n            require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n            emit RoyaltyPoolFunded(_newId, royaltyFundAmt, block.timestamp);\r\n        }\r\n        \r\n        // Referral income (95% = levelCost - royaltyFund)\r\n        uint _referrer = userInfo[_newId].referrer;\r\n        uint referralAmount = _levelCost - royaltyFundAmt;\r\n        \r\n        if (_referrer != 0 && userInfo[_referrer].exists) {\r\n            require(USDT.transfer(userInfo[_referrer].account, referralAmount), \"Referral failed\");\r\n            userIncome[_referrer].referralIncome += referralAmount;\r\n            userIncome[_referrer].totalIncome += referralAmount;\r\n            emit ReferralPayment(_referrer, _newId, referralAmount, block.timestamp);\r\n        } else {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, referralAmount), \"Default referral failed\");\r\n            userIncome[DEFAULT_REFER].referralIncome += referralAmount;\r\n            userIncome[DEFAULT_REFER].totalIncome += referralAmount;\r\n            emit ReferralPayment(DEFAULT_REFER, _newId, referralAmount, block.timestamp);\r\n        }\r\n        \r\n        // Note: For registration, income goes to Referrer, NOT matrix\r\n        // Matrix distribution only happens on upgrade\r\n    }\r\n\r\n    \r\n    function _processSponsorCommission(uint _id, uint _amount) private returns (uint) {\r\n        uint _referrer = userInfo[_id].referrer;\r\n        uint totalPaid = 0;\r\n        uint totalSponsorAllocation = (_amount * 500) / 10000;  // 5%\r\n        \r\n        // Distribute to up to 13 levels\r\n        for (uint8 level = 0; level < SPONSOR_LEVELS && _referrer != 0; level++) {\r\n            bool qualified = _isQualifiedForSponsorLevel(_referrer, level);\r\n            uint reward = (_amount * _getSponsorPercentage(level)) / 10000;\r\n            \r\n            if (qualified && reward > 0) {\r\n                bool success = USDT.transfer(userInfo[_referrer].account, reward);\r\n                if (success) {\r\n                    userIncome[_referrer].sponsorIncome += reward;\r\n                    userIncome[_referrer].totalIncome += reward;\r\n                    totalPaid += reward;\r\n                    \r\n                    emit SponsorCommissionPaid(_referrer, _id, reward, level + 1, block.timestamp);\r\n                }\r\n            } else if (reward > 0) {\r\n                // Track lost income only if upline exists\r\n                if (userInfo[_referrer].exists) {\r\n                    lostIncome[_referrer] += reward;\r\n                    \r\n                    string memory reason;\r\n                    if (level < 5) {\r\n                        reason = \"Not active (need Level 1+)\";\r\n                    } else if (level >= 5 && level < 8) {\r\n                        reason = \"Need 2+ direct referrals for L6-L8\";\r\n                    } else if (level >= 8 && level < 10) {\r\n                        reason = \"Need 3+ direct referrals for L9-L10\";\r\n                    } else {\r\n                        reason = \"Need 5+ direct referrals for L11-L13\";\r\n                    }\r\n                    \r\n                    emit IncomeLost(_referrer, _id,reward, reason, block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _referrer = userInfo[_referrer].referrer;\r\n        }\r\n        \r\n        // Fallback to root for unpaid commission\r\n        if (totalPaid < totalSponsorAllocation) {\r\n            uint unpaid = totalSponsorAllocation - totalPaid;\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, unpaid), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].sponsorIncome += unpaid;\r\n            userIncome[DEFAULT_REFER].totalIncome += unpaid;\r\n            emit RootFallbackIncome(unpaid, \"sponsor_commission\", block.timestamp);\r\n            totalPaid = totalSponsorAllocation;\r\n        }\r\n        \r\n        return _amount - totalPaid;  // Returns 95%\r\n    }\r\n    \r\n    \r\n    function _distributeMatrixIncome(uint _userId, uint _level, uint _amount, bool ignoreQualification) private {\r\n        uint _upline = userInfo[_userId].upline;\r\n        bool paid = false;\r\n        \r\n        // Search up to 13 levels for qualified upline\r\n        for (uint i = 0; i < MAX_INCOME_LAYER && _upline != 0; i++) {\r\n            bool qualified = ignoreQualification || \r\n                            (userInfo[_upline].level > _level && userInfo[_upline].directTeam >= DIRECT_REQUIRED);\r\n            \r\n            if (qualified) {\r\n                // Give FULL remaining amount (90%) to first qualified upline\r\n                bool success = USDT.transfer(userInfo[_upline].account, _amount);\r\n                if (success) {\r\n                    userIncome[_upline].levelIncome += _amount;\r\n                    userIncome[_upline].totalIncome += _amount;\r\n                    paid = true;\r\n                    \r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, true, block.timestamp);\r\n                }\r\n                break;  // Stop after first qualified upline gets paid\r\n            } else {\r\n                // Emit events for transparency, but DON'T track lostIncome\r\n                // (winner-takes-all model - only first qualified gets paid, so no real \"share\" lost)\r\n                if (userInfo[_upline].exists) {\r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, false, block.timestamp);\r\n                    emit IncomeLost(_upline, _userId, _amount, \"Not qualified for matrix\", block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _upline = userInfo[_upline].upline;\r\n        }\r\n        \r\n        // Fallback to root if no qualified upline found\r\n        if (!paid && _amount > 0) {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, _amount), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].levelIncome += _amount;\r\n            userIncome[DEFAULT_REFER].totalIncome += _amount;\r\n            emit RootFallbackIncome(_amount, \"matrix_income\", block.timestamp);\r\n        }\r\n    }\r\n\r\n    \r\n    function _isQualifiedForSponsorLevel(uint _userId, uint8 level) private view returns (bool) {\r\n        User storage user = userInfo[_userId];\r\n        \r\n        if (!user.exists || user.level < 1) return false;\r\n        \r\n        if (level < 5) {\r\n            return true;  // L1-L5: Just need Level 1+\r\n        } else if (level >= 5 && level < 8) {\r\n            return user.directTeam >= MIN_DIRECTS_L6_8;  // L6-L8: 2+ directs\r\n        } else if (level >= 8 && level < 10) {\r\n            return user.directTeam >= MIN_DIRECTS_L9_10;  // L9-L10: 3+ directs\r\n        } else {\r\n            return user.directTeam >= MIN_DIRECTS_L11_13;  // L11-L13: 5+ directs\r\n        }\r\n    }\r\n    \r\n    // ============ INTERNAL FUNCTIONS - USER & MATRIX ============\r\n    \r\n    function _createUser(uint _userId, address _account, uint _referrer, uint _upline, uint _level) private {\r\n        userInfo[_userId] = User({\r\n            exists: true,\r\n            account: _account,\r\n            referrer: _referrer,\r\n            upline: _upline,\r\n            level: _level + 1,\r\n            directTeam: 0,\r\n            team: 0,\r\n            registrationTime: block.timestamp\r\n        });\r\n        \r\n        userIncome[_userId] = UserIncome({\r\n            totalDeposit: 0,\r\n            totalIncome: 0,\r\n            referralIncome: 0,\r\n            sponsorIncome: 0,\r\n            levelIncome: 0\r\n        });\r\n        \r\n        if (_referrer != 0 && _referrer != _userId) {\r\n            userInfo[_referrer].directTeam++;\r\n            directReferrals[_referrer].push(_userId);  // Store in mapping for O(1) lookup\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Place new user in binary matrix using breadth-first search\r\n     * @param _newId ID of new user to place\r\n     * @param _ref Starting point (usually referrer)\r\n     * \r\n     * Searches for available spot (max 2 children per node) within MAX_PLACEMENT_DEPTH.\r\n     * If no spot found within depth limit, falls back to placing under root.\r\n     * This prevents infinite loops but may cluster users in very deep trees.\r\n     */\r\n    function _placeInBinaryMatrix(uint _newId, uint _ref) private {\r\n        uint[] memory queue = new uint[](MAX_PLACEMENT_DEPTH);\r\n        uint front = 0;\r\n        uint back = 0;\r\n        queue[back++] = _ref;\r\n        \r\n        bool placed = false;\r\n        uint iterations = 0;\r\n        \r\n        while (front < back && iterations < MAX_PLACEMENT_DEPTH) {\r\n            uint _upline = queue[front++];\r\n            iterations++;\r\n            \r\n            if (teams[_upline][0].length < 2) {\r\n                teams[_upline][0].push(_newId);\r\n                userInfo[_newId].upline = _upline;\r\n                matrixDirect[_upline]++;\r\n                placed = true;\r\n                break;\r\n            }\r\n            \r\n            for (uint i = 0; i < teams[_upline][0].length && back < MAX_PLACEMENT_DEPTH; i++) {\r\n                queue[back++] = teams[_upline][0][i];\r\n            }\r\n        }\r\n        \r\n        // Fallback to referrer if no spot found within depth limit\r\n        if (!placed) {\r\n            teams[_ref][0].push(_newId);\r\n            userInfo[_newId].upline = _ref;\r\n            matrixDirect[_ref]++;\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Update team counts - FIXED: Only increment once per new user\r\n     * Previously this was over-counting by incrementing multiple times\r\n     */\r\n    function _updateTeamCounts(uint _userId) private {\r\n        uint _upline = userInfo[_userId].referrer;\r\n        uint depth = 0;\r\n        \r\n        // Walk up referral chain and increment team count for each upline\r\n        // Each new user adds +1 to all uplines' team counts\r\n        while (_upline != 0 && depth < MAX_PLACEMENT_DEPTH) {\r\n            userInfo[_upline].team++;\r\n            _upline = userInfo[_upline].referrer;\r\n            depth++;\r\n        }\r\n    }\r\n    \r\n    // ============ VIEW FUNCTIONS ============\r\n    \r\n    function isAutonomous() external view returns (bool) {\r\n        return owner == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get user account address by ID (used by Royalty contract)\r\n     */\r\n    function getUserAccount(uint _userId) external view returns (address) {\r\n        return userInfo[_userId].account;\r\n    }\r\n    \r\n    function getLevelCost(uint _level) external view returns (uint cost, uint adminFee, uint total) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        cost = _getLevelCost(_level);\r\n        adminFee = (cost * ADMIN_FEE_PERCENT) / 100;\r\n        total = cost + adminFee;\r\n    }\r\n    \r\n    function getAllLevelCosts() external view returns (\r\n        uint[13] memory costs,\r\n        uint[13] memory fees,\r\n        uint[13] memory totals\r\n    ) {\r\n        for (uint i = 0; i < 13; i++) {\r\n            costs[i] = _getLevelCost(i);\r\n            fees[i] = (costs[i] * ADMIN_FEE_PERCENT) / 100;\r\n            totals[i] = costs[i] + fees[i];\r\n        }\r\n    }\r\n    \r\n    function getRegistrationCost() external view returns (uint cost, uint levelCost, uint adminFee) {\r\n        levelCost = _getLevelCost(0);\r\n        adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        cost = levelCost + adminFee;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for caller (for dApp use)\r\n     * @dev This version uses msg.sender - DOES NOT WORK on BSCScan Read Contract!\r\n     *      Use getUpgradeCostFor() on BSCScan instead\r\n     */\r\n    function getUpgradeCost(uint _levels) external view returns (uint totalCost, uint[] memory breakdown) {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[myId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);  // FIX: targetLevel is 1-13, need index 0-12\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for specific user (BSCScan-friendly!)\r\n     * @param _userAddress Address of the user to check\r\n     * @param _levels Number of levels to upgrade\r\n     * @return totalCost Total USDT cost (including admin fee)\r\n     * @return breakdown Cost breakdown per level\r\n     */\r\n    function getUpgradeCostFor(address _userAddress, uint _levels) \r\n        external view returns (uint totalCost, uint[] memory breakdown) \r\n    {\r\n        uint userId = id[_userAddress];\r\n        require(userId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[userId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    function getMyInfo() external view returns (\r\n        uint userId,\r\n        uint level,\r\n        uint team,\r\n        uint directTeam,\r\n        uint totalIncome,\r\n        uint referrerId,\r\n        uint uplineId,\r\n        uint registrationTime\r\n    ) {\r\n        userId = id[msg.sender];\r\n        if (userId == 0) return (0, 0, 0, 0, 0, 0, 0, 0);\r\n        \r\n        User storage user = userInfo[userId];\r\n        UserIncome storage income = userIncome[userId];\r\n        \r\n        return (\r\n            userId,\r\n            user.level,\r\n            user.team,\r\n            user.directTeam,\r\n            income.totalIncome,\r\n            user.referrer,\r\n            user.upline,\r\n            user.registrationTime\r\n        );\r\n    }\r\n    \r\n    function getMyIncomeBreakdown() external view returns (\r\n        uint totalDeposit,\r\n        uint totalIncome,\r\n        uint referralIncome,\r\n        uint sponsorIncome,\r\n        uint levelIncome,\r\n        uint lostAmount\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, 0, 0, 0, 0);\r\n        \r\n        UserIncome storage income = userIncome[myId];\r\n        return (\r\n            income.totalDeposit,\r\n            income.totalIncome,\r\n            income.referralIncome,\r\n            income.sponsorIncome,\r\n            income.levelIncome,\r\n            lostIncome[myId]\r\n        );\r\n    }\r\n    \r\n    function getMyTeam() external view returns (\r\n        uint teamSize,\r\n        uint directCount,\r\n        uint[] memory directReferralIds,\r\n        address[] memory directReferralAddresses\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, new uint[](0), new address[](0));\r\n        \r\n        User storage user = userInfo[myId];\r\n        teamSize = user.team;\r\n        directCount = user.directTeam;\r\n        \r\n        // Use mapping for O(1) lookup instead of O(N) loop\r\n        directReferralIds = directReferrals[myId];\r\n        \r\n        // Build addresses array\r\n        directReferralAddresses = new address[](directReferralIds.length);\r\n        for (uint i = 0; i < directReferralIds.length; i++) {\r\n            directReferralAddresses[i] = userInfo[directReferralIds[i]].account;\r\n        }\r\n    }\r\n    \r\n    function getMyRoyaltyStatus() external view returns (\r\n        uint[4] memory claimableAmounts,\r\n        bool[4] memory isEligible,\r\n        bool[4] memory hasClaimed\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (claimableAmounts, isEligible, hasClaimed);\r\n        \r\n        for (uint i = 0; i < 4; i++) {\r\n            (claimableAmounts[i], isEligible[i], hasClaimed[i]) = ROYALTY_ADDR.getUserRoyaltyData(myId, i);\r\n        }\r\n    }\r\n    \r\n    function isRegistered(address _address) external view returns (bool) {\r\n        return id[_address] > 0;\r\n    }\r\n    \r\n    function getContractBalance() external view returns (uint) {\r\n        return USDT.balanceOf(address(this));\r\n    }\r\n}\r\n"
    },
    "contracts/FiveDollarRide.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title FiveDollarRide - The $5 Opportunity Platform\r\n * @notice Revolutionary income platform starting at just $5 with USDT payments\r\n * @dev Owner-controlled smart contract with progressive decentralization capability\r\n * \r\n * Features:\r\n * - 13 Level progression ($5 to $20,480)\r\n * - Binary matrix tree structure  \r\n * - Multi-layer income distribution (20 layers)\r\n * - Sponsor commissions (13 levels)\r\n * - Royalty pool funding (5% per upgrade)\r\n * - USDT-based payments only\r\n * - Owner-controlled parameters (immutable after ownership renouncement)\r\n * - Full event-driven transparency\r\n * \r\n * Brand: FiveDollarRide - Your $5 Journey to Financial Freedom\r\n */\r\n// USDT Token Interface\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n// Royalty Contract Interface\r\ninterface IRoyalty {\r\n    function registerUser(uint _userId, uint _level, uint _directCount) external;\r\n    function claimRoyalty(\r\n        uint _id, \r\n        uint _tier,\r\n        uint rootUserId,\r\n        uint userTotalIncome,\r\n        uint userTotalDeposit,\r\n        address userAccount\r\n    ) external returns (uint);\r\n    function getUserRoyaltyData(uint _userId, uint _tier) external view returns (uint, bool, bool);\r\n    function getRoyaltyPercents() external view returns(uint[4] memory);\r\n    function getRoyaltyLevels() external view returns(uint[4] memory);\r\n    function getTierStats(uint _tier) external view returns(uint userCount, uint distributionRound, uint pendingUserCount);\r\n}\r\n\r\ncontract FiveDollarRide {\r\n    // ============ IMMUTABLE VALUES (SET AT DEPLOYMENT) ============\r\n    \r\n    address public immutable FEE_RECEIVER;\r\n    IERC20 public immutable USDT;\r\n    IRoyalty public immutable ROYALTY_ADDR;\r\n    uint private immutable DEFAULT_REFER;\r\n    uint public immutable START_TIME;\r\n    \r\n    // ============ CONSTANTS (HARDCODED FOREVER) ============\r\n    \r\n    // System constants\r\n    uint8 public constant MAX_LEVELS = 13;\r\n    uint8 public constant MAX_INCOME_LAYER = 13;  // Income distribution depth (matches 13 levels)\r\n    uint8 public constant MAX_PLACEMENT_DEPTH = 100;  // Placement search depth\r\n    // Note: If tree depth exceeds 100, placement falls back to root (DEFAULT_REFER)\r\n    // This prevents infinite loops but may cluster users under root in very large trees\r\n    \r\n    // Economic constants (adjustable by owner until renounced)\r\n    uint8 public constant ADMIN_FEE_PERCENT = 5;      // 5% admin fee\r\n    uint8 public constant ROYALTY_FUND_PERCENT = 5;   // 5% to royalty pool\r\n    \r\n    // Level costs (adjustable by owner, immutable after renounce)\r\n    // Starting costs: L1=$5, L2=$10, L3=$20... up to L13=$20,480 (hardcoded initially)\r\n    uint256[13] public levelCosts = [\r\n        5e18,      // L1: $5\r\n        10e18,     // L2: $10  \r\n        20e18,     // L3: $20\r\n        40e18,     // L4: $40\r\n        80e18,     // L5: $80\r\n        160e18,    // L6: $160\r\n        320e18,    // L7: $320\r\n        640e18,    // L8: $640\r\n        1280e18,   // L9: $1,280\r\n        2560e18,   // L10: $2,560\r\n        5120e18,   // L11: $5,120\r\n        10240e18,  // L12: $10,240\r\n        20480e18   // L13: $20,480\r\n    ];\r\n    \r\n    // Team & income constants\r\n    uint public constant DIRECT_REQUIRED = 2;\r\n    uint public constant MAX_REFERRAL_LAYERS = 1;\r\n    \r\n    // Sponsor commission (13 levels, total 5%)\r\n    uint8 private constant SPONSOR_LEVELS = 13;\r\n    \r\n    function _getSponsorPercentage(uint8 level) private pure returns (uint16) {\r\n        if (level == 0) return 100;   // L1: 1%\r\n        if (level == 1) return 80;    // L2: 0.8%\r\n        if (level == 2) return 60;    // L3: 0.6%\r\n        if (level == 3) return 50;    // L4: 0.5%\r\n        if (level == 4) return 50;    // L5: 0.5%\r\n        if (level == 5) return 40;    // L6: 0.4%\r\n        if (level == 6) return 30;    // L7: 0.3%\r\n        if (level == 7) return 25;    // L8: 0.25%\r\n        if (level == 8) return 20;    // L9: 0.2%\r\n        if (level == 9) return 15;    // L10: 0.15%\r\n        if (level == 10) return 10;   // L11: 0.1%\r\n        if (level == 11) return 10;   // L12: 0.1%\r\n        if (level == 12) return 10;   // L13: 0.1%\r\n        return 0;\r\n    }\r\n    \r\n    // Sponsor qualification thresholds\r\n    uint8 private constant MIN_DIRECTS_L6_8 = 2;\r\n    uint8 private constant MIN_DIRECTS_L9_10 = 3;\r\n    uint8 private constant MIN_DIRECTS_L11_13 = 5;\r\n    \r\n    \r\n    // ============ STATE VARIABLES ============\r\n    \r\n    // Owner (can renounce)\r\n    address public owner;\r\n    \r\n    // Emergency controls\r\n    bool public paused;\r\n    \r\n    // Reentrancy guard (improved pattern)\r\n    uint256 private unlocked = 1;\r\n    \r\n    // User tracking\r\n    uint public totalUsers;\r\n    uint private userIdCounter;\r\n    \r\n    // ============ DATA STRUCTURES ============\r\n    \r\n    struct User {\r\n        bool exists;\r\n        address account;\r\n        uint referrer;\r\n        uint upline;\r\n        uint level;\r\n        uint directTeam;\r\n        uint team;\r\n        uint registrationTime;\r\n    }\r\n    \r\n    struct UserIncome {\r\n        uint totalDeposit;\r\n        uint totalIncome;\r\n        uint referralIncome;\r\n        uint sponsorIncome;\r\n        uint levelIncome;\r\n    }\r\n    \r\n    struct Activity {\r\n        uint id;\r\n        uint level;\r\n        uint time;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => uint) public id;\r\n    mapping(uint => User) public userInfo;\r\n    mapping(uint => UserIncome) public userIncome;\r\n    mapping(uint => mapping(uint => uint[])) public teams;\r\n    mapping(uint => uint) public matrixDirect;\r\n    mapping(uint => uint) public lostIncome;\r\n    mapping(uint => uint[]) private directReferrals;  // NEW: O(1) direct team lookup\r\n    \r\n    uint[] private globalUsers;  // Changed to private (use events instead)\r\n    Activity[] private activity;  // Changed to private (use events instead)\r\n    \r\n    // ============ EVENTS ============\r\n    \r\n    // User lifecycle\r\n    event UserRegistered(uint indexed userId, address indexed account, uint indexed referrer, uint timestamp);\r\n    event UserUpgraded(uint indexed userId, uint newLevel, uint amount, uint timestamp);\r\n    event RootUserCreated(uint indexed rootUserId, address indexed rootAddress, uint timestamp);\r\n    \r\n    // Payments & income\r\n    event AdminFeePaid(uint amount, uint level, uint timestamp);\r\n    event ReferralPayment(uint indexed referrerId, uint indexed userId, uint amount, uint timestamp);\r\n    event SponsorCommissionPaid(uint indexed sponsorId, uint indexed fromUserId, uint amount, uint level, uint timestamp);\r\n    event MatrixPayment(uint indexed fromUserId, uint indexed toUserId, uint amount, uint level, uint layer, bool qualified, uint timestamp);\r\n    event IncomeLost(uint indexed userId, uint indexed fromUser, uint amount, string reason, uint timestamp);\r\n    event RoyaltyPoolFunded(uint indexed userId, uint amount, uint timestamp);\r\n    event RoyaltyClaimed(uint indexed userId, uint indexed royaltyLevel, uint amount, uint timestamp);\r\n    \r\n    // Ownership & Emergency\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipRenounced(address indexed previousOwner, uint timestamp);\r\n    event LevelCostUpdated(uint8 indexed level, uint256 oldCost, uint256 newCost, uint timestamp);\r\n    event ContractPaused(address indexed by, uint timestamp);\r\n    event ContractUnpaused(address indexed by, uint timestamp);\r\n    event RootFallbackIncome(uint amount, string source, uint timestamp);\r\n    \r\n    // ============ MODIFIERS ============\r\n    \r\n    modifier nonReentrant() {\r\n        require(unlocked == 1, \"Reentrancy detected\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n    \r\n    modifier validUser(uint _userId) {\r\n        require(_userId > 0 && userInfo[_userId].exists, \"Invalid user ID\");\r\n        _;\r\n    }\r\n    \r\n    // ============ CONSTRUCTOR ============\r\n    \r\n    constructor(\r\n        address _feeReceiver,\r\n        address _royalty,\r\n        address _rootUserAddress,\r\n        uint _rootUserId,\r\n        address _usdtToken\r\n    ) {\r\n        require(_feeReceiver != address(0), \"Invalid fee receiver\");\r\n        require(_royalty != address(0), \"Invalid royalty\");\r\n        require(_rootUserAddress != address(0), \"Invalid root address\");\r\n        require(_rootUserId > 0, \"Invalid root user ID\");\r\n        require(_usdtToken != address(0), \"Invalid USDT\");\r\n        \r\n        // Set immutables\r\n        FEE_RECEIVER = _feeReceiver;\r\n        ROYALTY_ADDR = IRoyalty(_royalty);\r\n        DEFAULT_REFER = _rootUserId;\r\n        START_TIME = block.timestamp;\r\n        USDT = IERC20(_usdtToken);\r\n        \r\n        // Set owner\r\n        owner = msg.sender;\r\n        \r\n        // Initialize root user\r\n        userIdCounter = DEFAULT_REFER;\r\n        id[_rootUserAddress] = DEFAULT_REFER;\r\n        _createUser(DEFAULT_REFER, _rootUserAddress, DEFAULT_REFER, DEFAULT_REFER, 12);\r\n        globalUsers.push(DEFAULT_REFER);\r\n        totalUsers = 1;\r\n        // Root user already has level 13 from _createUser (12 + 1)\r\n        \r\n        // Register root to all royalty tiers\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 10, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 11, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 12, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 13, 0);\r\n        \r\n        emit RootUserCreated(DEFAULT_REFER, _rootUserAddress, block.timestamp);\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n    \r\n    // ============ LEVEL COST HELPER ============\r\n    \r\n    /**\r\n     * @dev Get level cost in USDT (uses adjustable levelCosts array)\r\n     * @param _level Level index (0-12 for L1-L13)\r\n     * @return USDT cost in wei (18 decimals)\r\n     */\r\n    function _getLevelCost(uint _level) private view returns (uint) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        return levelCosts[_level];\r\n    }\r\n    \r\n    // ============ USER-FACING FUNCTIONS ============\r\n    \r\n    /**\r\n        if (_level == 7) return 320e18;     // $320\r\n        if (_level == 8) return 640e18;     // $640\r\n        if (_level == 9) return 1320e18;    // $1,320\r\n        if (_level == 10) return 2740e18;   // $2,740\r\n        if (_level == 11) return 5480e18;   // $5,480\r\n        if (_level == 12) return 10960e18;  // $10,960\r\n        revert(\"Invalid level\");\r\n    }\r\n    \r\n    // ============ USER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Register new user with USDT payment\r\n     * @param _ref Referrer user ID (0 = default)\r\n     * @param _newAcc New user wallet address\r\n     */\r\n    function register(uint _ref, address _newAcc) external nonReentrant whenNotPaused {\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly registration using referrer address\r\n     */\r\n    function registerMe(address _referrerAddress) external nonReentrant whenNotPaused {\r\n        uint _ref = (_referrerAddress == address(0)) ? 0 : id[_referrerAddress];\r\n        address _newAcc = msg.sender;\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice Upgrade user to higher levels with USDT\r\n     */\r\n    function upgrade(uint _id, uint _lvls) external nonReentrant whenNotPaused validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        require(userInfo[_id].level + _lvls <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        \r\n        // Calculate total cost\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        // Transfer USDT from user\r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        // Process each level\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[_id].level++;\r\n            userIncome[_id].totalDeposit += levelCost;\r\n            \r\n            // Pay admin fee\r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[_id].level - 1, block.timestamp);\r\n            }\r\n            \r\n            // Fund royalty pool (5% of levelCost)\r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n                emit RoyaltyPoolFunded(_id, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            // Distribute payments\r\n            uint remaining = _processSponsorCommission(_id, levelCost);\r\n            _distributeMatrixIncome(_id, userInfo[_id].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            // Register for royalty\r\n            ROYALTY_ADDR.registerUser(_id, userInfo[_id].level, userInfo[_id].directTeam);\r\n            \r\n            emit UserUpgraded(_id, userInfo[_id].level, levelCost, block.timestamp);\r\n            activity.push(Activity(_id, userInfo[_id].level, block.timestamp));\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly upgrade for caller\r\n     */\r\n    function upgradeMe(uint _levels) external nonReentrant whenNotPaused {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        require(msg.sender == userInfo[myId].account, \"Unauthorized\");\r\n        require(userInfo[myId].level + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[myId].level++;\r\n            userIncome[myId].totalDeposit += levelCost;\r\n            \r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[myId].level - 1, block.timestamp);\r\n            }\r\n            \r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");emit RoyaltyPoolFunded(myId, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            uint remaining = _processSponsorCommission(myId, levelCost);\r\n            _distributeMatrixIncome(myId, userInfo[myId].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            ROYALTY_ADDR.registerUser(myId, userInfo[myId].level, userInfo[myId].directTeam);\r\n            \r\n            emit UserUpgraded(myId, userInfo[myId].level, levelCost, block.timestamp);\r\n            activity.push(Activity(myId, userInfo[myId].level, block.timestamp));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim royalty reward\r\n     */\r\n    function claimRoyalty(uint _id, uint _royaltyLvl) external nonReentrant validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            _id,\r\n            _royaltyLvl,\r\n            DEFAULT_REFER,\r\n            userIncome[_id].totalIncome,\r\n            userIncome[_id].totalDeposit,\r\n            userInfo[_id].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(_id, _royaltyLvl, amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly royalty claim\r\n     */\r\n    function claimMyRoyalty(uint _tier) external nonReentrant {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            myId,\r\n            _tier,\r\n            DEFAULT_REFER,\r\n            userIncome[myId].totalIncome,\r\n            userIncome[myId].totalDeposit,\r\n            userInfo[myId].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(myId, _tier, amount, block.timestamp);\r\n    }\r\n    \r\n    // ============ OWNER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Renounce ownership - makes contract fully autonomous\r\n     * @dev IRREVERSIBLE - contract becomes ownerless forever\r\n     */\r\n    function renounceOwnership() external onlyOwner {\r\n        emit OwnershipRenounced(owner, block.timestamp);\r\n        owner = address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfer ownership to new address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Update level cost (owner only, before renouncing)\r\n     * @dev Allows flexibility during initial phase, becomes immutable after renounce\r\n     */\r\n    function setLevelCost(uint8 _level, uint256 _newCost) external onlyOwner {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        require(_newCost > 0, \"Cost must be positive\");\r\n        require(_newCost >= 1e18, \"Minimum cost is 1 USDT\");\r\n        require(_newCost <= 100000e18, \"Maximum cost is 100,000 USDT\");\r\n        \r\n        // Ensure costs are ascending (level n+1 > level n)\r\n        if (_level > 0) {\r\n            require(_newCost > levelCosts[_level - 1], \"Cost must increase\");\r\n        }\r\n        if (_level < MAX_LEVELS - 1) {\r\n            require(_newCost < levelCosts[_level + 1] || levelCosts[_level + 1] == 0, \"Cost must be less than next level\");\r\n        }\r\n        \r\n        uint256 oldCost = levelCosts[_level];\r\n        levelCosts[_level] = _newCost;\r\n        \r\n        emit LevelCostUpdated(_level, oldCost, _newCost, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Pause contract in case of emergency\r\n     * @dev Only owner can pause, prevents all user operations\r\n     */\r\n    function pauseContract() external onlyOwner {\r\n        require(!paused, \"Already paused\");\r\n        paused = true;\r\n        emit ContractPaused(msg.sender, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Resume contract operations\r\n     */\r\n    function unpauseContract() external onlyOwner {\r\n        require(paused, \"Not paused\");\r\n        paused = false;\r\n        emit ContractUnpaused(msg.sender, block.timestamp);\r\n    }\r\n\r\n    \r\n    // ============ INTERNAL FUNCTIONS - PAYMENT DISTRIBUTION ============\r\n    \r\n    function _processRegistrationPayments(uint _newId, uint _levelCost, uint _adminFee) private {\r\n        // Pay admin fee (5%)\r\n        if (_adminFee > 0) {\r\n            require(USDT.transfer(FEE_RECEIVER, _adminFee), \"Admin fee failed\");\r\n            emit AdminFeePaid(_adminFee, 0, block.timestamp);\r\n        }\r\n        \r\n        // Fund royalty pool (5% of levelCost)\r\n        uint royaltyFundAmt = (_levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n        if (royaltyFundAmt > 0) {\r\n            require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n            emit RoyaltyPoolFunded(_newId, royaltyFundAmt, block.timestamp);\r\n        }\r\n        \r\n        // Referral income (95% = levelCost - royaltyFund)\r\n        uint _referrer = userInfo[_newId].referrer;\r\n        uint referralAmount = _levelCost - royaltyFundAmt;\r\n        \r\n        if (_referrer != 0 && userInfo[_referrer].exists) {\r\n            require(USDT.transfer(userInfo[_referrer].account, referralAmount), \"Referral failed\");\r\n            userIncome[_referrer].referralIncome += referralAmount;\r\n            userIncome[_referrer].totalIncome += referralAmount;\r\n            emit ReferralPayment(_referrer, _newId, referralAmount, block.timestamp);\r\n        } else {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, referralAmount), \"Default referral failed\");\r\n            userIncome[DEFAULT_REFER].referralIncome += referralAmount;\r\n            userIncome[DEFAULT_REFER].totalIncome += referralAmount;\r\n            emit ReferralPayment(DEFAULT_REFER, _newId, referralAmount, block.timestamp);\r\n        }\r\n        \r\n        // Note: For registration, income goes to Referrer, NOT matrix\r\n        // Matrix distribution only happens on upgrade\r\n    }\r\n\r\n    \r\n    function _processSponsorCommission(uint _id, uint _amount) private returns (uint) {\r\n        uint _referrer = userInfo[_id].referrer;\r\n        uint totalPaid = 0;\r\n        uint totalSponsorAllocation = (_amount * 500) / 10000;  // 5%\r\n        \r\n        // Distribute to up to 13 levels\r\n        for (uint8 level = 0; level < SPONSOR_LEVELS && _referrer != 0; level++) {\r\n            bool qualified = _isQualifiedForSponsorLevel(_referrer, level);\r\n            uint reward = (_amount * _getSponsorPercentage(level)) / 10000;\r\n            \r\n            if (qualified && reward > 0) {\r\n                bool success = USDT.transfer(userInfo[_referrer].account, reward);\r\n                if (success) {\r\n                    userIncome[_referrer].sponsorIncome += reward;\r\n                    userIncome[_referrer].totalIncome += reward;\r\n                    totalPaid += reward;\r\n                    \r\n                    emit SponsorCommissionPaid(_referrer, _id, reward, level + 1, block.timestamp);\r\n                }\r\n            } else if (reward > 0) {\r\n                // Track lost income only if upline exists\r\n                if (userInfo[_referrer].exists) {\r\n                    lostIncome[_referrer] += reward;\r\n                    \r\n                    string memory reason;\r\n                    if (level < 5) {\r\n                        reason = \"Not active (need Level 1+)\";\r\n                    } else if (level >= 5 && level < 8) {\r\n                        reason = \"Need 2+ direct referrals for L6-L8\";\r\n                    } else if (level >= 8 && level < 10) {\r\n                        reason = \"Need 3+ direct referrals for L9-L10\";\r\n                    } else {\r\n                        reason = \"Need 5+ direct referrals for L11-L13\";\r\n                    }\r\n                    \r\n                    emit IncomeLost(_referrer, _id,reward, reason, block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _referrer = userInfo[_referrer].referrer;\r\n        }\r\n        \r\n        // Fallback to root for unpaid commission\r\n        if (totalPaid < totalSponsorAllocation) {\r\n            uint unpaid = totalSponsorAllocation - totalPaid;\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, unpaid), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].sponsorIncome += unpaid;\r\n            userIncome[DEFAULT_REFER].totalIncome += unpaid;\r\n            emit RootFallbackIncome(unpaid, \"sponsor_commission\", block.timestamp);\r\n            totalPaid = totalSponsorAllocation;\r\n        }\r\n        \r\n        return _amount - totalPaid;  // Returns 95%\r\n    }\r\n    \r\n    \r\n    function _distributeMatrixIncome(uint _userId, uint _level, uint _amount, bool ignoreQualification) private {\r\n        uint _upline = userInfo[_userId].upline;\r\n        bool paid = false;\r\n        \r\n        // Search up to 13 levels for qualified upline\r\n        for (uint i = 0; i < MAX_INCOME_LAYER && _upline != 0; i++) {\r\n            bool qualified = ignoreQualification || \r\n                            (userInfo[_upline].level > _level && userInfo[_upline].directTeam >= DIRECT_REQUIRED);\r\n            \r\n            if (qualified) {\r\n                // Give FULL remaining amount (90%) to first qualified upline\r\n                bool success = USDT.transfer(userInfo[_upline].account, _amount);\r\n                if (success) {\r\n                    userIncome[_upline].levelIncome += _amount;\r\n                    userIncome[_upline].totalIncome += _amount;\r\n                    paid = true;\r\n                    \r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, true, block.timestamp);\r\n                }\r\n                break;  // Stop after first qualified upline gets paid\r\n            } else {\r\n                // Emit events for transparency, but DON'T track lostIncome\r\n                // (winner-takes-all model - only first qualified gets paid, so no real \"share\" lost)\r\n                if (userInfo[_upline].exists) {\r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, false, block.timestamp);\r\n                    emit IncomeLost(_upline, _userId, _amount, \"Not qualified for matrix\", block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _upline = userInfo[_upline].upline;\r\n        }\r\n        \r\n        // Fallback to root if no qualified upline found\r\n        if (!paid && _amount > 0) {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, _amount), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].levelIncome += _amount;\r\n            userIncome[DEFAULT_REFER].totalIncome += _amount;\r\n            emit RootFallbackIncome(_amount, \"matrix_income\", block.timestamp);\r\n        }\r\n    }\r\n\r\n    \r\n    function _isQualifiedForSponsorLevel(uint _userId, uint8 level) private view returns (bool) {\r\n        User storage user = userInfo[_userId];\r\n        \r\n        if (!user.exists || user.level < 1) return false;\r\n        \r\n        if (level < 5) {\r\n            return true;  // L1-L5: Just need Level 1+\r\n        } else if (level >= 5 && level < 8) {\r\n            return user.directTeam >= MIN_DIRECTS_L6_8;  // L6-L8: 2+ directs\r\n        } else if (level >= 8 && level < 10) {\r\n            return user.directTeam >= MIN_DIRECTS_L9_10;  // L9-L10: 3+ directs\r\n        } else {\r\n            return user.directTeam >= MIN_DIRECTS_L11_13;  // L11-L13: 5+ directs\r\n        }\r\n    }\r\n    \r\n    // ============ INTERNAL FUNCTIONS - USER & MATRIX ============\r\n    \r\n    function _createUser(uint _userId, address _account, uint _referrer, uint _upline, uint _level) private {\r\n        userInfo[_userId] = User({\r\n            exists: true,\r\n            account: _account,\r\n            referrer: _referrer,\r\n            upline: _upline,\r\n            level: _level + 1,\r\n            directTeam: 0,\r\n            team: 0,\r\n            registrationTime: block.timestamp\r\n        });\r\n        \r\n        userIncome[_userId] = UserIncome({\r\n            totalDeposit: 0,\r\n            totalIncome: 0,\r\n            referralIncome: 0,\r\n            sponsorIncome: 0,\r\n            levelIncome: 0\r\n        });\r\n        \r\n        if (_referrer != 0 && _referrer != _userId) {\r\n            userInfo[_referrer].directTeam++;\r\n            directReferrals[_referrer].push(_userId);  // Store in mapping for O(1) lookup\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Place new user in binary matrix using breadth-first search\r\n     * @param _newId ID of new user to place\r\n     * @param _ref Starting point (usually referrer)\r\n     * \r\n     * Searches for available spot (max 2 children per node) within MAX_PLACEMENT_DEPTH.\r\n     * If no spot found within depth limit, falls back to placing under root.\r\n     * This prevents infinite loops but may cluster users in very deep trees.\r\n     */\r\n    function _placeInBinaryMatrix(uint _newId, uint _ref) private {\r\n        uint[] memory queue = new uint[](MAX_PLACEMENT_DEPTH);\r\n        uint front = 0;\r\n        uint back = 0;\r\n        queue[back++] = _ref;\r\n        \r\n        bool placed = false;\r\n        uint iterations = 0;\r\n        \r\n        while (front < back && iterations < MAX_PLACEMENT_DEPTH) {\r\n            uint _upline = queue[front++];\r\n            iterations++;\r\n            \r\n            if (teams[_upline][0].length < 2) {\r\n                teams[_upline][0].push(_newId);\r\n                userInfo[_newId].upline = _upline;\r\n                matrixDirect[_upline]++;\r\n                placed = true;\r\n                break;\r\n            }\r\n            \r\n            for (uint i = 0; i < teams[_upline][0].length && back < MAX_PLACEMENT_DEPTH; i++) {\r\n                queue[back++] = teams[_upline][0][i];\r\n            }\r\n        }\r\n        \r\n        // Fallback to referrer if no spot found within depth limit\r\n        if (!placed) {\r\n            teams[_ref][0].push(_newId);\r\n            userInfo[_newId].upline = _ref;\r\n            matrixDirect[_ref]++;\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Update team counts - FIXED: Only increment once per new user\r\n     * Previously this was over-counting by incrementing multiple times\r\n     */\r\n    function _updateTeamCounts(uint _userId) private {\r\n        uint _upline = userInfo[_userId].referrer;\r\n        uint depth = 0;\r\n        \r\n        // Walk up referral chain and increment team count for each upline\r\n        // Each new user adds +1 to all uplines' team counts\r\n        while (_upline != 0 && depth < MAX_PLACEMENT_DEPTH) {\r\n            userInfo[_upline].team++;\r\n            _upline = userInfo[_upline].referrer;\r\n            depth++;\r\n        }\r\n    }\r\n    \r\n    // ============ VIEW FUNCTIONS ============\r\n    \r\n    function isAutonomous() external view returns (bool) {\r\n        return owner == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get user account address by ID (used by Royalty contract)\r\n     */\r\n    function getUserAccount(uint _userId) external view returns (address) {\r\n        return userInfo[_userId].account;\r\n    }\r\n    \r\n    function getLevelCost(uint _level) external view returns (uint cost, uint adminFee, uint total) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        cost = _getLevelCost(_level);\r\n        adminFee = (cost * ADMIN_FEE_PERCENT) / 100;\r\n        total = cost + adminFee;\r\n    }\r\n    \r\n    function getAllLevelCosts() external view returns (\r\n        uint[13] memory costs,\r\n        uint[13] memory fees,\r\n        uint[13] memory totals\r\n    ) {\r\n        for (uint i = 0; i < 13; i++) {\r\n            costs[i] = _getLevelCost(i);\r\n            fees[i] = (costs[i] * ADMIN_FEE_PERCENT) / 100;\r\n            totals[i] = costs[i] + fees[i];\r\n        }\r\n    }\r\n    \r\n    function getRegistrationCost() external view returns (uint cost, uint levelCost, uint adminFee) {\r\n        levelCost = _getLevelCost(0);\r\n        adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        cost = levelCost + adminFee;\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for caller (for dApp use)\r\n     * @dev This version uses msg.sender - DOES NOT WORK on BSCScan Read Contract!\r\n     *      Use getUpgradeCostFor() on BSCScan instead\r\n     */\r\n    function getUpgradeCost(uint _levels) external view returns (uint totalCost, uint[] memory breakdown) {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[myId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);  // FIX: targetLevel is 1-13, need index 0-12\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Get upgrade cost for specific user (BSCScan-friendly!)\r\n     * @param _userAddress Address of the user to check\r\n     * @param _levels Number of levels to upgrade\r\n     * @return totalCost Total USDT cost (including admin fee)\r\n     * @return breakdown Cost breakdown per level\r\n     */\r\n    function getUpgradeCostFor(address _userAddress, uint _levels) \r\n        external view returns (uint totalCost, uint[] memory breakdown) \r\n    {\r\n        uint userId = id[_userAddress];\r\n        require(userId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[userId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    function getMyInfo() external view returns (\r\n        uint userId,\r\n        uint level,\r\n        uint team,\r\n        uint directTeam,\r\n        uint totalIncome,\r\n        uint referrerId,\r\n        uint uplineId,\r\n        uint registrationTime\r\n    ) {\r\n        userId = id[msg.sender];\r\n        if (userId == 0) return (0, 0, 0, 0, 0, 0, 0, 0);\r\n        \r\n        User storage user = userInfo[userId];\r\n        UserIncome storage income = userIncome[userId];\r\n        \r\n        return (\r\n            userId,\r\n            user.level,\r\n            user.team,\r\n            user.directTeam,\r\n            income.totalIncome,\r\n            user.referrer,\r\n            user.upline,\r\n            user.registrationTime\r\n        );\r\n    }\r\n    \r\n    function getMyIncomeBreakdown() external view returns (\r\n        uint totalDeposit,\r\n        uint totalIncome,\r\n        uint referralIncome,\r\n        uint sponsorIncome,\r\n        uint levelIncome,\r\n        uint lostAmount\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, 0, 0, 0, 0);\r\n        \r\n        UserIncome storage income = userIncome[myId];\r\n        return (\r\n            income.totalDeposit,\r\n            income.totalIncome,\r\n            income.referralIncome,\r\n            income.sponsorIncome,\r\n            income.levelIncome,\r\n            lostIncome[myId]\r\n        );\r\n    }\r\n    \r\n    function getMyTeam() external view returns (\r\n        uint teamSize,\r\n        uint directCount,\r\n        uint[] memory directReferralIds,\r\n        address[] memory directReferralAddresses\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, new uint[](0), new address[](0));\r\n        \r\n        User storage user = userInfo[myId];\r\n        teamSize = user.team;\r\n        directCount = user.directTeam;\r\n        \r\n        // Use mapping for O(1) lookup instead of O(N) loop\r\n        directReferralIds = directReferrals[myId];\r\n        \r\n        // Build addresses array\r\n        directReferralAddresses = new address[](directReferralIds.length);\r\n        for (uint i = 0; i < directReferralIds.length; i++) {\r\n            directReferralAddresses[i] = userInfo[directReferralIds[i]].account;\r\n        }\r\n    }\r\n    \r\n    function getMyRoyaltyStatus() external view returns (\r\n        uint[4] memory claimableAmounts,\r\n        bool[4] memory isEligible,\r\n        bool[4] memory hasClaimed\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (claimableAmounts, isEligible, hasClaimed);\r\n        \r\n        for (uint i = 0; i < 4; i++) {\r\n            (claimableAmounts[i], isEligible[i], hasClaimed[i]) = ROYALTY_ADDR.getUserRoyaltyData(myId, i);\r\n        }\r\n    }\r\n    \r\n    function isRegistered(address _address) external view returns (bool) {\r\n        return id[_address] > 0;\r\n    }\r\n    \r\n    function getContractBalance() external view returns (uint) {\r\n        return USDT.balanceOf(address(this));\r\n    }\r\n}\r\n"
    },
    "contracts/FiveDollarRideRoyalty_BNB.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title FiveDollarRideRoyalty_BNB - Native BNB Royalty Pool\r\n * @notice Royalty distribution system for FiveDollarRide_BNB platform\r\n * @dev Accepts native BNB and distributes to eligible users\r\n * \r\n * Features:\r\n * - Native BNB payments (no token approval)\r\n * - 4 royalty tiers (L10, L11, L12, L13)\r\n * - Automatic distribution rounds\r\n * - Eligible user tracking\r\n * - Multiple claim support\r\n */\r\n\r\ncontract FiveDollarRideRoyalty_BNB {\r\n    // ============ IMMUTABLES ============\r\n    \r\n    address public immutable OWNER;\r\n    address public immutable DEFAULT_REFER_ADDRESS;\r\n    address public MAIN_CONTRACT; // Can be set after deployment\r\n    \r\n    // ============ CONSTANTS ============\r\n    \r\n    uint[4] public ROYALTY_LEVELS = [10, 11, 12, 13];\r\n    uint public constant MIN_CLAIM = 0.001 ether; // Minimum claim threshold (~$0.90)\r\n    \r\n    // ============ STATE VARIABLES ============\r\n    \r\n    // Tier => User ID => Registration Data\r\n    mapping(uint => mapping(uint => UserRoyalty)) public userRoyalties;\r\n    \r\n    // Tier => Distribution Round => User IDs\r\n    mapping(uint => mapping(uint => uint[])) public distributionQueue;\r\n    \r\n    // Tier => Statistics\r\n    mapping(uint => TierStats) public tierStats;\r\n    \r\n    // Tier => BNB Pool Balance\r\n    mapping(uint => uint) public poolBalance;\r\n    \r\n    // NEW: Tier => Round => BNB Amount for that round\r\n    mapping(uint => mapping(uint => uint)) public roundPoolAmount;\r\n    \r\n    struct UserRoyalty {\r\n        bool registered;\r\n        uint registrationRound;\r\n        uint lastClaimRound;\r\n        uint totalClaimed;\r\n        uint directReferrals;\r\n    }\r\n    \r\n    struct TierStats {\r\n        uint totalUsers;\r\n        uint currentRound;\r\n        uint pendingUsers;\r\n        uint totalDistributed;\r\n        uint lastRoundTime;  // NEW: Track last round advancement\r\n    }\r\n    \r\n    uint public constant ROUND_DURATION = 24 hours;  // NEW: 24-hour rounds\r\n    \r\n    // ============ EVENTS ============\r\n    \r\n    event UserRegistered(uint indexed userId, uint indexed tier, uint round, uint timestamp);\r\n    event RoyaltyDistributed(uint indexed userId, uint indexed tier, uint bnbAmount, uint round, uint timestamp);\r\n    event PoolFunded(uint indexed tier, uint bnbAmount, uint timestamp);\r\n    event RoundAdvanced(uint indexed tier, uint newRound, uint timestamp);\r\n    \r\n    // ============ MODIFIERS ============\r\n    \r\n    modifier onlyMainContract() {\r\n        require(msg.sender == MAIN_CONTRACT, \"Only main contract\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == OWNER, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier validTier(uint _tier) {\r\n        require(_tier >= 10 && _tier <= 13, \"Invalid tier\");\r\n        _;\r\n    }\r\n    \r\n    // ============ CONSTRUCTOR ============\r\n    \r\n    constructor(\r\n        address _owner,\r\n        address _defaultRefer,\r\n        address _mainContract\r\n    ) {\r\n        require(_owner != address(0), \"Invalid owner\");\r\n        require(_defaultRefer != address(0), \"Invalid default refer\");\r\n        // Allow zero address for _mainContract during deployment\r\n        \r\n        OWNER = _owner;\r\n        DEFAULT_REFER_ADDRESS = _defaultRefer;\r\n        MAIN_CONTRACT = _mainContract;\r\n        \r\n        // Initialize tier stats with time-based rounds\r\n        for (uint i = 0; i < 4; i++) {\r\n            tierStats[ROYALTY_LEVELS[i]].currentRound = 1;\r\n            tierStats[ROYALTY_LEVELS[i]].lastRoundTime = block.timestamp;\r\n        }\r\n    }\r\n    \r\n    // ============ MAIN CONTRACT FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Register user for royalty tier\r\n     * @dev Called by main contract when user reaches required level\r\n     */\r\n    function registerUser(\r\n        uint _userId,\r\n        uint _level,\r\n        uint _directCount\r\n    ) external onlyMainContract {\r\n        // Register users for tiers they qualify for\r\n        for (uint i = 0; i < 4; i++) {\r\n            uint tier = ROYALTY_LEVELS[i];\r\n            \r\n            if (_level >= tier && !userRoyalties[tier][_userId].registered) {\r\n                // Advance round if 24h passed before registering\r\n                _checkAndAdvanceRound(tier);\r\n                \r\n                TierStats storage stats = tierStats[tier];\r\n                \r\n                userRoyalties[tier][_userId] = UserRoyalty({\r\n                    registered: true,\r\n                    registrationRound: stats.currentRound,\r\n                    lastClaimRound: 0,\r\n                    totalClaimed: 0,\r\n                    directReferrals: _directCount\r\n                });\r\n                \r\n                distributionQueue[tier][stats.currentRound].push(_userId);\r\n                stats.totalUsers++;\r\n                stats.pendingUsers++;\r\n                \r\n                emit UserRegistered(_userId, tier, stats.currentRound, block.timestamp);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim royalty for a specific tier\r\n     * @dev Called by main contract via user request\r\n     */\r\n    function claimRoyalty(\r\n        uint _userId,\r\n        uint _tier,\r\n        uint, // _rootUserId - unused\r\n        uint, // _userTotalIncome - unused  \r\n        uint, // _userTotalDeposit - unused\r\n        address _userAccount\r\n    ) external onlyMainContract validTier(_tier) returns (uint) {\r\n        UserRoyalty storage user = userRoyalties[_tier][_userId];\r\n        require(user.registered, \"Not registered\");\r\n        \r\n        // Advance round if 24 hours passed\r\n        _checkAndAdvanceRound(_tier);\r\n        \r\n        TierStats storage stats = tierStats[_tier];\r\n        require(user.lastClaimRound < stats.currentRound, \"Already claimed\");\r\n        \r\n        // Calculate total claimable\r\n        uint totalClaimable = _calculateClaimable(_tier, _userId);\r\n        \r\n        // Minimum claim threshold  \r\n        if (totalClaimable < MIN_CLAIM) {\r\n            return 0; // Roll over to next claim\r\n        }\r\n        \r\n        if (totalClaimable > 0) {\r\n            require(poolBalance[_tier] >= totalClaimable, \"Insufficient balance\");\r\n            \r\n            poolBalance[_tier] -= totalClaimable;\r\n            user.lastClaimRound = stats.currentRound - 1;\r\n            user.totalClaimed += totalClaimable;\r\n            stats.totalDistributed += totalClaimable;\r\n            \r\n            (bool success, ) = payable(_userAccount).call{value: totalClaimable}(\"\");\r\n            require(success, \"Transfer failed\");\r\n            \r\n            emit RoyaltyDistributed(_userId, _tier, totalClaimable, stats.currentRound, block.timestamp);\r\n        }\r\n        \r\n        return totalClaimable;\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculate claimable amount for a user (helper to avoid stack too deep)\r\n     */\r\n    function _calculateClaimable(uint _tier, uint _userId) private view returns (uint) {\r\n        UserRoyalty storage user = userRoyalties[_tier][_userId];\r\n        TierStats storage stats = tierStats[_tier];\r\n        \r\n        uint startRound = user.lastClaimRound == 0 ? user.registrationRound : user.lastClaimRound;\r\n        uint claimableRounds = stats.currentRound - startRound;\r\n        uint total = 0;\r\n        \r\n        for (uint i = 0; i < claimableRounds && i < 10; i++) {\r\n            uint round = startRound + i + 1;\r\n            uint users = distributionQueue[_tier][round].length;\r\n            uint pool = roundPoolAmount[_tier][round];\r\n            \r\n            if (users > 0 && pool > 0) {\r\n                uint share = pool / users;\r\n                if (share > 0) total += share;\r\n            }\r\n        }\r\n        \r\n        return total;\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if round should advance based on pending users\r\n     */\r\n    function _checkAndAdvanceRound(uint _tier) private {\r\n        TierStats storage stats = tierStats[_tier];\r\n        \r\n        // CHANGED: Advance round based on 24-hour time intervals\r\n        if (block.timestamp >= stats.lastRoundTime + ROUND_DURATION) {\r\n            stats.currentRound++;\r\n            stats.lastRoundTime = block.timestamp;\r\n            stats.pendingUsers = 0;\r\n            emit RoundAdvanced(_tier, stats.currentRound, block.timestamp);\r\n        }\r\n    }\r\n    \r\n    // ============ VIEW FUNCTIONS ============\r\n    \r\n    function getUserRoyaltyData(\r\n        uint _userId,\r\n        uint _tier\r\n    ) external view validTier(_tier) returns (\r\n        uint claimableAmount,\r\n        bool isEligible,\r\n        bool hasClaimed\r\n    ) {\r\n        UserRoyalty storage user = userRoyalties[_tier][_userId];\r\n        isEligible = user.registered;\r\n        hasClaimed = user.lastClaimRound >= tierStats[_tier].currentRound - 1;\r\n        \r\n        if (isEligible && !hasClaimed) {\r\n            TierStats storage stats = tierStats[_tier];\r\n            uint claimableRounds = stats.currentRound - user.lastClaimRound;\r\n            if (user.lastClaimRound == 0) {\r\n                claimableRounds = stats.currentRound - user.registrationRound;\r\n            }\r\n            \r\n            for (uint i = 0; i < claimableRounds; i++) {\r\n                uint round = user.lastClaimRound + i + 1;\r\n                uint usersInRound = distributionQueue[_tier][round].length;\r\n                \r\n                uint poolForRound = roundPoolAmount[_tier][round];\r\n                if (usersInRound > 0 && poolForRound > 0) {\r\n                    uint userShare = poolForRound / usersInRound;\r\n                    claimableAmount += userShare;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    \r\n    function getRoyaltyLevels() external view returns (uint[4] memory) {\r\n        return ROYALTY_LEVELS;\r\n    }\r\n    \r\n    function getTierStats(uint _tier) external view validTier(_tier) returns (\r\n        uint userCount,\r\n        uint distributionRound,\r\n        uint pendingUserCount\r\n    ) {\r\n        TierStats storage stats = tierStats[_tier];\r\n        return (stats.totalUsers, stats.currentRound, stats.pendingUsers);\r\n    }\r\n    \r\n    function getPoolBalance(uint _tier) external view validTier(_tier) returns (uint) {\r\n        return poolBalance[_tier];\r\n    }\r\n    \r\n    function getTotalPoolBalance() external view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    // ============ OWNER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Manual round advancement (emergency use)\r\n     */\r\n    function advanceRound(uint _tier) external onlyOwner validTier(_tier) {\r\n        TierStats storage stats = tierStats[_tier];\r\n        stats.currentRound++;\r\n        stats.pendingUsers = 0;\r\n        emit RoundAdvanced(_tier, stats.currentRound, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Set main contract address (only once)\r\n     */\r\n    function setMainContract(address _mainContract) external onlyOwner {\r\n        require(_mainContract != address(0), \"Invalid address\");\r\n        require(MAIN_CONTRACT == address(0), \"Already set\");\r\n        MAIN_CONTRACT = _mainContract;\r\n    }\r\n    \r\n    /**\r\n     * @notice Emergency withdraw (only to owner)\r\n     */\r\n    function emergencyWithdraw() external onlyOwner {\r\n        uint balance = address(this).balance;\r\n        require(balance > 0, \"No balance\");\r\n        (bool success, ) = payable(OWNER).call{value: balance}(\"\");\r\n        require(success, \"Withdraw failed\");\r\n    }\r\n    \r\n    // ============ RECEIVE FUNCTION ============\r\n    \r\n    /**\r\n     * @notice Accept BNB deposits - distribute to tier pools equally\r\n     */\r\n    receive() external payable {\r\n        require(msg.value > 0, \"No BNB sent\");\r\n        \r\n        // Distribute equally across all 4 tiers\r\n        uint perTier = msg.value / 4;\r\n        \r\n        for (uint i = 0; i < 4; i++) {\r\n            uint tier = ROYALTY_LEVELS[i];\r\n            poolBalance[tier] += perTier;\r\n            \r\n            // FIXED: Track per-round pool amounts\r\n            uint currentRound = tierStats[tier].currentRound;\r\n            roundPoolAmount[tier][currentRound] += perTier;\r\n            \r\n            emit PoolFunded(tier, perTier, block.timestamp);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Fallback function\r\n     */\r\n    fallback() external payable {\r\n        revert(\"Use receive() function\");\r\n    }\r\n}\r\n"
    },
    "contracts/FiveDollarRideRoyalty.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title FiveDollarRide Royalty System\r\n * @notice Passive income distribution for FiveDollarRide platform members\r\n * @dev Tier-based dividend system with 150% income cap per user\r\n * \r\n * Brand: FiveDollarRide Royalty - Earn While You Sleep\r\n */\r\n\r\n// USDT Token Interface (ERC20)\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n// Interface to query FiveDollarRide main contract for user data\r\ninterface IFiveDollarRide {\r\n    function getUserAccount(uint userId) external view returns (address);\r\n}\r\n\r\ncontract FiveDollarRideRoyalty {\r\n    \r\n    // ==================== IMMUTABLES ====================\r\n    \r\n    IERC20 public immutable USDT;\r\n    \r\n    // ==================== STATE VARIABLES ====================\r\n    \r\n    // Reentrancy guard (improved pattern)\r\n    uint256 private unlocked = 1;\r\n    address public owner;\r\n    address public fiveDollarRideContract;\r\n    uint public immutable startTime;\r\n    uint private immutable rootUserId;\r\n    \r\n    // Royalty system constants\r\n    uint public constant royaltyDistTime = 1 days;\r\n    uint public constant royaltyMaxPercent = 150;  // 150% cap on total income\r\n    \r\n    // Royalty tier percentages (immutable)\r\n    uint[4] public royaltyPercent = [40, 30, 20, 10];  // Tier 0-3 pool distribution\r\n    \r\n    // Royalty tier requirements (adjustable by owner, immutable after renounce)\r\n    uint[4] public royaltyLevels = [10, 11, 12, 13];  // Required levels for each tier\r\n    uint[4] public royaltyDirects = [0, 0, 0, 0];     // Required direct referrals for each tier required\r\n    \r\n    // Royalty tracking\r\n    struct RoyaltyData {\r\n        uint userCount;\r\n        uint index;\r\n        uint distributionRound;\r\n        uint dividendPerShare; // Accumulated dividend per share (scaled by 1e18)\r\n    }\r\n    \r\n    mapping(uint => RoyaltyData) public royaltyData;  // Tier index -> RoyaltyData\r\n    mapping(uint => mapping(uint => uint[])) private pendingRoyaltyUsers; // Pending list\r\n    mapping(uint => mapping(uint => bool)) public royaltyActive;    // Active status\r\n    mapping(uint => mapping(uint => uint)) private lastRoyaltyTime; // Claim timestamps\r\n    mapping(uint => mapping(uint => uint)) private lastClaimedDividend; // Track last claimed dividend per share\r\n    \r\n    mapping(uint => uint) private lastDistributedBalance;  // Track last balance PER TIER to calculate new funds only\r\n    \r\n    // Separate tracking for royalty income only (for 150% cap)\r\n    mapping(uint => uint) public royaltyIncome;  // userId -> total royalty income claimed\r\n    \r\n    // ==================== EVENTS ====================\r\n    \r\n    event RoyaltyDistributed(uint indexed tier, uint amount, uint userCount, uint timestamp);\r\n    event RoyaltyClaimed(uint indexed userId, uint indexed tier, uint amount, uint timestamp);\r\n    event UserRegistered(uint indexed userId, uint indexed tier, uint timestamp);\r\n    event RoyaltyConfigUpdated(string configType, uint timestamp);\r\n    event RoyaltyRequirementsUpdated(uint indexed tier, uint newLevel, uint newDirects, uint timestamp);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event FiveDollarRideContractSet(address indexed fiveDollarRideContract, uint timestamp);\r\n    \r\n    // ==================== MODIFIERS ====================\r\n    \r\n    modifier nonReentrant() {\r\n        require(unlocked == 1, \"Reentrancy detected\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyFiveDollarRide() {\r\n        require(msg.sender == fiveDollarRideContract, \"Only FiveDollarRide contract\");\r\n        _;\r\n    }\r\n    \r\n    // ==================== CONSTRUCTOR ====================\r\n    \r\n    constructor(address _owner, uint _defaultRefer, address _usdtToken) {\r\n        require(_owner != address(0), \"Invalid owner\");\r\n        require(_usdtToken != address(0), \"Invalid USDT\");\r\n        \r\n        owner = _owner;\r\n        rootUserId = _defaultRefer;  // Store as immutable\r\n        startTime = block.timestamp;\r\n        USDT = IERC20(_usdtToken);\r\n    }\r\n    \r\n    // ==================== ADMIN FUNCTIONS ====================\r\n    \r\n    /**\r\n     * @dev Set FiveDollarRide contract address (one-time setup)\r\n     */\r\n    function setFiveDollarRideContract(address _fiveDollarRideContract) external onlyOwner {\r\n        require(fiveDollarRideContract == address(0), \"Already set\");\r\n        require(_fiveDollarRideContract != address(0), \"Invalid address\");\r\n        fiveDollarRideContract = _fiveDollarRideContract;\r\n        emit FiveDollarRideContractSet(_fiveDollarRideContract, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Set royalty distribution percentages\r\n     */\r\n    function setRoyaltyPercents(uint[4] memory _newPercents) external {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        require(_newPercents[0] + _newPercents[1] + _newPercents[2] + _newPercents[3] == 100, \"Must total 100%\");\r\n        royaltyPercent = _newPercents;\r\n        emit RoyaltyConfigUpdated(\"percentages\", block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Update royalty tier requirements (owner only, before renouncing)\r\n     * @dev Allows flexibility during initial phase, becomes immutable after renounce\r\n     */\r\n    function setRoyaltyRequirements(uint _tier, uint _requiredLevel, uint _requiredDirects) external {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        require(_tier < 4, \"Invalid tier\");\r\n        require(_requiredLevel >= 1 && _requiredLevel <= 13, \"Level must be 1-13\");\r\n        require(_requiredDirects <= 100, \"Max 100 directs\");\r\n        \r\n        royaltyLevels[_tier] = _requiredLevel;\r\n        royaltyDirects[_tier] = _requiredDirects;\r\n        \r\n        emit RoyaltyRequirementsUpdated(_tier, _requiredLevel, _requiredDirects, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Set royalty tier levels (deprecated - use setRoyaltyRequirements)\r\n     */\r\n    function setRoyaltyLevels(uint[4] memory _levels) external onlyOwner {\r\n        for(uint i=0; i<4; i++) {\r\n            require(_levels[i] >= 1 && _levels[i] <= 13, \"Invalid level\");\r\n        }\r\n        royaltyLevels = _levels;\r\n        emit RoyaltyConfigUpdated(\"levels\", block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Set direct referral requirements (deprecated - use setRoyaltyRequirements)\r\n     */\r\n    function setRoyaltyDirectRequired(uint[4] memory _required) external onlyOwner {\r\n        for(uint i=0; i<4; i++) {\r\n            require(_required[i] > 0 && _required[i] <= 100, \"Invalid requirement\");\r\n            // Ensure ascending order - higher tiers need more or equal direct referrals\r\n            if(i > 0) require(_required[i] >= _required[i-1], \"Must be ascending\");\r\n        }\r\n        royaltyDirects = _required;\r\n        emit RoyaltyConfigUpdated(\"directRequired\", block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Transfer ownership\r\n     */\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"Invalid address\");\r\n        address previousOwner = owner;\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n    \r\n    // ==================== CORE ROYALTY FUNCTIONS ====================\r\n    \r\n    /**\r\n     * @dev Register user for royalty tier (called by FiveDollarRide on upgrade)\r\n     */\r\n    function registerUser(uint _userId, uint _level, uint _directCount) external nonReentrant {\r\n        \r\n        // Allow calls from FiveDollarRide contract OR during initial setup (before FiveDollarRide is connected)\r\n        require(msg.sender == fiveDollarRideContract || fiveDollarRideContract == address(0), \"Only FiveDollarRide contract\");\r\n        \r\n        bool isRootUser = (_userId == rootUserId);\r\n        \r\n        // For normal users (not root): auto-claim and deactivate all previous tiers\r\n        if (!isRootUser) {\r\n            for(uint i = 0; i < 4; i++) {\r\n                if (royaltyActive[_userId][i]) {\r\n                    // AUTO-CLAIM: Try to transfer unclaimed dividends (non-blocking)\r\n                    uint totalDividendPerShare = royaltyData[i].dividendPerShare;\r\n                    uint userLastClaimed = lastClaimedDividend[_userId][i];\r\n                    \r\n                    if (totalDividendPerShare > userLastClaimed) {\r\n                        uint unclaimedDividend = totalDividendPerShare - userLastClaimed;\r\n                        uint claimAmount = unclaimedDividend / 1e18;\r\n                        \r\n                        if (claimAmount > 0) {\r\n                            // Try to transfer (best effort, non-blocking)\r\n                            address userAccount = IFiveDollarRide(fiveDollarRideContract).getUserAccount(_userId);\r\n                            bool success = USDT.transfer(userAccount, claimAmount);\r\n                            \r\n                            // Only update tracking if transfer successful\r\n                            if (success) {\r\n                                lastClaimedDividend[_userId][i] = totalDividendPerShare;\r\n                                royaltyIncome[_userId] += claimAmount;\r\n                                emit RoyaltyClaimed(_userId, i, claimAmount, block.timestamp);\r\n                            }\r\n                            // If failed: Share preserved, user can claim from old tier later\r\n                        }\r\n                    }\r\n                    \r\n                    // Deactivate tier\r\n                    royaltyActive[_userId][i] = false;\r\n                    royaltyData[i].userCount--;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Register to new tier\r\n        for(uint i = 0; i < 4; i++) {\r\n            bool meetsRequirement = isRootUser || (_directCount >= royaltyDirects[i]);\r\n            \r\n            if(royaltyLevels[i] == _level && meetsRequirement) {\r\n                // Skip if already active (for root user)\r\n                if (!royaltyActive[_userId][i]) {\r\n                    pendingRoyaltyUsers[i][0].push(_userId);\r\n                    royaltyActive[_userId][i] = true;\r\n                    emit UserRegistered(_userId, i, block.timestamp);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Distribute royalty pool to eligible users (NEW MODEL: Dividend-Per-Share)\r\n     * This increases accumulated dividends for ALL active users, not just new ones\r\n     */\r\n    function distRoyalty(uint _tier) external {\r\n        require(_tier < 4, \"Invalid tier\");\r\n        require((block.timestamp - startTime) / royaltyDistTime > royaltyData[_tier].distributionRound, \"Not yet\");\r\n        \r\n        // Get NEW funds only (not entire balance) - PER TIER\r\n        uint currentBalance = USDT.balanceOf(address(this));\r\n        uint newFunds = currentBalance > lastDistributedBalance[_tier] \r\n            ? currentBalance - lastDistributedBalance[_tier] \r\n            : 0;\r\n        \r\n        uint _amt = (newFunds * royaltyPercent[_tier]) / 100;\r\n        \r\n        require(_amt > 0, \"No new funds to distribute\");\r\n        \r\n        // Update tracked balance for THIS tier after calculating tier share\r\n        lastDistributedBalance[_tier] += _amt;\r\n        \r\n        // Process pending users first (add them to active pool for THIS tier)\r\n        uint currentIndex = royaltyData[_tier].index;\r\n        \r\n        for(uint i = currentIndex; i < pendingRoyaltyUsers[_tier][0].length; i++) {\r\n            uint _user = pendingRoyaltyUsers[_tier][0][i];\r\n            royaltyActive[_user][_tier] = true;\r\n            royaltyData[_tier].userCount++;\r\n            royaltyData[_tier].index++;\r\n        }\r\n        \r\n        uint totalActiveUsers = royaltyData[_tier].userCount;\r\n        require(totalActiveUsers > 0, \"No active users\");\r\n        \r\n        // Calculate dividend per share (scaled by 1e18 for precision)\r\n        uint dividendIncrease = (_amt * 1e18) / totalActiveUsers;\r\n        royaltyData[_tier].dividendPerShare += dividendIncrease;\r\n        \r\n        royaltyData[_tier].distributionRound++;\r\n        emit RoyaltyDistributed(_tier, _amt, totalActiveUsers, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev User claims their ACCUMULATED royalty (NEW MODEL: Pull Pattern)\r\n     */\r\n    function claimRoyalty(\r\n        uint _id, \r\n        uint _tier,\r\n        uint rootUserId,\r\n        uint userTotalIncome,\r\n        uint userTotalDeposit,\r\n        address userAccount\r\n    ) external nonReentrant returns (uint) {\r\n        require(msg.sender == userAccount || msg.sender == fiveDollarRideContract, \"Unauthorized\");\r\n        require(_tier < 4, \"Invalid tier\");\r\n        \r\n        // Allow claiming from ANY tier where user has unclaimed dividends\r\n        // No longer requires active status - user can claim old tier dividends\r\n        \r\n        // Prevent claiming if no new dividends available\r\n        uint totalDividendPerShare = royaltyData[_tier].dividendPerShare;\r\n        uint userLastClaimed = lastClaimedDividend[_id][_tier];\r\n        require(userLastClaimed < totalDividendPerShare, \"No new dividends\");\r\n        \r\n        // Root user special privilege: no income cap\r\n        bool isRoot = _id == rootUserId;\r\n        \r\n        // CAP CHECK: 150% applies ONLY to royalty income, not other income!\r\n        if(!isRoot) {\r\n            uint maxRoyaltyIncome = (userTotalDeposit * royaltyMaxPercent) / 100;\r\n            require(royaltyIncome[_id] < maxRoyaltyIncome, \"Royalty cap reached\");\r\n        }\r\n        \r\n        // Calculate accumulated dividends\r\n        uint unclaimedDividend = totalDividendPerShare - userLastClaimed;\r\n        \r\n        // Each user gets 1 share, so amount = unclaimedDividend / 1e18\r\n        uint _amt = unclaimedDividend / 1e18;\r\n        \r\n        require(_amt > 0, \"No royalty available\");\r\n        \r\n        // Apply cap to claim amount if needed\r\n        if(!isRoot) {\r\n            uint maxRoyaltyIncome = (userTotalDeposit * royaltyMaxPercent) / 100;\r\n            uint remainingAllowed = maxRoyaltyIncome > royaltyIncome[_id]\r\n                ? maxRoyaltyIncome - royaltyIncome[_id]\r\n                : 0;\r\n            \r\n            if (_amt > remainingAllowed) {\r\n                _amt = remainingAllowed;\r\n            }\r\n        }\r\n        \r\n        require(_amt > 0, \"Claim amount too small\");\r\n        \r\n        // Update tracking\r\n        lastClaimedDividend[_id][_tier] = totalDividendPerShare;\r\n        lastRoyaltyTime[_id][_tier] = getCurRoyaltyDay();\r\n        \r\n        // Track royalty income separately for cap calculation\r\n        royaltyIncome[_id] += _amt;\r\n        \r\n        // RECURRING ROYALTY MODEL: Users stay active until 150% income cap\r\n        // Both root and normal users can claim multiple times from their tier\r\n        // Only the 150% cap check (line 220) limits normal users\r\n        // if(!isRoot) {\r\n        //     royaltyActive[_id][_tier] = false; // DISABLED - allows recurring claims\r\n        // }\r\n        \r\n        \r\n        // Transfer royalty to user in USDT\r\n        require(USDT.transfer(userAccount, _amt), \"USDT transfer failed\");\r\n        \r\n        emit RoyaltyClaimed(_id, _tier, _amt, block.timestamp);\r\n        return _amt;\r\n    }\r\n    \r\n    // ==================== VIEW FUNCTIONS ====================\r\n    \r\n    /**\r\n     * @dev Get current royalty day\r\n     */\r\n    function getCurRoyaltyDay() public view returns(uint) {\r\n        return (block.timestamp - startTime) / royaltyDistTime;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get next royalty distribution time\r\n     */\r\n    function getNextDistTime() external view returns(uint) {\r\n        return startTime + (royaltyDistTime * (getCurRoyaltyDay() + 1));\r\n    }\r\n    \r\n    /**\r\n     * @dev Get royalty percentages\r\n     */\r\n    function getRoyaltyPercents() external view returns(uint[4] memory) {\r\n        return royaltyPercent;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get royalty levels\r\n     */\r\n    function getRoyaltyLevels() external view returns(uint[4] memory) {\r\n        return royaltyLevels;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get user's royalty data for specific tier\r\n     */\r\n    function getUserRoyaltyData(uint _userId, uint _tier) external view returns(\r\n        uint claimableAmount,\r\n        bool active,\r\n        uint lastClaimedDay\r\n    ) {\r\n        uint totalDividendPerShare = royaltyData[_tier].dividendPerShare;\r\n        uint userLastClaimed = lastClaimedDividend[_userId][_tier];\r\n        uint unclaimedDividend = totalDividendPerShare > userLastClaimed \r\n            ? totalDividendPerShare - userLastClaimed \r\n            : 0;\r\n        \r\n        return (\r\n            unclaimedDividend / 1e18,\r\n            royaltyActive[_userId][_tier],\r\n            lastRoyaltyTime[_userId][_tier]\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Get tier statistics\r\n     */\r\n    function getTierStats(uint _tier) external view returns(\r\n        uint userCount,\r\n        uint distributionRound,\r\n        uint pendingUserCount\r\n    ) {\r\n        require(_tier < 4, \"Invalid tier\");\r\n        return (\r\n            royaltyData[_tier].userCount,\r\n            royaltyData[_tier].distributionRound,\r\n            pendingRoyaltyUsers[_tier][0].length\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if user is eligible for specific tier\r\n     */\r\n    function isEligibleForRoyalty(uint _userId, uint _tier) external view returns(bool) {\r\n        require(_tier < 4, \"Invalid tier\");\r\n        return royaltyActive[_userId][_tier] && \r\n               lastClaimedDividend[_userId][_tier] < royaltyData[_tier].dividendPerShare;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get contract USDT balance\r\n     */\r\n    function getBalance() external view returns(uint) {\r\n        return USDT.balanceOf(address(this));\r\n    }\r\n    \r\n    /**\r\n     * @dev Get contract configuration for frontend\r\n     */\r\n    function getContractConfig() external view returns(\r\n        uint _royaltyMaxPercent,\r\n        uint _royaltyDistTime,\r\n        uint _startTime,\r\n        uint _currentDay\r\n    ) {\r\n        return (\r\n            royaltyMaxPercent,\r\n            royaltyDistTime,\r\n            startTime,\r\n            getCurRoyaltyDay()\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/MockChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title MockChainlinkOracle\r\n * @notice Mock Chainlink price feed for testing\r\n */\r\ncontract MockChainlinkOracle {\r\n    int256 private price;\r\n    uint80 private roundId = 1;\r\n    \r\n    constructor() {\r\n        price = 600 * 1e8; // $600 with 8 decimals\r\n    }\r\n    \r\n    function setPrice(uint256 _price) external {\r\n        price = int256(_price * 1e8);\r\n        roundId++;\r\n    }\r\n    \r\n    function latestRoundData() external view returns (\r\n        uint80,\r\n        int256,\r\n        uint256,\r\n        uint256,\r\n        uint80\r\n    ) {\r\n        return (\r\n            roundId,\r\n            price,\r\n            block.timestamp,\r\n            block.timestamp,\r\n            roundId\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/RideBNB_USDT.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title RideBNB - USDT-Only Global Matrix\r\n * @notice Fully autonomous contract with hardcoded economics\r\n * @dev Owner can renounce to make fully decentralized\r\n */\r\n\r\n// USDT Token Interface\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n// Royalty Contract Interface\r\ninterface IRoyalty {\r\n    function registerUser(uint _userId, uint _level, uint _directCount) external;\r\n    function claimRoyalty(\r\n        uint _id, \r\n        uint _tier,\r\n        uint rootUserId,\r\n        uint userTotalIncome,\r\n        uint userTotalDeposit,\r\n        address userAccount\r\n    ) external returns (uint);\r\n    function getUserRoyaltyData(uint _userId, uint _tier) external view returns (uint, bool, bool);\r\n    function getRoyaltyPercents() external view returns(uint[4] memory);\r\n    function getRoyaltyLevels() external view returns(uint[4] memory);\r\n    function getTierStats(uint _tier) external view returns(uint userCount, uint distributionRound, uint pendingUserCount);\r\n}\r\n\r\ncontract RideBNB {\r\n    // ============ IMMUTABLE VALUES (SET AT DEPLOYMENT) ============\r\n    \r\n    address public immutable FEE_RECEIVER;\r\n    IERC20 public immutable USDT;\r\n    IRoyalty public immutable ROYALTY_ADDR;\r\n    uint private immutable DEFAULT_REFER;\r\n    uint public immutable START_TIME;\r\n    \r\n    // ============ CONSTANTS (HARDCODED FOREVER) ============\r\n    \r\n    // System constants\r\n    uint8 public constant MAX_LEVELS = 13;\r\n    uint8 public constant MAX_INCOME_LAYER = 20;  // Income distribution depth\r\n    uint8 public constant MAX_PLACEMENT_DEPTH = 100;  // Placement search depth\r\n    // Note: If tree depth exceeds 100, placement falls back to root (DEFAULT_REFER)\r\n    // This prevents infinite loops but may cluster users under root in very large trees\r\n    \r\n    // Economic constants (adjustable by owner until renounced)\r\n    uint8 public constant ADMIN_FEE_PERCENT = 5;      // 5% admin fee\r\n    uint8 public constant ROYALTY_FUND_PERCENT = 5;   // 5% to royalty pool\r\n    \r\n    // Level costs (adjustable by owner, immutable after renounce)\r\n    // Starting costs: L1=$5, L2=$10, L3=$20... up to L13=$20,480 (hardcoded initially)\r\n    uint256[13] public levelCosts = [\r\n        5e18,      // L1: $5\r\n        10e18,     // L2: $10  \r\n        20e18,     // L3: $20\r\n        40e18,     // L4: $40\r\n        80e18,     // L5: $80\r\n        160e18,    // L6: $160\r\n        320e18,    // L7: $320\r\n        640e18,    // L8: $640\r\n        1280e18,   // L9: $1,280\r\n        2560e18,   // L10: $2,560\r\n        5120e18,   // L11: $5,120\r\n        10240e18,  // L12: $10,240\r\n        20480e18   // L13: $20,480\r\n    ];\r\n    \r\n    // Team & income constants\r\n    uint public constant DIRECT_REQUIRED = 2;\r\n    uint public constant MAX_REFERRAL_LAYERS = 1;\r\n    \r\n    // Sponsor commission (13 levels, total 5%)\r\n    uint8 private constant SPONSOR_LEVELS = 13;\r\n    \r\n    function _getSponsorPercentage(uint8 level) private pure returns (uint16) {\r\n        if (level == 0) return 100;   // L1: 1%\r\n        if (level == 1) return 80;    // L2: 0.8%\r\n        if (level == 2) return 60;    // L3: 0.6%\r\n        if (level == 3) return 50;    // L4: 0.5%\r\n        if (level == 4) return 50;    // L5: 0.5%\r\n        if (level == 5) return 40;    // L6: 0.4%\r\n        if (level == 6) return 30;    // L7: 0.3%\r\n        if (level == 7) return 25;    // L8: 0.25%\r\n        if (level == 8) return 20;    // L9: 0.2%\r\n        if (level == 9) return 15;    // L10: 0.15%\r\n        if (level == 10) return 10;   // L11: 0.1%\r\n        if (level == 11) return 10;   // L12: 0.1%\r\n        if (level == 12) return 10;   // L13: 0.1%\r\n        return 0;\r\n    }\r\n    \r\n    // Sponsor qualification thresholds\r\n    uint8 private constant MIN_DIRECTS_L6_8 = 2;\r\n    uint8 private constant MIN_DIRECTS_L9_10 = 3;\r\n    uint8 private constant MIN_DIRECTS_L11_13 = 5;\r\n    \r\n    \r\n    // ============ STATE VARIABLES ============\r\n    \r\n    // Owner (can renounce)\r\n    address public owner;\r\n    \r\n    // Reentrancy guard (improved pattern)\r\n    uint256 private unlocked = 1;\r\n    \r\n    // User tracking\r\n    uint public totalUsers;\r\n    uint private userIdCounter;\r\n    \r\n    // ============ DATA STRUCTURES ============\r\n    \r\n    struct User {\r\n        bool exists;\r\n        address account;\r\n        uint referrer;\r\n        uint upline;\r\n        uint level;\r\n        uint directTeam;\r\n        uint team;\r\n        uint registrationTime;\r\n    }\r\n    \r\n    struct UserIncome {\r\n        uint totalDeposit;\r\n        uint totalIncome;\r\n        uint referralIncome;\r\n        uint sponsorIncome;\r\n        uint levelIncome;\r\n    }\r\n    \r\n    struct Activity {\r\n        uint id;\r\n        uint level;\r\n        uint time;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => uint) public id;\r\n    mapping(uint => User) public userInfo;\r\n    mapping(uint => UserIncome) public userIncome;\r\n    mapping(uint => mapping(uint => uint[])) public teams;\r\n    mapping(uint => uint) public matrixDirect;\r\n    mapping(uint => uint) public lostIncome;\r\n    mapping(uint => uint[]) private directReferrals;  // NEW: O(1) direct team lookup\r\n    \r\n    uint[] private globalUsers;  // Changed to private (use events instead)\r\n    Activity[] private activity;  // Changed to private (use events instead)\r\n    \r\n    // ============ EVENTS ============\r\n    \r\n    // User lifecycle\r\n    event UserRegistered(uint indexed userId, address indexed account, uint indexed referrer, uint timestamp);\r\n    event UserUpgraded(uint indexed userId, uint newLevel, uint amount, uint timestamp);\r\n    event RootUserCreated(uint indexed rootUserId, address indexed rootAddress, uint timestamp);\r\n    \r\n    // Payments & income\r\n    event AdminFeePaid(uint amount, uint level, uint timestamp);\r\n    event ReferralPayment(uint indexed referrerId, uint indexed userId, uint amount, uint timestamp);\r\n    event SponsorCommissionPaid(uint indexed sponsorId, uint indexed fromUserId, uint amount, uint level, uint timestamp);\r\n    event MatrixPayment(uint indexed fromUserId, uint indexed toUserId, uint amount, uint level, uint layer, bool qualified, uint timestamp);\r\n    event IncomeLost(uint indexed userId, uint indexed fromUser, uint amount, string reason, uint timestamp);\r\n    event RoyaltyPoolFunded(uint indexed userId, uint amount, uint timestamp);\r\n    event RoyaltyClaimed(uint indexed userId, uint indexed royaltyLevel, uint amount, uint timestamp);\r\n    \r\n    // Ownership\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipRenounced(address indexed previousOwner, uint timestamp);\r\n    event LevelCostUpdated(uint8 indexed level, uint256 oldCost, uint256 newCost, uint timestamp);\r\n    \r\n    // ============ MODIFIERS ============\r\n    \r\n    modifier nonReentrant() {\r\n        require(unlocked == 1, \"Reentrancy detected\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier validUser(uint _userId) {\r\n        require(_userId > 0 && userInfo[_userId].exists, \"Invalid user ID\");\r\n        _;\r\n    }\r\n    \r\n    // ============ CONSTRUCTOR ============\r\n    \r\n    constructor(\r\n        address _feeReceiver,\r\n        address _royalty,\r\n        address _rootUserAddress,\r\n        uint _rootUserId,\r\n        address _usdtToken\r\n    ) {\r\n        require(_feeReceiver != address(0), \"Invalid fee receiver\");\r\n        require(_royalty != address(0), \"Invalid royalty\");\r\n        require(_rootUserAddress != address(0), \"Invalid root address\");\r\n        require(_rootUserId > 0, \"Invalid root user ID\");\r\n        require(_usdtToken != address(0), \"Invalid USDT\");\r\n        \r\n        // Set immutables\r\n        FEE_RECEIVER = _feeReceiver;\r\n        ROYALTY_ADDR = IRoyalty(_royalty);\r\n        DEFAULT_REFER = _rootUserId;\r\n        START_TIME = block.timestamp;\r\n        USDT = IERC20(_usdtToken);\r\n        \r\n        // Set owner\r\n        owner = msg.sender;\r\n        \r\n        // Initialize root user\r\n        userIdCounter = DEFAULT_REFER;\r\n        id[_rootUserAddress] = DEFAULT_REFER;\r\n        _createUser(DEFAULT_REFER, _rootUserAddress, DEFAULT_REFER, DEFAULT_REFER, 12);\r\n        globalUsers.push(DEFAULT_REFER);\r\n        totalUsers = 1;\r\n        // Root user already has level 13 from _createUser (12 + 1)\r\n        \r\n        // Register root to all royalty tiers\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 10, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 11, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 12, 0);\r\n        ROYALTY_ADDR.registerUser(DEFAULT_REFER, 13, 0);\r\n        \r\n        emit RootUserCreated(DEFAULT_REFER, _rootUserAddress, block.timestamp);\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n    \r\n    // ============ LEVEL COST HELPER ============\r\n    \r\n    /**\r\n     * @dev Get level cost in USDT (uses adjustable levelCosts array)\r\n     * @param _level Level index (0-12 for L1-L13)\r\n     * @return USDT cost in wei (18 decimals)\r\n     */\r\n    function _getLevelCost(uint _level) private view returns (uint) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        return levelCosts[_level];\r\n    }\r\n    \r\n    // ============ USER-FACING FUNCTIONS ============\r\n    \r\n    /**\r\n        if (_level == 7) return 320e18;     // $320\r\n        if (_level == 8) return 640e18;     // $640\r\n        if (_level == 9) return 1320e18;    // $1,320\r\n        if (_level == 10) return 2740e18;   // $2,740\r\n        if (_level == 11) return 5480e18;   // $5,480\r\n        if (_level == 12) return 10960e18;  // $10,960\r\n        revert(\"Invalid level\");\r\n    }\r\n    \r\n    // ============ USER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Register new user with USDT payment\r\n     * @param _ref Referrer user ID (0 = default)\r\n     * @param _newAcc New user wallet address\r\n     */\r\n    function register(uint _ref, address _newAcc) external nonReentrant {\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly registration using referrer address\r\n     */\r\n    function registerMe(address _referrerAddress) external {\r\n        uint _ref = (_referrerAddress == address(0)) ? 0 : id[_referrerAddress];\r\n        address _newAcc = msg.sender;\r\n        require(id[_newAcc] == 0, \"Already registered\");\r\n        require(_newAcc != address(0), \"Invalid address\");\r\n        \r\n        // Validate referrer or use default\r\n        if (_ref == 0 || !userInfo[_ref].exists) {\r\n            _ref = DEFAULT_REFER;\r\n        }\r\n        \r\n        // Calculate required USDT amount\r\n        uint levelCost = _getLevelCost(0);\r\n        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        uint requiredAmount = levelCost + adminFee;\r\n        \r\n        // Transfer USDT from user\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), requiredAmount),\r\n            \"USDT transfer failed\"\r\n        );\r\n        \r\n        // Create user\r\n        uint _newId = userIdCounter + 1;\r\n        userIdCounter = _newId;\r\n        id[_newAcc] = _newId;\r\n        _createUser(_newId, _newAcc, _ref, _ref, 0);\r\n        globalUsers.push(_newId);\r\n        totalUsers++;\r\n        \r\n        // Update deposit\r\n        userIncome[_newId].totalDeposit += levelCost;\r\n        \r\n        // Process payments\r\n        _processRegistrationPayments(_newId, levelCost, adminFee);\r\n        _placeInBinaryMatrix(_newId, _ref);\r\n        _updateTeamCounts(_newId);\r\n\r\n        \r\n        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);\r\n        activity.push(Activity(_newId, 1, block.timestamp));\r\n    }\r\n    \r\n    /**\r\n     * @notice Upgrade user to higher levels with USDT\r\n     */\r\n    function upgrade(uint _id, uint _lvls) external nonReentrant validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        require(userInfo[_id].level + _lvls <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        \r\n        // Calculate total cost\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        // Transfer USDT from user\r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        // Process each level\r\n        for (uint i = 0; i < _lvls; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[_id].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[_id].level++;\r\n            userIncome[_id].totalDeposit += levelCost;\r\n            \r\n            // Pay admin fee\r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[_id].level - 1, block.timestamp);\r\n            }\r\n            \r\n            // Fund royalty pool (5% of levelCost)\r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n                emit RoyaltyPoolFunded(_id, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            // Distribute payments\r\n            uint remaining = _processSponsorCommission(_id, levelCost);\r\n            _distributeMatrixIncome(_id, userInfo[_id].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            // Register for royalty\r\n            ROYALTY_ADDR.registerUser(_id, userInfo[_id].level, userInfo[_id].directTeam);\r\n            \r\n            emit UserUpgraded(_id, userInfo[_id].level, levelCost, block.timestamp);\r\n            activity.push(Activity(_id, userInfo[_id].level, block.timestamp));\r\n\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly upgrade for caller\r\n     */\r\n    function upgradeMe(uint _levels) external {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        require(msg.sender == userInfo[myId].account, \"Unauthorized\");\r\n        require(userInfo[myId].level + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        uint totalCost;\r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            totalCost += levelCost + (levelCost * ADMIN_FEE_PERCENT / 100);\r\n        }\r\n        \r\n        require(USDT.transferFrom(msg.sender, address(this), totalCost), \"USDT transfer failed\");\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint levelCost = _getLevelCost(userInfo[myId].level + i - 1);\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            \r\n            userInfo[myId].level++;\r\n            userIncome[myId].totalDeposit += levelCost;\r\n            \r\n            if (adminFee > 0) {\r\n                require(USDT.transfer(FEE_RECEIVER, adminFee), \"Admin fee failed\");\r\n                emit AdminFeePaid(adminFee, userInfo[myId].level - 1, block.timestamp);\r\n            }\r\n            \r\n            uint royaltyFundAmt = (levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n            if (royaltyFundAmt > 0) {\r\n                require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");emit RoyaltyPoolFunded(myId, royaltyFundAmt, block.timestamp);\r\n            }\r\n            \r\n            uint remaining = _processSponsorCommission(myId, levelCost);\r\n            _distributeMatrixIncome(myId, userInfo[myId].level - 1, remaining - royaltyFundAmt, false);\r\n            \r\n            ROYALTY_ADDR.registerUser(myId, userInfo[myId].level, userInfo[myId].directTeam);\r\n            \r\n            emit UserUpgraded(myId, userInfo[myId].level, levelCost, block.timestamp);\r\n            activity.push(Activity(myId, userInfo[myId].level, block.timestamp));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Claim royalty reward\r\n     */\r\n    function claimRoyalty(uint _id, uint _royaltyLvl) external nonReentrant validUser(_id) {\r\n        require(msg.sender == userInfo[_id].account, \"Unauthorized\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            _id,\r\n            _royaltyLvl,\r\n            DEFAULT_REFER,\r\n            userIncome[_id].totalIncome,\r\n            userIncome[_id].totalDeposit,\r\n            userInfo[_id].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(_id, _royaltyLvl, amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice BSCScan-friendly royalty claim\r\n     */\r\n    function claimMyRoyalty(uint _tier) external nonReentrant {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint amount = ROYALTY_ADDR.claimRoyalty(\r\n            myId,\r\n            _tier,\r\n            DEFAULT_REFER,\r\n            userIncome[myId].totalIncome,\r\n            userIncome[myId].totalDeposit,\r\n            userInfo[myId].account\r\n        );\r\n        \r\n        emit RoyaltyClaimed(myId, _tier, amount, block.timestamp);\r\n    }\r\n    \r\n    // ============ OWNER FUNCTIONS ============\r\n    \r\n    /**\r\n     * @notice Renounce ownership - makes contract fully autonomous\r\n     * @dev IRREVERSIBLE - contract becomes ownerless forever\r\n     */\r\n    function renounceOwnership() external onlyOwner {\r\n        emit OwnershipRenounced(owner, block.timestamp);\r\n        owner = address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfer ownership to new address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Update level cost (owner only, before renouncing)\r\n     * @dev Allows flexibility during initial phase, becomes immutable after renounce\r\n     */\r\n    function setLevelCost(uint8 _level, uint256 _newCost) external onlyOwner {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        require(_newCost > 0, \"Cost must be positive\");\r\n        require(_newCost >= 1e18, \"Minimum cost is 1 USDT\");\r\n        require(_newCost <= 100000e18, \"Maximum cost is 100,000 USDT\");\r\n        \r\n        uint256 oldCost = levelCosts[_level];\r\n        levelCosts[_level] = _newCost;\r\n        \r\n        emit LevelCostUpdated(_level, oldCost, _newCost, block.timestamp);\r\n    }\r\n    \r\n    // ============ INTERNAL FUNCTIONS - PAYMENT DISTRIBUTION ============\r\n    \r\n    function _processRegistrationPayments(uint _newId, uint _levelCost, uint _adminFee) private {\r\n        // Pay admin fee (5%)\r\n        if (_adminFee > 0) {\r\n            require(USDT.transfer(FEE_RECEIVER, _adminFee), \"Admin fee failed\");\r\n            emit AdminFeePaid(_adminFee, 0, block.timestamp);\r\n        }\r\n        \r\n        // Fund royalty pool (5% of levelCost)\r\n        uint royaltyFundAmt = (_levelCost * ROYALTY_FUND_PERCENT) / 100;\r\n        if (royaltyFundAmt > 0) {\r\n            require(USDT.transfer(address(ROYALTY_ADDR), royaltyFundAmt), \"Royalty fund failed\");\r\n            emit RoyaltyPoolFunded(_newId, royaltyFundAmt, block.timestamp);\r\n        }\r\n        \r\n        // Referral income (95% = levelCost - royaltyFund)\r\n        uint _referrer = userInfo[_newId].referrer;\r\n        uint referralAmount = _levelCost - royaltyFundAmt;\r\n        \r\n        if (_referrer != 0 && userInfo[_referrer].exists) {\r\n            require(USDT.transfer(userInfo[_referrer].account, referralAmount), \"Referral failed\");\r\n            userIncome[_referrer].referralIncome += referralAmount;\r\n            userIncome[_referrer].totalIncome += referralAmount;\r\n            emit ReferralPayment(_referrer, _newId, referralAmount, block.timestamp);\r\n        } else {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, referralAmount), \"Default referral failed\");\r\n            userIncome[DEFAULT_REFER].referralIncome += referralAmount;\r\n            userIncome[DEFAULT_REFER].totalIncome += referralAmount;\r\n            emit ReferralPayment(DEFAULT_REFER, _newId, referralAmount, block.timestamp);\r\n        }\r\n        \r\n        // Note: For registration, income goes to Referrer, NOT matrix\r\n        // Matrix distribution only happens on upgrade\r\n    }\r\n\r\n    \r\n    function _processSponsorCommission(uint _id, uint _amount) private returns (uint) {\r\n        uint _referrer = userInfo[_id].referrer;\r\n        uint totalPaid = 0;\r\n        uint totalSponsorAllocation = (_amount * 500) / 10000;  // 5%\r\n        \r\n        // Distribute to up to 13 levels\r\n        for (uint8 level = 0; level < SPONSOR_LEVELS && _referrer != 0; level++) {\r\n            bool qualified = _isQualifiedForSponsorLevel(_referrer, level);\r\n            uint reward = (_amount * _getSponsorPercentage(level)) / 10000;\r\n            \r\n            if (qualified && reward > 0) {\r\n                bool success = USDT.transfer(userInfo[_referrer].account, reward);\r\n                if (success) {\r\n                    userIncome[_referrer].sponsorIncome += reward;\r\n                    userIncome[_referrer].totalIncome += reward;\r\n                    totalPaid += reward;\r\n                    \r\n                    emit SponsorCommissionPaid(_referrer, _id, reward, level + 1, block.timestamp);\r\n                }\r\n            } else if (reward > 0) {\r\n                // Track lost income only if upline exists\r\n                if (userInfo[_referrer].exists) {\r\n                    lostIncome[_referrer] += reward;\r\n                    \r\n                    string memory reason;\r\n                    if (level < 5) {\r\n                        reason = \"Not active (need Level 1+)\";\r\n                    } else if (level >= 5 && level < 8) {\r\n                        reason = \"Need 2+ direct referrals for L6-L8\";\r\n                    } else if (level >= 8 && level < 10) {\r\n                        reason = \"Need 3+ direct referrals for L9-L10\";\r\n                    } else {\r\n                        reason = \"Need 5+ direct referrals for L11-L13\";\r\n                    }\r\n                    \r\n                    emit IncomeLost(_referrer, _id,reward, reason, block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _referrer = userInfo[_referrer].referrer;\r\n        }\r\n        \r\n        // Silent fallback to root for unpaid commission\r\n        if (totalPaid < totalSponsorAllocation) {\r\n            uint unpaid = totalSponsorAllocation - totalPaid;\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, unpaid), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].sponsorIncome += unpaid;\r\n            userIncome[DEFAULT_REFER].totalIncome += unpaid;\r\n            totalPaid = totalSponsorAllocation;\r\n        }\r\n        \r\n        return _amount - totalPaid;  // Returns 95%\r\n    }\r\n    \r\n    \r\n    function _distributeMatrixIncome(uint _userId, uint _level, uint _amount, bool ignoreQualification) private {\r\n        uint _upline = userInfo[_userId].upline;\r\n        bool paid = false;\r\n        \r\n        // Search up to 13 levels for qualified upline\r\n        for (uint i = 0; i < MAX_INCOME_LAYER && _upline != 0; i++) {\r\n            bool qualified = ignoreQualification || \r\n                            (userInfo[_upline].level > _level && userInfo[_upline].directTeam >= DIRECT_REQUIRED);\r\n            \r\n            if (qualified) {\r\n                // Give FULL remaining amount (90%) to first qualified upline\r\n                bool success = USDT.transfer(userInfo[_upline].account, _amount);\r\n                if (success) {\r\n                    userIncome[_upline].levelIncome += _amount;\r\n                    userIncome[_upline].totalIncome += _amount;\r\n                    paid = true;\r\n                    \r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, true, block.timestamp);\r\n                }\r\n                break;  // Stop after first qualified upline gets paid\r\n            } else {\r\n                // Emit events for transparency, but DON'T track lostIncome\r\n                // (winner-takes-all model - only first qualified gets paid, so no real \"share\" lost)\r\n                if (userInfo[_upline].exists) {\r\n                    emit MatrixPayment(_userId, _upline, _amount, _level, i + 1, false, block.timestamp);\r\n                    emit IncomeLost(_upline, _userId, _amount, \"Not qualified for matrix\", block.timestamp);\r\n                }\r\n            }\r\n            \r\n            _upline = userInfo[_upline].upline;\r\n        }\r\n        \r\n        // Silent fallback to root if no qualified upline found\r\n        if (!paid && _amount > 0) {\r\n            require(USDT.transfer(userInfo[DEFAULT_REFER].account, _amount), \"Root fallback failed\");\r\n            userIncome[DEFAULT_REFER].levelIncome += _amount;\r\n            userIncome[DEFAULT_REFER].totalIncome += _amount;\r\n            // No event emission - users only see their own missed income\r\n        }\r\n    }\r\n\r\n    \r\n    function _isQualifiedForSponsorLevel(uint _userId, uint8 level) private view returns (bool) {\r\n        User storage user = userInfo[_userId];\r\n        \r\n        if (!user.exists || user.level < 1) return false;\r\n        \r\n        if (level < 5) {\r\n            return true;  // L1-L5: Just need Level 1+\r\n        } else if (level >= 5 && level < 8) {\r\n            return user.directTeam >= MIN_DIRECTS_L6_8;  // L6-L8: 2+ directs\r\n        } else if (level >= 8 && level < 10) {\r\n            return user.directTeam >= MIN_DIRECTS_L9_10;  // L9-L10: 3+ directs\r\n        } else {\r\n            return user.directTeam >= MIN_DIRECTS_L11_13;  // L11-L13: 5+ directs\r\n        }\r\n    }\r\n    \r\n    // ============ INTERNAL FUNCTIONS - USER & MATRIX ============\r\n    \r\n    function _createUser(uint _userId, address _account, uint _referrer, uint _upline, uint _level) private {\r\n        userInfo[_userId] = User({\r\n            exists: true,\r\n            account: _account,\r\n            referrer: _referrer,\r\n            upline: _upline,\r\n            level: _level + 1,\r\n            directTeam: 0,\r\n            team: 0,\r\n            registrationTime: block.timestamp\r\n        });\r\n        \r\n        userIncome[_userId] = UserIncome({\r\n            totalDeposit: 0,\r\n            totalIncome: 0,\r\n            referralIncome: 0,\r\n            sponsorIncome: 0,\r\n            levelIncome: 0\r\n        });\r\n        \r\n        if (_referrer != 0 && _referrer != _userId) {\r\n            userInfo[_referrer].directTeam++;\r\n            directReferrals[_referrer].push(_userId);  // Store in mapping for O(1) lookup\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Place new user in binary matrix using breadth-first search\r\n     * @param _newId ID of new user to place\r\n     * @param _ref Starting point (usually referrer)\r\n     * \r\n     * Searches for available spot (max 2 children per node) within MAX_PLACEMENT_DEPTH.\r\n     * If no spot found within depth limit, falls back to placing under root.\r\n     * This prevents infinite loops but may cluster users in very deep trees.\r\n     */\r\n    function _placeInBinaryMatrix(uint _newId, uint _ref) private {\r\n        uint[] memory queue = new uint[](MAX_PLACEMENT_DEPTH);\r\n        uint front = 0;\r\n        uint back = 0;\r\n        queue[back++] = _ref;\r\n        \r\n        bool placed = false;\r\n        uint iterations = 0;\r\n        \r\n        while (front < back && iterations < MAX_PLACEMENT_DEPTH) {\r\n            uint _upline = queue[front++];\r\n            iterations++;\r\n            \r\n            if (teams[_upline][0].length < 2) {\r\n                teams[_upline][0].push(_newId);\r\n                userInfo[_newId].upline = _upline;\r\n                matrixDirect[_upline]++;\r\n                placed = true;\r\n                break;\r\n            }\r\n            \r\n            for (uint i = 0; i < teams[_upline][0].length && back < MAX_PLACEMENT_DEPTH; i++) {\r\n                queue[back++] = teams[_upline][0][i];\r\n            }\r\n        }\r\n        \r\n        // Fallback to referrer if no spot found within depth limit\r\n        if (!placed) {\r\n            teams[_ref][0].push(_newId);\r\n            userInfo[_newId].upline = _ref;\r\n            matrixDirect[_ref]++;\r\n\r\n        }\r\n    }\r\n    \r\n    function _updateTeamCounts(uint _userId) private {\r\n        uint _upline = userInfo[_userId].referrer;\r\n        uint depth = 0;\r\n        \r\n        while (_upline != 0 && depth < MAX_PLACEMENT_DEPTH) {\r\n            userInfo[_upline].team++;\r\n            _upline = userInfo[_upline].referrer;\r\n            depth++;\r\n        }\r\n    }\r\n    \r\n    // ============ VIEW FUNCTIONS ============\r\n    \r\n    function isAutonomous() external view returns (bool) {\r\n        return owner == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @notice Get user account address by ID (used by Royalty contract)\r\n     */\r\n    function getUserAccount(uint _userId) external view returns (address) {\r\n        return userInfo[_userId].account;\r\n    }\r\n    \r\n    function getLevelCost(uint _level) external view returns (uint cost, uint adminFee, uint total) {\r\n        require(_level < MAX_LEVELS, \"Invalid level\");\r\n        cost = _getLevelCost(_level);\r\n        adminFee = (cost * ADMIN_FEE_PERCENT) / 100;\r\n        total = cost + adminFee;\r\n    }\r\n    \r\n    function getAllLevelCosts() external view returns (\r\n        uint[13] memory costs,\r\n        uint[13] memory fees,\r\n        uint[13] memory totals\r\n    ) {\r\n        for (uint i = 0; i < 13; i++) {\r\n            costs[i] = _getLevelCost(i);\r\n            fees[i] = (costs[i] * ADMIN_FEE_PERCENT) / 100;\r\n            totals[i] = costs[i] + fees[i];\r\n        }\r\n    }\r\n    \r\n    function getRegistrationCost() external view returns (uint cost, uint levelCost, uint adminFee) {\r\n        levelCost = _getLevelCost(0);\r\n        adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n        cost = levelCost + adminFee;\r\n    }\r\n    \r\n    function getUpgradeCost(uint _levels) external view returns (uint totalCost, uint[] memory breakdown) {\r\n        uint myId = id[msg.sender];\r\n        require(myId > 0, \"Not registered\");\r\n        \r\n        uint currentLevel = userInfo[myId].level;\r\n        require(currentLevel + _levels <= MAX_LEVELS, \"Exceeds max level\");\r\n        \r\n        breakdown = new uint[](_levels);\r\n        totalCost = 0;\r\n        \r\n        for (uint i = 0; i < _levels; i++) {\r\n            uint targetLevel = currentLevel + i;\r\n            uint levelCost = _getLevelCost(targetLevel - 1);  // FIX: targetLevel is 1-13, need index 0-12\r\n            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;\r\n            uint cost = levelCost + adminFee;\r\n            \r\n            breakdown[i] = cost;\r\n            totalCost += cost;\r\n        }\r\n    }\r\n    \r\n    function getMyInfo() external view returns (\r\n        uint userId,\r\n        uint level,\r\n        uint team,\r\n        uint directTeam,\r\n        uint totalIncome,\r\n        uint referrerId,\r\n        uint uplineId,\r\n        uint registrationTime\r\n    ) {\r\n        userId = id[msg.sender];\r\n        if (userId == 0) return (0, 0, 0, 0, 0, 0, 0, 0);\r\n        \r\n        User storage user = userInfo[userId];\r\n        UserIncome storage income = userIncome[userId];\r\n        \r\n        return (\r\n            userId,\r\n            user.level,\r\n            user.team,\r\n            user.directTeam,\r\n            income.totalIncome,\r\n            user.referrer,\r\n            user.upline,\r\n            user.registrationTime\r\n        );\r\n    }\r\n    \r\n    function getMyIncomeBreakdown() external view returns (\r\n        uint totalDeposit,\r\n        uint totalIncome,\r\n        uint referralIncome,\r\n        uint sponsorIncome,\r\n        uint levelIncome,\r\n        uint lostAmount\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, 0, 0, 0, 0);\r\n        \r\n        UserIncome storage income = userIncome[myId];\r\n        return (\r\n            income.totalDeposit,\r\n            income.totalIncome,\r\n            income.referralIncome,\r\n            income.sponsorIncome,\r\n            income.levelIncome,\r\n            lostIncome[myId]\r\n        );\r\n    }\r\n    \r\n    function getMyTeam() external view returns (\r\n        uint teamSize,\r\n        uint directCount,\r\n        uint[] memory directReferralIds,\r\n        address[] memory directReferralAddresses\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (0, 0, new uint[](0), new address[](0));\r\n        \r\n        User storage user = userInfo[myId];\r\n        teamSize = user.team;\r\n        directCount = user.directTeam;\r\n        \r\n        // Use mapping for O(1) lookup instead of O(N) loop\r\n        directReferralIds = directReferrals[myId];\r\n        \r\n        // Build addresses array\r\n        directReferralAddresses = new address[](directReferralIds.length);\r\n        for (uint i = 0; i < directReferralIds.length; i++) {\r\n            directReferralAddresses[i] = userInfo[directReferralIds[i]].account;\r\n        }\r\n    }\r\n    \r\n    function getMyRoyaltyStatus() external view returns (\r\n        uint[4] memory claimableAmounts,\r\n        bool[4] memory isEligible,\r\n        bool[4] memory hasClaimed\r\n    ) {\r\n        uint myId = id[msg.sender];\r\n        if (myId == 0) return (claimableAmounts, isEligible, hasClaimed);\r\n        \r\n        for (uint i = 0; i < 4; i++) {\r\n            (claimableAmounts[i], isEligible[i], hasClaimed[i]) = ROYALTY_ADDR.getUserRoyaltyData(myId, i);\r\n        }\r\n    }\r\n    \r\n    function isRegistered(address _address) external view returns (bool) {\r\n        return id[_address] > 0;\r\n    }\r\n    \r\n    function getContractBalance() external view returns (uint) {\r\n        return USDT.balanceOf(address(this));\r\n    }\r\n}\r\n"
    },
    "contracts/Royalty_USDT.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title Royalty - USDT-Only Version\r\n * @notice Manages all royalty distribution for the RideBNB platform in USDT\r\n * @dev Simplified version with owner-only control\r\n */\r\n\r\n// USDT Token Interface\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n// Interface to query RideBNB contract for user data\r\ninterface IRideBNB {\r\n    function getUserAccount(uint userId) external view returns (address);\r\n}\r\n\r\ncontract Royalty_USDT {\r\n    \r\n    // ==================== IMMUTABLES ====================\r\n    \r\n    IERC20 public immutable USDT;\r\n    \r\n    // ==================== STATE VARIABLES ====================\r\n    \r\n    // Reentrancy guard (improved pattern)\r\n    uint256 private unlocked = 1;\r\n    address public owner;\r\n    address public rideBNBContract;\r\n    uint public immutable startTime;\r\n    uint private immutable rootUserId;\r\n    \r\n    // Royalty system constants\r\n    uint public constant royaltyDistTime = 1 days;\r\n    uint public constant royaltyMaxPercent = 150;  // 150% cap on total income\r\n    \r\n    // Royalty tier percentages (immutable)\r\n    uint[4] public royaltyPercent = [40, 30, 20, 10];  // Tier 0-3 pool distribution\r\n    \r\n    // Royalty tier requirements (adjustable by owner, immutable after renounce)\r\n    uint[4] public royaltyLevels = [10, 11, 12, 13];  // Required levels for each tier\r\n    uint[4] public royaltyDirects = [0, 0, 0, 0];     // Required direct referrals for each tier required\r\n    \r\n    // Royalty tracking\r\n    struct RoyaltyData {\r\n        uint userCount;\r\n        uint index;\r\n        uint distributionRound;\r\n        uint dividendPerShare; // Accumulated dividend per share (scaled by 1e18)\r\n    }\r\n    \r\n    mapping(uint => RoyaltyData) public royaltyData;  // Tier index -> RoyaltyData\r\n    mapping(uint => mapping(uint => uint[])) private pendingRoyaltyUsers; // Pending list\r\n    mapping(uint => mapping(uint => bool)) public royaltyActive;    // Active status\r\n    mapping(uint => mapping(uint => uint)) private lastRoyaltyTime; // Claim timestamps\r\n    mapping(uint => mapping(uint => uint)) private lastClaimedDividend; // Track last claimed dividend per share\r\n    \r\n    mapping(uint => uint) private lastDistributedBalance;  // Track last balance PER TIER to calculate new funds only\r\n    \r\n    // Separate tracking for royalty income only (for 150% cap)\r\n    mapping(uint => uint) public royaltyIncome;  // userId -> total royalty income claimed\r\n    \r\n    // ==================== EVENTS ====================\r\n    \r\n    event RoyaltyDistributed(uint indexed tier, uint amount, uint userCount, uint timestamp);\r\n    event RoyaltyClaimed(uint indexed userId, uint indexed tier, uint amount, uint timestamp);\r\n    event UserRegistered(uint indexed userId, uint indexed tier, uint timestamp);\r\n    event RoyaltyConfigUpdated(string configType, uint timestamp);\r\n    event RoyaltyRequirementsUpdated(uint indexed tier, uint newLevel, uint newDirects, uint timestamp);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event RideBNBContractSet(address indexed rideBNBContract, uint timestamp);\r\n    \r\n    // ==================== MODIFIERS ====================\r\n    \r\n    modifier nonReentrant() {\r\n        require(unlocked == 1, \"Reentrancy detected\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyRideBNB() {\r\n        require(msg.sender == rideBNBContract, \"Only RideBNB contract\");\r\n        _;\r\n    }\r\n    \r\n    // ==================== CONSTRUCTOR ====================\r\n    \r\n    constructor(address _owner, uint _defaultRefer, address _usdtToken) {\r\n        require(_owner != address(0), \"Invalid owner\");\r\n        require(_usdtToken != address(0), \"Invalid USDT\");\r\n        \r\n        owner = _owner;\r\n        rootUserId = _defaultRefer;  // Store as immutable\r\n        startTime = block.timestamp;\r\n        USDT = IERC20(_usdtToken);\r\n    }\r\n    \r\n    // ==================== ADMIN FUNCTIONS ====================\r\n    \r\n    /**\r\n     * @dev Set RideBNB contract address (one-time setup)\r\n     */\r\n    function setRideBNBContract(address _rideBNBContract) external onlyOwner {\r\n        require(rideBNBContract == address(0), \"Already set\");\r\n        require(_rideBNBContract != address(0), \"Invalid address\");\r\n        rideBNBContract = _rideBNBContract;\r\n        emit RideBNBContractSet(_rideBNBContract, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Set royalty distribution percentages\r\n     */\r\n    function setRoyaltyPercents(uint[4] memory _newPercents) external {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        require(_newPercents[0] + _newPercents[1] + _newPercents[2] + _newPercents[3] == 100, \"Must total 100%\");\r\n        royaltyPercent = _newPercents;\r\n        emit RoyaltyConfigUpdated(\"percentages\", block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Update royalty tier requirements (owner only, before renouncing)\r\n     * @dev Allows flexibility during initial phase, becomes immutable after renounce\r\n     */\r\n    function setRoyaltyRequirements(uint _tier, uint _requiredLevel, uint _requiredDirects) external {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        require(_tier < 4, \"Invalid tier\");\r\n        require(_requiredLevel >= 1 && _requiredLevel <= 13, \"Level must be 1-13\");\r\n        require(_requiredDirects <= 100, \"Max 100 directs\");\r\n        \r\n        royaltyLevels[_tier] = _requiredLevel;\r\n        royaltyDirects[_tier] = _requiredDirects;\r\n        \r\n        emit RoyaltyRequirementsUpdated(_tier, _requiredLevel, _requiredDirects, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Set royalty tier levels (deprecated - use setRoyaltyRequirements)\r\n     */\r\n    function setRoyaltyLevels(uint[4] memory _levels) external onlyOwner {\r\n        for(uint i=0; i<4; i++) {\r\n            require(_levels[i] >= 1 && _levels[i] <= 13, \"Invalid level\");\r\n        }\r\n        royaltyLevels = _levels;\r\n        emit RoyaltyConfigUpdated(\"levels\", block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Set direct referral requirements (deprecated - use setRoyaltyRequirements)\r\n     */\r\n    function setRoyaltyDirectRequired(uint[4] memory _required) external onlyOwner {\r\n        for(uint i=0; i<4; i++) {\r\n            require(_required[i] > 0 && _required[i] <= 100, \"Invalid requirement\");\r\n            // Ensure ascending order - higher tiers need more or equal direct referrals\r\n            if(i > 0) require(_required[i] >= _required[i-1], \"Must be ascending\");\r\n        }\r\n        royaltyDirects = _required;\r\n        emit RoyaltyConfigUpdated(\"directRequired\", block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Transfer ownership\r\n     */\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"Invalid address\");\r\n        address previousOwner = owner;\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n    \r\n    // ==================== CORE ROYALTY FUNCTIONS ====================\r\n    \r\n    /**\r\n     * @dev Register user for royalty tier (called by RideBNB on upgrade)\r\n     * Root user stays in ALL tiers, normal users move between tiers (only one at a time)\r\n     * Auto-claims any unclaimed dividends before tier transition to prevent loss\r\n     */\r\n    function registerUser(uint _userId, uint _level, uint _directCount) external {\r\n        // Allow calls from RideBNB contract OR during initial setup (before RideBNB is connected)\r\n        require(msg.sender == rideBNBContract || rideBNBContract == address(0), \"Only RideBNB contract\");\r\n        \r\n        bool isRootUser = (_userId == rootUserId);\r\n        \r\n        // For normal users (not root): auto-claim and deactivate all previous tiers\r\n        if (!isRootUser) {\r\n            for(uint i = 0; i < 4; i++) {\r\n                if (royaltyActive[_userId][i]) {\r\n                    // AUTO-CLAIM: Try to transfer unclaimed dividends (non-blocking)\r\n                    uint totalDividendPerShare = royaltyData[i].dividendPerShare;\r\n                    uint userLastClaimed = lastClaimedDividend[_userId][i];\r\n                    \r\n                    if (totalDividendPerShare > userLastClaimed) {\r\n                        uint unclaimedDividend = totalDividendPerShare - userLastClaimed;\r\n                        uint claimAmount = unclaimedDividend / 1e18;\r\n                        \r\n                        if (claimAmount > 0) {\r\n                            // Try to transfer (best effort, non-blocking)\r\n                            address userAccount = IRideBNB(rideBNBContract).getUserAccount(_userId);\r\n                            bool success = USDT.transfer(userAccount, claimAmount);\r\n                            \r\n                            // Only update tracking if transfer successful\r\n                            if (success) {\r\n                                lastClaimedDividend[_userId][i] = totalDividendPerShare;\r\n                                royaltyIncome[_userId] += claimAmount;\r\n                                emit RoyaltyClaimed(_userId, i, claimAmount, block.timestamp);\r\n                            }\r\n                            // If failed: Share preserved, user can claim from old tier later\r\n                        }\r\n                    }\r\n                    \r\n                    // Deactivate tier\r\n                    royaltyActive[_userId][i] = false;\r\n                    royaltyData[i].userCount--;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Register to new tier\r\n        for(uint i = 0; i < 4; i++) {\r\n            bool meetsRequirement = isRootUser || (_directCount >= royaltyDirects[i]);\r\n            \r\n            if(royaltyLevels[i] == _level && meetsRequirement) {\r\n                // Skip if already active (for root user)\r\n                if (!royaltyActive[_userId][i]) {\r\n                    pendingRoyaltyUsers[i][0].push(_userId);\r\n                    royaltyActive[_userId][i] = true;\r\n                    emit UserRegistered(_userId, i, block.timestamp);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Distribute royalty pool to eligible users (NEW MODEL: Dividend-Per-Share)\r\n     * This increases accumulated dividends for ALL active users, not just new ones\r\n     */\r\n    function distRoyalty(uint _tier) external {\r\n        require(_tier < 4, \"Invalid tier\");\r\n        require((block.timestamp - startTime) / royaltyDistTime > royaltyData[_tier].distributionRound, \"Not yet\");\r\n        \r\n        // Get NEW funds only (not entire balance) - PER TIER\r\n        uint currentBalance = USDT.balanceOf(address(this));\r\n        uint newFunds = currentBalance > lastDistributedBalance[_tier] \r\n            ? currentBalance - lastDistributedBalance[_tier] \r\n            : 0;\r\n        \r\n        uint _amt = (newFunds * royaltyPercent[_tier]) / 100;\r\n        \r\n        require(_amt > 0, \"No new funds to distribute\");\r\n        \r\n        // Update tracked balance for THIS tier after calculating tier share\r\n        lastDistributedBalance[_tier] += _amt;\r\n        \r\n        // Process pending users first (add them to active pool for THIS tier)\r\n        uint currentIndex = royaltyData[_tier].index;\r\n        \r\n        for(uint i = currentIndex; i < pendingRoyaltyUsers[_tier][0].length; i++) {\r\n            uint _user = pendingRoyaltyUsers[_tier][0][i];\r\n            royaltyActive[_user][_tier] = true;\r\n            royaltyData[_tier].userCount++;\r\n            royaltyData[_tier].index++;\r\n        }\r\n        \r\n        uint totalActiveUsers = royaltyData[_tier].userCount;\r\n        require(totalActiveUsers > 0, \"No active users\");\r\n        \r\n        // Calculate dividend per share (scaled by 1e18 for precision)\r\n        uint dividendIncrease = (_amt * 1e18) / totalActiveUsers;\r\n        royaltyData[_tier].dividendPerShare += dividendIncrease;\r\n        \r\n        royaltyData[_tier].distributionRound++;\r\n        emit RoyaltyDistributed(_tier, _amt, totalActiveUsers, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev User claims their ACCUMULATED royalty (NEW MODEL: Pull Pattern)\r\n     */\r\n    function claimRoyalty(\r\n        uint _id, \r\n        uint _tier,\r\n        uint rootUserId,\r\n        uint userTotalIncome,\r\n        uint userTotalDeposit,\r\n        address userAccount\r\n    ) external nonReentrant returns (uint) {\r\n        require(msg.sender == userAccount || msg.sender == rideBNBContract, \"Unauthorized\");\r\n        require(_tier < 4, \"Invalid tier\");\r\n        \r\n        // Allow claiming from ANY tier where user has unclaimed dividends\r\n        // No longer requires active status - user can claim old tier dividends\r\n        \r\n        // Prevent claiming if no new dividends available\r\n        uint totalDividendPerShare = royaltyData[_tier].dividendPerShare;\r\n        uint userLastClaimed = lastClaimedDividend[_id][_tier];\r\n        require(userLastClaimed < totalDividendPerShare, \"No new dividends\");\r\n        \r\n        // Root user special privilege: no income cap\r\n        bool isRoot = _id == rootUserId;\r\n        \r\n        // CAP CHECK: 150% applies ONLY to royalty income, not other income!\r\n        if(!isRoot) {\r\n            uint maxRoyaltyIncome = (userTotalDeposit * royaltyMaxPercent) / 100;\r\n            require(royaltyIncome[_id] < maxRoyaltyIncome, \"Royalty cap reached\");\r\n        }\r\n        \r\n        // Calculate accumulated dividends\r\n        uint unclaimedDividend = totalDividendPerShare - userLastClaimed;\r\n        \r\n        // Each user gets 1 share, so amount = unclaimedDividend / 1e18\r\n        uint _amt = unclaimedDividend / 1e18;\r\n        \r\n        require(_amt > 0, \"No royalty available\");\r\n        \r\n        // Apply cap to claim amount if needed\r\n        if(!isRoot) {\r\n            uint maxRoyaltyIncome = (userTotalDeposit * royaltyMaxPercent) / 100;\r\n            uint remainingAllowed = maxRoyaltyIncome > royaltyIncome[_id]\r\n                ? maxRoyaltyIncome - royaltyIncome[_id]\r\n                : 0;\r\n            \r\n            if (_amt > remainingAllowed) {\r\n                _amt = remainingAllowed;\r\n            }\r\n        }\r\n        \r\n        require(_amt > 0, \"Claim amount too small\");\r\n        \r\n        // Update tracking\r\n        lastClaimedDividend[_id][_tier] = totalDividendPerShare;\r\n        lastRoyaltyTime[_id][_tier] = getCurRoyaltyDay();\r\n        \r\n        // Track royalty income separately for cap calculation\r\n        royaltyIncome[_id] += _amt;\r\n        \r\n        // RECURRING ROYALTY MODEL: Users stay active until 150% income cap\r\n        // Both root and normal users can claim multiple times from their tier\r\n        // Only the 150% cap check (line 220) limits normal users\r\n        // if(!isRoot) {\r\n        //     royaltyActive[_id][_tier] = false; // DISABLED - allows recurring claims\r\n        // }\r\n        \r\n        \r\n        // Transfer royalty to user in USDT\r\n        require(USDT.transfer(userAccount, _amt), \"USDT transfer failed\");\r\n        \r\n        emit RoyaltyClaimed(_id, _tier, _amt, block.timestamp);\r\n        return _amt;\r\n    }\r\n    \r\n    // ==================== VIEW FUNCTIONS ====================\r\n    \r\n    /**\r\n     * @dev Get current royalty day\r\n     */\r\n    function getCurRoyaltyDay() public view returns(uint) {\r\n        return (block.timestamp - startTime) / royaltyDistTime;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get next royalty distribution time\r\n     */\r\n    function getNextDistTime() external view returns(uint) {\r\n        return startTime + (royaltyDistTime * (getCurRoyaltyDay() + 1));\r\n    }\r\n    \r\n    /**\r\n     * @dev Get royalty percentages\r\n     */\r\n    function getRoyaltyPercents() external view returns(uint[4] memory) {\r\n        return royaltyPercent;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get royalty levels\r\n     */\r\n    function getRoyaltyLevels() external view returns(uint[4] memory) {\r\n        return royaltyLevels;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get user's royalty data for specific tier\r\n     */\r\n    function getUserRoyaltyData(uint _userId, uint _tier) external view returns(\r\n        uint claimableAmount,\r\n        bool active,\r\n        uint lastClaimedDay\r\n    ) {\r\n        uint totalDividendPerShare = royaltyData[_tier].dividendPerShare;\r\n        uint userLastClaimed = lastClaimedDividend[_userId][_tier];\r\n        uint unclaimedDividend = totalDividendPerShare > userLastClaimed \r\n            ? totalDividendPerShare - userLastClaimed \r\n            : 0;\r\n        \r\n        return (\r\n            unclaimedDividend / 1e18,\r\n            royaltyActive[_userId][_tier],\r\n            lastRoyaltyTime[_userId][_tier]\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Get tier statistics\r\n     */\r\n    function getTierStats(uint _tier) external view returns(\r\n        uint userCount,\r\n        uint distributionRound,\r\n        uint pendingUserCount\r\n    ) {\r\n        require(_tier < 4, \"Invalid tier\");\r\n        return (\r\n            royaltyData[_tier].userCount,\r\n            royaltyData[_tier].distributionRound,\r\n            pendingRoyaltyUsers[_tier][0].length\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if user is eligible for specific tier\r\n     */\r\n    function isEligibleForRoyalty(uint _userId, uint _tier) external view returns(bool) {\r\n        require(_tier < 4, \"Invalid tier\");\r\n        return royaltyActive[_userId][_tier] && \r\n               lastClaimedDividend[_userId][_tier] < royaltyData[_tier].dividendPerShare;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get contract USDT balance\r\n     */\r\n    function getBalance() external view returns(uint) {\r\n        return USDT.balanceOf(address(this));\r\n    }\r\n    \r\n    /**\r\n     * @dev Get contract configuration for frontend\r\n     */\r\n    function getContractConfig() external view returns(\r\n        uint _royaltyMaxPercent,\r\n        uint _royaltyDistTime,\r\n        uint _startTime,\r\n        uint _currentDay\r\n    ) {\r\n        return (\r\n            royaltyMaxPercent,\r\n            royaltyDistTime,\r\n            startTime,\r\n            getCurRoyaltyDay()\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/TestUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract TestUSDT {\r\n    string public name = \"Test USDT\";\r\n    string public symbol = \"USDT\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n    \r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    \r\n    constructor(uint256 _initialSupply) {\r\n        totalSupply = _initialSupply * 10**decimals;\r\n        balanceOf[msg.sender] = totalSupply;\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) external returns (bool) {\r\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\r\n        require(_to != address(0), \"Invalid address\");\r\n        \r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        \r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) external returns (bool) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\r\n        require(balanceOf[_from] >= _value, \"Insufficient balance\");\r\n        require(allowance[_from][msg.sender] >= _value, \"Insufficient allowance\");\r\n        require(_to != address(0), \"Invalid address\");\r\n        \r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        \r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function mint(address _to, uint256 _amount) external {\r\n        require(_to != address(0), \"Invalid address\");\r\n        \r\n        totalSupply += _amount;\r\n        balanceOf[_to] += _amount;\r\n        \r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}