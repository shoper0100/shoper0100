// SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.20;

// Chainlink Price Feed Interface
interface AggregatorV3Interface {
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

interface IRoyalty {
    function registerUser(uint _userId, uint _level, uint _directCount) external;
    function claimRoyalty(
        uint _id, 
        uint _tier,
        uint rootUserId,
        uint userTotalIncome,
        uint userTotalDeposit,
        address userAccount
    ) external returns (uint);
    function getUserRoyaltyData(uint _userId, uint _tier) external view returns (uint, bool, bool);
    function getRoyaltyPercents() external view returns(uint[4] memory);
    function getRoyaltyLevels() external view returns(uint[4] memory);
    function getTierStats(uint _tier) external view returns(uint userCount, uint distributionRound, uint pendingUserCount);
}

/**
 * @title RideBNB - Limitless Global Matrix
 * @notice Simplified version with owner-only control
 */
contract RideBNB {
    // Reentrancy guard
    bool private locked;
    
    // Governance addresses
    address public owner;
    address public daoAddress; // Restored DAO address
    address public emergencyAdmin;
    
    // Contract addresses
    IRoyalty public royaltyAddr;
    address public feeReceiver;
    
    // Constants
    uint private constant MAX_INCOME_LAYER = 13;
    uint private constant MAX_LEVELS = 13;
    uint private constant ROYALTY_TIERS = 4;
    uint private constant MAX_DIRECT_REQUIRED = 10;
    uint private constant MAX_SPONSOR_COMMISSION = 10;  // Max 10% sponsor commission
    uint private constant MAX_LEVEL_FEE_PERCENT = 20;
    uint private constant MAX_ITERATIONS = 100;
    uint private constant MAX_REFERRAL_LAYERS = 5;      // Max 5 layers for referral
    uint private constant MAX_ROYALTY_PERCENT = 20;     // Max 20% for royalty funding
    uint private constant MAX_BNB_PRICE_USD = 100000; // Max $100k per BNB
    uint private constant MIN_BNB_PRICE_USD = 10; // Min $10 per BNB
    uint private constant MAX_LEVEL_COST = 100 ether; // Max cost per level
    uint private constant MIN_LEVEL_COST = 0.001 ether; // Min cost per level
    uint public constant ADMIN_FEE_PERCENT = 5;  // 5% admin fee for all levels (hardcoded)
    
    // Rank System Constants (13 ranks: 0-12 for levels 1-13)
    uint8 private constant MAX_RANK = 12;
    uint32[13] private RANK_TEAM_SIZE = [0, 3, 5, 10, 20, 40, 75, 150, 300, 600, 1200, 2500, 5000];
    uint8[13] private RANK_DIRECT_REQUIRED = [0, 2, 2, 3, 3, 4, 5, 6, 7, 8, 10, 12, 15];
    uint[13] private RANK_TEAM_VOLUME = [
        0, 0.01 ether, 0.05 ether, 0.1 ether, 0.25 ether, 0.5 ether, 1 ether,
        2.5 ether, 5 ether, 10 ether, 25 ether, 50 ether, 100 ether
    ];
    
    // Configurable parameters
    uint private maxLayers = 26;
    uint public directRequired = 2;                    // Direct referrals required for qualification
    uint public maxReferralLayers = 1;                  // How many layers up referral income can go
    uint public royaltyFundPercent = 5;                 // Royalty pool funding percentage (5% default)
    
    // 13-level sponsor commission system (basis points: /10000)
    // Total: 5% distributed progressively across up to 13 uplines
    uint8 private constant SPONSOR_LEVELS = 13;
    uint16[13] private SPONSOR_PERCENTAGES = [
        100, 80, 60, 50, 50,   // L1-L5: 1%, 0.8%, 0.6%, 0.5%, 0.5%
        40, 30, 25,            // L6-L8: 0.4%, 0.3%, 0.25%
        20, 15,                // L9-L10: 0.2%, 0.15%
        10, 10, 10             // L11-L13: 0.1%, 0.1%, 0.1%
    ];
    uint8 private constant MIN_DIRECTS_L6_8 = 2;
    uint8 private constant MIN_DIRECTS_L9_10 = 3;
    uint8 private constant MIN_DIRECTS_L11_13 = 5;
    uint public bnbPriceInUSD = 600;  // Current BNB price in USD
    uint public lastPriceUpdate;       // Last price update timestamp
    address public priceOracle;        // Chainlink price feed address
    uint public constant PRICE_UPDATE_INTERVAL = 24 hours; // Auto-update interval
    bool public autoUpdateEnabled = true; // Enable/disable auto-updates
    bool public paused;
    
    // Levels (in wei)
    uint[13] private levels = [
        4e15, 6e15, 12e15, 24e15, 48e15, 96e15, 192e15, 384e15, 
        768e15, 1536e15, 3072e15, 6144e15, 12288e15
    ];
    // Admin fee percent removed - now using ADMIN_FEE_PERCENT constant
    
    // User structures
    struct User {
        address account;
        uint id;
        uint referrer;
        uint upline;
        uint start;
        uint level;
        uint directTeam;
        uint totalMatrixTeam;
        bool exists;
    }
    
    struct UserIncome {
        uint totalIncome;
        uint totalDeposit;
        uint royaltyIncome;
        uint referralIncome;
        uint levelIncome;
        uint sponsorIncome;
        uint[13] income;
        uint8 rank;  // User's current rank (0-12)
    }
    
    struct Income {
        uint id;
        uint layer;
        uint amount;
        uint time;
        bool isLost;
    }
    
    struct Activity {
        uint id;
        uint level;
        uint timestamp;
    }
    
    // Immutable variables (set once in constructor, zero gas to read)
    uint public immutable START_TIME;
    uint private immutable DEFAULT_REFER;
    
    // State variables
    uint public totalUsers;
    uint private userIdCounter;
    
    // Mappings
    mapping (uint => User) public userInfo;
    mapping (uint => UserIncome) public userIncome;
    mapping (uint => Income[]) private incomeInfo;
    mapping (uint => uint) public lostIncome;
    mapping (address => uint) public id;
    mapping (uint => uint[]) public directTeam;
    mapping (uint => mapping (uint => uint[])) private teams;
    mapping (uint => uint) private matrixDirect;
    
    // Activity tracking
    Activity[] private activity;
    uint[] public globalUsers;
    
    // Events
    event UserRegistered(uint indexed userId, address indexed account, uint indexed referrer, uint timestamp);
    event UserUpgraded(uint indexed userId, uint level, uint amount, uint timestamp);
    event SponsorCommissionPaid(uint indexed sponsorId, uint indexed recipientId, uint amount, uint level, uint timestamp);
    event MatrixPayment(uint indexed fromId, uint indexed toId, uint amount, uint level, uint layer, bool qualified, uint timestamp);
    event RoyaltyClaimed(uint indexed userId, uint indexed royaltyLevel, uint amount, uint timestamp);
    event AdminFeePaid(uint amount, uint level, uint timestamp);
    event EmergencyPaused(address indexed admin, uint timestamp);
    event EmergencyUnpaused(address indexed admin, uint timestamp);
    event EmergencyAdminSet(address indexed oldAdmin, address indexed newAdmin);
    event EmergencyWithdraw(address indexed admin, uint amount, uint timestamp);
    event ConfigUpdated(string configName, uint oldValue, uint newValue, uint timestamp);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event DAOTransferred(address indexed oldDAO, address indexed newDAO);
    event RootUserCreated(uint indexed userId, address indexed account, uint timestamp);
    event MatrixPlaced(uint indexed userId, uint indexed upline, uint timestamp);
    event ReferralPayment(uint indexed fromId, uint indexed toId, uint amount, uint timestamp);
    event RoyaltyPoolFunded(uint indexed fromId, uint amount, uint timestamp);
    event IncomeLost(uint indexed userId, uint indexed fromId, uint amount, string reason, uint timestamp);
    event TeamCountUpdated(uint indexed userId, uint indexed uplineId, uint newCount, uint timestamp);
    event FeeReceiverUpdated(address indexed oldReceiver, address indexed newReceiver, uint timestamp);
    event RoyaltyContractUpdated(address indexed oldRoyalty, address indexed newRoyalty, uint timestamp);
    event RankAchieved(uint indexed userId, uint8 oldRank, uint8 newRank, string rankName, uint timestamp);
    
    // Modifiers
    modifier nonReentrant() {
        require(!locked, "No reentrancy");
        locked = true;
        _;
        locked = false;
    }
    
    modifier whenNotPaused() {
        require(!paused, "Contract paused");
        _;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    modifier onlyDAO() {
        require(msg.sender == daoAddress, "Only DAO");
        _;
    }
    
    modifier onlyEmergencyAdmin() {
        require(msg.sender == emergencyAdmin, "Only emergency admin");
        _;
    }
    
    modifier validUserId(uint _userId) {
        require(_userId > 0 && userInfo[_userId].exists, "Invalid user ID");
        _;
    }
    
    constructor(
        address _feeReceiver, 
        address _royalty, 
        address _owner, 
        uint _defaultRefer
    ) {
        require(_feeReceiver != address(0), "Invalid fee receiver");
        require(_royalty != address(0), "Invalid royalty address");
        require(_owner != address(0), "Invalid owner");
        require(_defaultRefer > 0, "Invalid default refer");
        
        // Set immutable variables first (zero gas to read after deployment)
        DEFAULT_REFER = _defaultRefer;
        START_TIME = block.timestamp;
        
        feeReceiver = _feeReceiver;
        royaltyAddr = IRoyalty(_royalty);
        owner = _owner;
        daoAddress = _owner; // Initial DAO address is owner
        emergencyAdmin = _owner; // Initially owner is also emergency admin
        
        // Initialize root user at Level 1
        userIdCounter = DEFAULT_REFER;
        id[_owner] = DEFAULT_REFER;
        _createUser(DEFAULT_REFER, _owner, DEFAULT_REFER, DEFAULT_REFER, 0);
        globalUsers.push(DEFAULT_REFER);
        totalUsers = 1;
        
        // Set root user to max level (L13) so they qualify for all royalty tiers
        userInfo[DEFAULT_REFER].level = 13;
        
        // Register root to ALL royalty tiers (ensures distributions never fail)
        // Root is exempt from direct referral requirements
        royaltyAddr.registerUser(DEFAULT_REFER, 10, 0); // Tier 0 (L10)
        royaltyAddr.registerUser(DEFAULT_REFER, 11, 0); // Tier 1 (L11)
        royaltyAddr.registerUser(DEFAULT_REFER, 12, 0); // Tier 2 (L12)
        royaltyAddr.registerUser(DEFAULT_REFER, 13, 0); // Tier 3 (L13)
        
        emit RootUserCreated(DEFAULT_REFER, _owner, block.timestamp);
    }
    
    receive() external payable {}
    
    // ==================== USER FUNCTIONS ====================
    
    function register(uint _ref, address _newAcc) external payable 
        nonReentrant 
        whenNotPaused 
    {
        // Auto-update price from oracle if 24 hours have passed
        _autoUpdatePrice();
        
        require(msg.value > 0, "No BNB sent");
        require(id[_newAcc] == 0, "Already registered");
        require(_newAcc != address(0), "Invalid address");
        
        // Validate referrer or use default
        if (_ref == 0 || !userInfo[_ref].exists) {
            _ref = DEFAULT_REFER;
        }
        
        // Calculate required amount with admin fee
        uint levelCost = levels[0];
        uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;
        uint requiredAmount = levelCost + adminFee;
        
        require(msg.value >= requiredAmount, "Insufficient BNB");
        
        // Generate new user ID
        uint _newId = ++userIdCounter;
        
        // Create user
        id[_newAcc] = _newId;
        totalUsers++;
        globalUsers.push(_newId);
        
        _createUser(_newId, _newAcc, _ref, defaultRefer, levelCost);
        
        // Process payments
        _processRegistrationPayments(_ref, _newId, levelCost, adminFee);
        
        // Update team structure
        directTeam[_ref].push(_newId);
        userInfo[_ref].directTeam++;
        
        // Place in binary matrix
        _placeInBinaryMatrix(_newId, _ref);
        
        // Update team counts
        _updateTeamCounts(_newId);
        
        // Register for royalty
        royaltyAddr.registerUser(_newId, 1, 0);
        
        // Update rank
        _updateRank(_newId);
        
        // Emit events
        emit UserRegistered(_newId, _newAcc, _ref, block.timestamp);
        activity.push(Activity(_newId, 1, block.timestamp));
        
        // Refund excess BNB if any
        if (msg.value > requiredAmount) {
            uint refundAmount = msg.value - requiredAmount;
            (bool refundSuccess, ) = payable(msg.sender).call{value: refundAmount}("");
            // Don't require success - user can re-register if refund fails
        }
    }
    
    function upgrade(uint _id, uint _lvls) external payable 
        nonReentrant 
        whenNotPaused 
        validUserId(_id)
    {
        // Auto-update price from oracle if 24 hours have passed
        _autoUpdatePrice();
        
        require(msg.sender == userInfo[_id].account || msg.sender == owner, "Unauthorized");
        require(_lvls > 0 && _lvls <= MAX_LEVELS, "Invalid levels count");
        
        uint currentLevel = userInfo[_id].level;
        require(currentLevel + _lvls <= MAX_LEVELS, "Exceeds max level");
        
        // Calculate total cost
        uint totalCost;
        uint[] memory upgradeLevels = new uint[](_lvls);
        
        for (uint i = 0; i < _lvls; i++) {
            uint targetLevel = currentLevel + i;
            uint levelCost = levels[targetLevel];
            uint adminFee = (levelCost * percents[targetLevel]) / 100;
            totalCost += levelCost + adminFee;
            upgradeLevels[i] = targetLevel;
        }
        
        require(msg.value >= totalCost, "Insufficient BNB");
        
        // Process each level upgrade
        for (uint i = 0; i < _lvls; i++) {
            uint targetLevel = upgradeLevels[i];
            uint levelCost = levels[targetLevel];
            uint adminFee = (levelCost * ADMIN_FEE_PERCENT) / 100;
            
            // Update user level and deposit
            userInfo[_id].level = targetLevel + 1;
            userIncome[_id].totalDeposit += levelCost;
            
            // Pay admin fee
            if (adminFee > 0) {
                payable(feeReceiver).transfer(adminFee);
                emit AdminFeePaid(adminFee, targetLevel, block.timestamp);
            }
            
            // Process sponsor commission and matrix distribution for ALL users (including owner)
            uint remaining = _processSponsorCommission(_id, levelCost);
            _distributeMatrixIncome(_id, targetLevel, remaining, false);
            
            // Register for royalty if applicable (pass direct team count)
            uint userDirectTeam = userInfo[_id].directTeam;
            royaltyAddr.registerUser(_id, targetLevel + 1, userDirectTeam);
            
            // Emit events
            emit UserUpgraded(_id, targetLevel + 1, levelCost, block.timestamp);
            activity.push(Activity(_id, targetLevel + 1, block.timestamp));
            
            // Update rank
            _updateRank(_id);
        }
        
        // Refund excess BNB if any
        if (msg.value > totalCost) {
            uint refundAmount = msg.value - totalCost;
            (bool refundSuccess, ) = payable(msg.sender).call{value: refundAmount}("");
            // Don't require success - user can retry upgrade if refund fails
        }
    }
    
    function claimRoyalty(uint _id, uint _royaltyLvl) external 
        nonReentrant 
        whenNotPaused 
        validUserId(_id)
    {
        require(msg.sender == userInfo[_id].account, "Unauthorized");
        require(_royaltyLvl < ROYALTY_TIERS, "Invalid royalty level");
        
        uint claimedAmt = royaltyAddr.claimRoyalty(
            _id,
            _royaltyLvl,
            defaultRefer,
            userIncome[_id].totalIncome,
            userIncome[_id].totalDeposit,
            userInfo[_id].account
        );
        
        require(claimedAmt > 0, "No royalty to claim");
        
        userIncome[_id].royaltyIncome += claimedAmt;
        userIncome[_id].totalIncome += claimedAmt;
        
        emit RoyaltyClaimed(_id, _royaltyLvl, claimedAmt, block.timestamp);
    }
    
    // ==================== USER-FRIENDLY BSCSCAN FUNCTIONS ====================
    
    /**
     * @notice Register yourself with a referrer address (easier than using ID)
     * @dev Wrapper function for BSCScan users - converts address to ID
     * @param _referrerAddress Your sponsor's address (use 0x0 for default root user)
     */
    function registerMe(address _referrerAddress) external payable 
        nonReentrant 
        whenNotPaused 
    {
        uint _ref = DEFAULT_REFER;
        
        if (_referrerAddress != address(0)) {
            _ref = id[_referrerAddress];
            require(_ref > 0, "Referrer not registered");
        }
        
        register(_ref, msg.sender);
    }
    
    /**
     * @notice Upgrade your own account by specified levels
     * @dev Wrapper function for BSCScan users - automatic ID lookup
     * @param _levels Number of levels to upgrade (1-13)
     */
    function upgradeMe(uint _levels) external payable 
        nonReentrant 
        whenNotPaused 
    {
        uint myId = id[msg.sender];
        require(myId > 0, "Not registered");
        
        upgrade(myId, _levels);
    }
    
    /**
     * @notice Claim your royalty for a specific tier
     * @dev Wrapper function for BSCScan users - automatic ID lookup
     * @param _tier Royalty tier (0-3: Tier0=L10, Tier1=L11, Tier2=L12, Tier3=L13)
     */
    function claimMyRoyalty(uint _tier) external 
        nonReentrant 
        whenNotPaused 
    {
        uint myId = id[msg.sender];
        require(myId > 0, "Not registered");
        
        claimRoyalty(myId, _tier);
    }
    
    // ==================== INTERNAL FUNCTIONS ====================
    
    function _createUser(
        uint _id,
        address _account,
        uint _referrer,
        uint _upline,
        uint _deposit
    ) private {
        userInfo[_id] = User({
            account: _account,
            id: _id,
            referrer: _referrer,
            upline: _upline,
            start: block.timestamp,
            level: 1,
            directTeam: 0,
            totalMatrixTeam: 0,
            exists: true
        });
        
        uint[13] memory emptyIncomes;
        userIncome[_id] = UserIncome({
            totalIncome: 0,
            totalDeposit: _deposit,
            royaltyIncome: 0,
            referralIncome: 0,
            levelIncome: 0,
            sponsorIncome: 0,
            income: emptyIncomes
        });
    }
    
    function _processRegistrationPayments(
        uint _referrer,
        uint _newId,
        uint _levelCost,
        uint _adminFee
    ) private {
        // Distribute referral commission up to configurable layers
        uint currentReferrer = _referrer;
        bool paid = false;
        
        // Fund royalty pool (configurable % of level cost) by deducting from referral payment
        uint royaltyFund = (_levelCost * royaltyFundPercent) / 100;
        uint referralPayment = _levelCost - royaltyFund;
        
        for (uint i = 0; i < maxReferralLayers && currentReferrer != 0 && currentReferrer != _newId; i++) {
            if (userInfo[currentReferrer].exists) {
                (bool success, ) = payable(userInfo[currentReferrer].account).call{value: referralPayment}("");
                require(success, "Referral payment failed");
                userIncome[currentReferrer].referralIncome += referralPayment;
                userIncome[currentReferrer].totalIncome += referralPayment;
                emit ReferralPayment(_newId, currentReferrer, referralPayment, block.timestamp);
                paid = true;
                break;
            }
            currentReferrer = userInfo[currentReferrer].referrer;
        }
        
        // If no valid referrer found in chain, send to default refer
        if (!paid && _referrer != _newId) {
            (bool success, ) = payable(userInfo[defaultRefer].account).call{value: referralPayment}("");
            require(success, "Default referral payment failed");
            userIncome[defaultRefer].referralIncome += referralPayment;
            userIncome[defaultRefer].totalIncome += referralPayment;
            emit ReferralPayment(_newId, defaultRefer, referralPayment, block.timestamp);
        }
        
        // Pay admin fee
        if (_adminFee > 0) {
            (bool success2, ) = payable(feeReceiver).call{value: _adminFee}("");
            require(success2, "Admin fee payment failed");
            emit AdminFeePaid(_adminFee, 0, block.timestamp);
        }
        
        // Send royalty funding to pool
        if (royaltyFund > 0) {
            (bool royaltySuccess, ) = address(royaltyAddr).call{value: royaltyFund}("");
            require(royaltySuccess, "Royalty funding failed");
            emit RoyaltyPoolFunded(_newId, royaltyFund, block.timestamp);
        }
        
        // Note: For Level 1 (Registration), income goes to Referrer (Referral Income), not Matrix.
        // Matrix income distribution applies for Upgrades (Level 2+) or specific matrix bonuses if added later.
        // Therefore, _distributeMatrixIncome is NOT called here to avoid double-spending msg.value.
    }
    
    function _placeInBinaryMatrix(uint _newId, uint _startUpline) private {
        uint _upline = _startUpline;
        bool placed = false;
        
        for (uint i = 0; i < maxLayers; i++) {
            _upline = userInfo[_upline].upline;
            if (_upline == 0) {
                _upline = defaultRefer;
            }
            
            // Check if spot available (strict binary - max 2 children)
            if (teams[_upline][0].length < 2) {
                teams[_upline][0].push(_newId);
                userInfo[_newId].upline = _upline;
                matrixDirect[_upline]++;
                placed = true;
                break;
            }
        }
        
        // Fallback to root if no spot found
        if (!placed) {
            teams[defaultRefer][0].push(_newId);
            userInfo[_newId].upline = defaultRefer;
            matrixDirect[defaultRefer]++;
            emit MatrixPlaced(_newId, defaultRefer, block.timestamp);
        } else {
            emit MatrixPlaced(_newId, userInfo[_newId].upline, block.timestamp);
        }
    }
    
    function _updateTeamCounts(uint _userId) private {
        uint _upline = userInfo[_userId].upline;
        uint iterations = 0;
        
        while (_upline != 0 && iterations < MAX_ITERATIONS) {
            userInfo[_upline].totalMatrixTeam++;
            // NOTE: TeamCountUpdated event removed from loop to prevent excessive gas costs
            // Emitting for each upline would cost ~1,500 gas Ã— iterations (39k-150k total)
            _upline = userInfo[_upline].upline;
            iterations++;
            
            // Gas limit protection
            if (gasleft() < 30000) break;
        }
    }
    
    function _processSponsorCommission(uint _id, uint _amount) private returns (uint) {
        uint _referrer = userInfo[_id].referrer;
        if (_referrer == 0 || _referrer == _id) {
            return _amount;
        }
        
        uint sponsorAmt = (_amount * sponsorCommission) / 100;
        
        // Distribute sponsor commission up to configurable layers
        for (uint i = 0; i < maxSponsorLayers && _referrer != 0; i++) {
            if (userInfo[_referrer].level >= minSponsorLevel) {
                (bool success, ) = payable(userInfo[_referrer].account).call{value: sponsorAmt}("");
                require(success, "Sponsor payment failed");
                userIncome[_referrer].sponsorIncome += sponsorAmt;
                userIncome[_referrer].totalIncome += sponsorAmt;
                
                emit SponsorCommissionPaid(_referrer, _id, sponsorAmt, block.timestamp);
                return _amount - sponsorAmt;
            } else {
                lostIncome[_referrer] += sponsorAmt;
                emit IncomeLost(_referrer, _id, sponsorAmt, "Sponsor level too low", block.timestamp);
            }
            _referrer = userInfo[_referrer].referrer;
        }
        
        // If no qualified sponsor in 13 layers, send to root
        (bool success2, ) = payable(userInfo[defaultRefer].account).call{value: sponsorAmt}("");
        require(success2, "Root sponsor payment failed");
        userIncome[defaultRefer].sponsorIncome += sponsorAmt;
        userIncome[defaultRefer].totalIncome += sponsorAmt;
        
        return _amount - sponsorAmt;
    }
    
    function _distributeMatrixIncome(
        uint _userId,
        uint _level,
        uint _amount,
        bool _isRegistration
    ) private {
        uint _upline = userInfo[_userId].upline;
        bool paid = false;
        uint levelCost = _isRegistration ? levels[_level] : _amount;
        
        for (uint i = 0; i < MAX_INCOME_LAYER && _upline != 0; i++) {
            if (userInfo[_upline].level > _level && userInfo[_upline].directTeam >= directRequired) {
                (bool success, ) = payable(userInfo[_upline].account).call{value: levelCost}("");
                require(success, "Matrix payment failed");
                
                userIncome[_upline].totalIncome += levelCost;
                userIncome[_upline].levelIncome += levelCost;
                userIncome[_upline].income[_level] += levelCost;
                
                incomeInfo[_upline].push(Income({
                    id: _userId,
                    layer: i + 1,
                    amount: levelCost,
                    time: block.timestamp,
                    isLost: false
                }));
                
                emit MatrixPayment(_userId, _upline, levelCost, _level, i + 1, true, block.timestamp);
                paid = true;
                break;
            } else {
                lostIncome[_upline] += levelCost;
                incomeInfo[_upline].push(Income({
                    id: _userId,
                    layer: i + 1,
                    amount: levelCost,
                    time: block.timestamp,
                    isLost: true
                }));
                
                emit MatrixPayment(_userId, _upline, levelCost, _level, i + 1, false, block.timestamp);
                emit IncomeLost(_upline, _userId, levelCost, "Not qualified for matrix", block.timestamp);
            }
            _upline = userInfo[_upline].upline;
        }
        
        // If no qualified receiver, send to root (silent fallback)
        if (!paid && levelCost > 0) {
            (bool success, ) = payable(userInfo[DEFAULT_REFER].account).call{value: levelCost}("");
            require(success, "Root fallback failed");
            userIncome[DEFAULT_REFER].levelIncome += levelCost;
            userIncome[DEFAULT_REFER].totalIncome += levelCost;
            // No event emission - users only see their own missed income
        }
    }
    
    /**
     * @dev Process 13-level sponsor commission distribution
     * @param _id User ID who made the deposit
     * @param _amount Amount to distribute (5% total across 13 levels)
     * @return remaining Amount after all sponsor commissions paid
     */
    function _processSponsorCommission(uint _id, uint _amount) private returns (uint) {
        uint _referrer = userInfo[_id].referrer;
        uint totalPaid = 0;
        uint totalSponsorAllocation = (_amount * 500) / 10000;  // Total 5% allocation
        
        // Distribute to up to 13 levels of sponsors
        for (uint8 level = 0; level < SPONSOR_LEVELS && _referrer != 0; level++) {
            bool qualified = _isQualifiedForSponsorLevel(_referrer, level);
            uint reward = (_amount * SPONSOR_PERCENTAGES[level]) / 10000;
            
            if (qualified && reward > 0) {
                (bool success, ) = payable(userInfo[_referrer].account).call{value: reward}("");
                if (success) {
                    userIncome[_referrer].sponsorIncome += reward;
                    userIncome[_referrer].totalIncome += reward;
                    totalPaid += reward;
                    
                    emit SponsorCommissionPaid(_referrer, _id, reward, level + 1, block.timestamp);
                }
            } else if (reward > 0) {
                // Track lost income with detailed reason
                lostIncome[_referrer] += reward;
                
                string memory reason;
                if (level < 5) {
                    reason = "Not active (need Level 1+)";
                } else if (level >= 5 && level < 8) {
                    reason = "Need 2+ direct referrals for L6-L8";
                } else if (level >= 8 && level < 10) {
                    reason = "Need 3+ direct referrals for L9-L10";
                } else {
                    reason = "Need 5+ direct referrals for L11-L13";
                }
                
                emit IncomeLost(_referrer, _id, reward, reason, block.timestamp);
            }
            
            _referrer = userInfo[_referrer].referrer;
        }
        
        // Fallback: Send any unpaid sponsor commission to root user (silent)
        if (totalPaid < totalSponsorAllocation) {
            uint unpaid = totalSponsorAllocation - totalPaid;
            
            (bool success, ) = payable(userInfo[DEFAULT_REFER].account).call{value: unpaid}("");
            if (success) {
                userIncome[DEFAULT_REFER].sponsorIncome += unpaid;
                userIncome[DEFAULT_REFER].totalIncome += unpaid;
                // No event emission - users only see their own missed income
            }
            
            totalPaid = totalSponsorAllocation;
        }
        
        return _amount - totalPaid;  // Always returns exactly 95% to matrix
    }
    
    /**
     * @dev Check if user qualifies for sponsor commission at specific level
     * @param _userId User ID to check
     * @param level Sponsor level (0-12 for L1-L13)
     * @return qualified True if user meets requirements
     */
    function _isQualifiedForSponsorLevel(uint _userId, uint8 level) private view returns (bool) {
        User storage user = userInfo[_userId];
        
        // Must be registered and have at least Level 1
        if (!user.exists || user.level < 1) {
            return false;
        }
        
        if (level < 5) {
            // L1-L5: Just need to be active (Level 1+)
            return true;
        } else if (level >= 5 && level < 8) {
            // L6-L8: Need 2+ direct referrals
            return user.directTeam >= MIN_DIRECTS_L6_8;
        } else if (level >= 8 && level < 10) {
            // L9-L10: Need 3+ direct referrals
            return user.directTeam >= MIN_DIRECTS_L9_10;
        } else {
            // L11-L13: Need 5+ direct referrals
            return user.directTeam >= MIN_DIRECTS_L11_13;
        }
    }
    
    function _updateRank(uint _userId) private {
        User storage user = userInfo[_userId];
        UserIncome storage income = userIncome[_userId];
        uint8 currentRank = income.rank;
        uint8 newRank = 0;
        
        // Calculate rank based on level and team metrics
        uint userLevel = user.level;
        uint teamSize = user.totalMatrixTeam;
        uint directTeam = user.directTeam;
        uint teamVolume = income.totalDeposit;
        
        // Check from highest rank down
        for (uint8 i = MAX_RANK; ; i--) {
            // User must have achieved at least the level
            if (userLevel >= (i + 1) &&
                teamSize >= RANK_TEAM_SIZE[i] &&
                directTeam >= RANK_DIRECT_REQUIRED[i] &&
                teamVolume >= RANK_TEAM_VOLUME[i]) {
                newRank = i;
                break;
            }
            if (i == 0) break;
        }
        
        if (newRank != currentRank) {
            income.rank = newRank;
            emit RankAchieved(_userId, currentRank, newRank, _getRankName(newRank), block.timestamp);
        }
    }
    
    function _getRankName(uint8 rank) private pure returns (string memory) {
        if (rank == 0) return "Starter";
        if (rank == 1) return "Builder";
        if (rank == 2) return "Achiever";
        if (rank == 3) return "Leader";
        if (rank == 4) return "Manager";
        if (rank == 5) return "Director";
        if (rank == 6) return "Executive";
        if (rank == 7) return "Senior Executive";
        if (rank == 8) return "Vice President";
        if (rank == 9) return "President";
        if (rank == 10) return "Diamond";
        if (rank == 11) return "Crown Diamond";
        if (rank == 12) return "Royal Crown";
        return "Unknown";
    }
    
    // ==================== ADMIN FUNCTIONS (OWNER OR DAO CONTROLLED) ====================
    
    function setDirectRequired(uint _newRequired) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_newRequired >= 1 && _newRequired <= MAX_DIRECT_REQUIRED, "Invalid value");
        uint oldValue = directRequired;
        directRequired = _newRequired;
        emit ConfigUpdated("directRequired", oldValue, _newRequired, block.timestamp);
    }
    
    function setSponsorCommission(uint _newPercent) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_newPercent <= MAX_SPONSOR_COMMISSION, "Exceeds max commission");
        uint oldValue = sponsorCommission;
        sponsorCommission = _newPercent;
        emit ConfigUpdated("sponsorCommission", oldValue, _newPercent, block.timestamp);
    }
    
    function setMinSponsorLevel(uint _newLevel) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_newLevel >= 1 && _newLevel <= MAX_LEVELS, "Invalid level");
        uint oldValue = minSponsorLevel;
        minSponsorLevel = _newLevel;
        emit ConfigUpdated("minSponsorLevel", oldValue, _newLevel, block.timestamp);
    }
    
    function setLevelCost(uint _levelIndex, uint _newCost) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_levelIndex < MAX_LEVELS, "Invalid index");
        require(_newCost >= MIN_LEVEL_COST && _newCost <= MAX_LEVEL_COST, "Cost out of range");
        uint oldValue = levels[_levelIndex];
        levels[_levelIndex] = _newCost;
        emit ConfigUpdated("levelCost", oldValue, _newCost, block.timestamp);
    }
    
    function setLevelFeePercent(uint _levelIndex, uint _newPercent) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_levelIndex < MAX_LEVELS, "Invalid index");
        require(_newPercent <= MAX_LEVEL_FEE_PERCENT, "Exceeds max fee");
        uint oldValue = percents[_levelIndex];
        percents[_levelIndex] = _newPercent;
        emit ConfigUpdated("levelFeePercent", oldValue, _newPercent, block.timestamp);
    }
    
    function setRoyaltyFundPercent(uint _newPercent) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_newPercent <= MAX_ROYALTY_PERCENT, "Exceeds max royalty percent");
        uint oldValue = royaltyFundPercent;
        royaltyFundPercent = _newPercent;
        emit ConfigUpdated("royaltyFundPercent", oldValue, _newPercent, block.timestamp);
    }
    
    function setMaxLayers(uint _max) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_max >= 13 && _max <= 200, "Invalid range");
        uint oldValue = maxLayers;
        maxLayers = _max;
        emit ConfigUpdated("maxLayers", oldValue, _max, block.timestamp);
    }
    
    function setMaxReferralLayers(uint _max) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_max >= 1 && _max <= MAX_REFERRAL_LAYERS, "Invalid range");
        uint oldValue = maxReferralLayers;
        maxReferralLayers = _max;
        emit ConfigUpdated("maxReferralLayers", oldValue, _max, block.timestamp);
    }
    
    function setMaxSponsorLayers(uint _max) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_max >= 1 && _max <= 200, "Invalid range");
        uint oldValue = maxSponsorLayers;
        maxSponsorLayers = _max;
        emit ConfigUpdated("maxSponsorLayers", oldValue, _max, block.timestamp);
    }
    
    function setBnbPrice(uint _priceInUSD) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_priceInUSD >= MIN_BNB_PRICE_USD && _priceInUSD <= MAX_BNB_PRICE_USD, "Price out of range");
        uint oldValue = bnbPriceInUSD;
        bnbPriceInUSD = _priceInUSD;
        lastPriceUpdate = block.timestamp;
        emit ConfigUpdated("bnbPriceInUSD", oldValue, _priceInUSD, block.timestamp);
    }
    
    function setPriceOracle(address _oracle) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        require(_oracle != address(0), "Invalid oracle address");
        priceOracle = _oracle;
        emit ConfigUpdated("priceOracle", 0, uint(uint160(_oracle)), block.timestamp);
    }
    
    /**
     * @dev Enable/disable automatic price updates from oracle
     */
    function setAutoUpdateEnabled(bool _enabled) external {
        require(msg.sender == owner || msg.sender == daoAddress, "Only owner or DAO");
        autoUpdateEnabled = _enabled;
        emit ConfigUpdated("autoUpdateEnabled", autoUpdateEnabled ? 0 : 1, _enabled ? 1 : 0, block.timestamp);
    }
    
    /**
     * @dev Update fee receiver address (DAO controlled for security)
     */
    function setFeeReceiver(address _newReceiver) external onlyDAO {
        require(_newReceiver != address(0), "Invalid address");
        address oldReceiver = feeReceiver;
        feeReceiver = _newReceiver;
        emit FeeReceiverUpdated(oldReceiver, _newReceiver, block.timestamp);
    }
    
    /**
     * @dev Update royalty contract address (DAO controlled for security)
     */
    function setRoyaltyContract(address _newRoyalty) external onlyDAO {
        require(_newRoyalty != address(0), "Invalid address");
        address oldRoyalty = address(royaltyAddr);
        royaltyAddr = IRoyalty(_newRoyalty);
        emit RoyaltyContractUpdated(oldRoyalty, _newRoyalty, block.timestamp);
    }
    
    /**
     * @dev Update BNB price from Chainlink oracle (manual refresh)
     * Can be called by owner/DAO anytime, or by anyone after 24 hours
     */
    function updateBnbPriceFromOracle() public {
        require(priceOracle != address(0), "Oracle not set");
        
        // Owner/DAO can update anytime, others must wait 24 hours
        if(msg.sender != owner && msg.sender != daoAddress) {
            require(block.timestamp >= lastPriceUpdate + PRICE_UPDATE_INTERVAL, "Too soon to update");
        }
        
        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceOracle);
        (
            /* uint80 roundID */,
            int256 price,
            /* uint startedAt */,
            /* uint timeStamp */,
            /* uint80 answeredInRound */
        ) = priceFeed.latestRoundData();
        
        require(price > 0, "Invalid price from oracle");
        
        // Chainlink returns price with 8 decimals, convert to USD
        uint newPrice = uint(price) / 1e8;
        require(newPrice >= MIN_BNB_PRICE_USD && newPrice <= MAX_BNB_PRICE_USD, "Price out of range");
        
        uint oldValue = bnbPriceInUSD;
        bnbPriceInUSD = newPrice;
        lastPriceUpdate = block.timestamp;
        emit ConfigUpdated("bnbPriceInUSD", oldValue, newPrice, block.timestamp);
    }
    
    /**
     * @dev Automatically update price if needed (internal helper)
     */
    function _autoUpdatePrice() private {
        // Only auto-update if enabled
        if(!autoUpdateEnabled) return;
        
        if(priceOracle != address(0) && block.timestamp >= lastPriceUpdate + PRICE_UPDATE_INTERVAL) {
            try this.updateBnbPriceFromOracle() {
                // Price updated successfully
            } catch {
                // Oracle call failed, continue with old price
            }
        }
    }
    
    function setEmergencyAdmin(address _newAdmin) external onlyOwner {
        require(_newAdmin != address(0), "Invalid address");
        address oldAdmin = emergencyAdmin;
        emergencyAdmin = _newAdmin;
        emit EmergencyAdminSet(oldAdmin, _newAdmin);
    }
    
    function batchUpdateLevels(uint[13] memory _usdAmounts) external onlyDAO {
        require(bnbPriceInUSD > 0, "Set BNB price first");
        
        for (uint i = 0; i < MAX_LEVELS; i++) {
            // Prevent overflow: max USD amount should not exceed type(uint128).max / 1e18
            require(_usdAmounts[i] <= type(uint128).max / 1e18, "Amount too large");
            levels[i] = (_usdAmounts[i] * 1e18) / bnbPriceInUSD;
        }
        emit ConfigUpdated("batchUpdateLevels", 0, 1, block.timestamp);
    }
    
    // ==================== EMERGENCY FUNCTIONS ====================
    
    function emergencyPause() external onlyEmergencyAdmin {
        paused = true;
        emit EmergencyPaused(msg.sender, block.timestamp);
    }
    
    function emergencyUnpause() external onlyEmergencyAdmin {
        paused = false;
        emit EmergencyUnpaused(msg.sender, block.timestamp);
    }
    
    function emergencyWithdraw() external onlyEmergencyAdmin {
        require(paused, "Contract not paused");
        uint balance = address(this).balance;
        require(balance > 0, "No funds");
        
        // Send to owner (not root user) for security
        (bool success, ) = payable(owner).call{value: balance}("");
        require(success, "Emergency withdrawal failed");
        
        emit EmergencyWithdraw(msg.sender, balance, block.timestamp);
    }
    
    // ==================== OWNERSHIP & DAO FUNCTIONS ====================
    
    function transferOwnership(address _newOwner) external onlyOwner {
        require(_newOwner != address(0), "Invalid address");
        address oldOwner = owner;
        owner = _newOwner;
        emit OwnershipTransferred(oldOwner, _newOwner);
    }
    
    function transferDAOControl(address _newDAO) external onlyOwner {
        require(_newDAO != address(0), "Invalid address");
        address oldDAO = daoAddress;
        daoAddress = _newDAO;
        emit DAOTransferred(oldDAO, _newDAO);
    }

    function updateGovernance(address _newDAO, address _newOwner) external onlyOwner {
        require(_newDAO != address(0) && _newOwner != address(0), "Invalid addresses");
        daoAddress = _newDAO;
        owner = _newOwner;
        emit OwnershipTransferred(msg.sender, _newOwner);
    }
    
    // ==================== VIEW FUNCTIONS ====================
    
    // NOTE: getUserData removed due to compiler stack depth limitations
    // Access via public userInfo mapping: contract.userInfo(userId)
    /*
    function getUserData(uint _userId) external view validUserId(_userId) returns (
        address account,
        uint id_,
        uint referrer,
        uint upline,
        uint startTime,
        uint level,
        uint directTeam,
        uint totalMatrixTeam,
        uint totalIncome,
        uint totalDeposit,
        uint royaltyIncome,
        uint referralIncome,
        uint levelIncome,
        uint sponsorIncome,
        uint[13] memory levelIncomes
    ) {
        User storage user = userInfo[_userId];
        return (
            user.account,
            user.id,
            user.referrer,
            user.upline,
            user.start,
            user.level,
            user.directTeam,
            user.totalMatrixTeam,
            user.totalIncome,
            user.totalDeposit,
            user.royaltyIncome,
            user.referralIncome,
            user.levelIncome,
            user.sponsorIncome,
            user.income
        );
    }
    */
    
    function getContractConfig() external view returns (
        uint _directRequired,
        uint _sponsorCommission,
        uint _minSponsorLevel,
        uint _bnbPriceInUSD,
        uint _maxLayers,
        uint _maxReferralLayers,
        uint _maxSponsorLayers,
        uint _totalUsers,
        uint _defaultRefer,
        uint _royaltyFundPercent
    ) {
        return (
            directRequired,
            sponsorCommission,
            minSponsorLevel,
            bnbPriceInUSD,
            maxLayers,
            maxReferralLayers,
            maxSponsorLayers,
            totalUsers,
            defaultRefer,
            royaltyFundPercent
        );
    }
    
    function getUserRoyaltyData(uint _userId, uint _royaltyLvl) external view returns (
        uint amount,
        bool taken,
        bool active
    ) {
        return royaltyAddr.getUserRoyaltyData(_userId, _royaltyLvl);
    }
    
    function getRoyaltyPercents() external view returns(uint[4] memory) {
        return royaltyAddr.getRoyaltyPercents();
    }
    
    function getRoyaltyLevels() external view returns(uint[4] memory) {
        return royaltyAddr.getRoyaltyLevels();
    }
    
    function getLevels() external view returns(uint[13] memory, uint[13] memory) {
        return (levels, percents);
    }
    
    function getMatrixDirect(uint _user) external view returns(uint[2] memory _directs) {
        for(uint i = 0; i < teams[_user][0].length && i < 2; i++) {
            _directs[i] = teams[_user][0][i];
        }
    }
    
    function getUserCurDay(uint _id) public view validUserId(_id) returns(uint) {
        return (block.timestamp - userInfo[_id].start) / 1 days;
    }
    
    function getRecentActivities(uint _num) external view returns(Activity[] memory) {
        uint count = activity.length > _num ? _num : activity.length;
        Activity[] memory result = new Activity[](count);
        
        if (count == 0) return result;
        
        for (uint i = 0; i < count; i++) {
            result[i] = activity[activity.length - 1 - i];
        }
        
        return result;
    }
    
    function getIncome(uint _user, uint _length) external view returns(Income[] memory) {
        uint count = incomeInfo[_user].length > _length ? _length : incomeInfo[_user].length;
        Income[] memory result = new Income[](count);
        
        if (count == 0) return result;
        
        for (uint i = 0; i < count; i++) {
            result[i] = incomeInfo[_user][incomeInfo[_user].length - 1 - i];
        }
        
        return result;
    }
    
    // ==================== UTILITY FUNCTIONS ====================
    
    function userExists(uint _userId) external view returns(bool) {
        return userInfo[_userId].exists;
    }
    
    function getDefaultRefer() external view returns(uint) {
        return defaultRefer;
    }
    
    function getOwner() external view returns(address) {
        return owner;
    }
    
    // Helper function to check if user qualifies for matrix income
    function isQualifiedForMatrix(uint _userId) external view returns(bool) {
        return userInfo[_userId].directTeam >= directRequired;
    }
    
    /*
    // Get user info for frontend - REMOVED due to stack depth
    // Use public userInfo mapping instead: contract.userInfo(userId)
    function getUserBasicInfo(uint _userId) external view returns(
        address account,
        uint level,
        uint directTeamCount,
        uint totalMatrixTeam,
        uint totalIncome
    ) {
        User storage user = userInfo[_userId];
        return (
            user.account,
            user.level,
            user.directTeam,
            user.totalMatrixTeam,
            user.totalIncome
        );
    }
    */
    
    function getUserRank(uint _userId) external view validUserId(_userId) 
        returns (uint8 rank, string memory rankName) 
    {
        rank = userIncome[_userId].rank;
        rankName = _getRankName(rank);
    }
    
    function getRankRequirements(uint8 rank) external view 
        returns (
            uint levelRequired,
            uint32 teamSizeRequired,
            uint8 directRequired,
            uint teamVolumeRequired,
            string memory rankName
        ) 
    {
        require(rank <= MAX_RANK, "Invalid rank");
        return (
            rank + 1,  // Level required
            RANK_TEAM_SIZE[rank],
            RANK_DIRECT_REQUIRED[rank],
            RANK_TEAM_VOLUME[rank],
            _getRankName(rank)
        );
    }
    
    function getAllRankNames() external pure returns (string[13] memory) {
        return [
            "Starter", "Builder", "Achiever", "Leader", "Manager", "Director",
            "Executive", "Senior Executive", "Vice President", "President",
            "Diamond", "Crown Diamond", "Royal Crown"
        ];
    }
    
    // ==================== BSCSCAN USER-FRIENDLY VIEW FUNCTIONS ====================
    
    /**
     * @notice Get all your account information in one call
     * @dev Returns comprehensive user data for the caller
     * @return userId Your user ID
     * @return level Current level (1-13)
     * @return directTeam Number of direct referrals
     * @return totalMatrixTeam Total team size in matrix
     * @return totalIncome Total income earned
     * @return totalDeposit Total amount deposited
     * @return rank Current rank (0-12)
     * @return rankName Rank name string
     * @return referrer Referrer's address
     * @return upline Matrix upline's address
     * @return registrationTime When registered (timestamp)
     */
    function getMyInfo() external view returns (
        uint userId,
        uint level,
        uint directTeam,
        uint totalMatrixTeam,
        uint totalIncome,
        uint totalDeposit,
        uint8 rank,
        string memory rankName,
        address referrer,
        address upline,
        uint registrationTime
    ) {
        uint myId = id[msg.sender];
        require(myId > 0, "Not registered");
        
        User storage user = userInfo[myId];
        UserIncome storage inc = userIncome[myId];
        
        return (
            myId,
            user.level,
            user.directTeam,
            user.totalMatrixTeam,
            inc.totalIncome,
            inc.totalDeposit,
            inc.rank,
            _getRankName(inc.rank),
            userInfo[user.referrer].account,
            userInfo[user.upline].account,
            user.start
        );
    }
    
    /**
     * @notice Get breakdown of all your income sources
     * @dev Returns detailed income information for the caller
     * @return totalIncome Total income from all sources
     * @return referralIncome Income from referrals
     * @return sponsorIncome Income from sponsor commissions
     * @return levelIncome Income from matrix
     * @return royaltyIncome Income from royalty pool
     * @return lostIncome Income you missed (unqualified)
     */
    function getMyIncomeBreakdown() external view returns (
        uint totalIncome,
        uint referralIncome,
        uint sponsorIncome,
        uint levelIncome,
        uint royaltyIncome,
        uint lostIncome
    ) {
        uint myId = id[msg.sender];
        require(myId > 0, "Not registered");
        
        UserIncome storage inc = userIncome[myId];
        
        return (
            inc.totalIncome,
            inc.referralIncome,
            inc.sponsorIncome,
            inc.levelIncome,
            inc.royaltyIncome,
            lostIncome[myId]
        );
    }
    
    /**
     * @notice Get your team statistics
     * @dev Returns team information for the caller
     * @return directCount Number of direct referrals
     * @return totalMatrixTeam Total team in matrix
     * @return directIds Array of direct referral user IDs
     * @return directAddresses Array of direct referral addresses
     */
    function getMyTeam() external view returns (
        uint directCount,
        uint totalMatrixTeam,
        uint[] memory directIds,
        address[] memory directAddresses
    ) {
        uint myId = id[msg.sender];
        require(myId > 0, "Not registered");
        
        User storage user = userInfo[myId];
        uint[] storage directs = directTeam[myId];
        
        address[] memory addresses = new address[](directs.length);
        for (uint i = 0; i < directs.length; i++) {
            addresses[i] = userInfo[directs[i]].account;
        }
        
        return (
            user.directTeam,
            user.totalMatrixTeam,
            directs,
            addresses
        );
    }
    
    /**
     * @notice Calculate exact cost to upgrade X levels
     * @dev Helps users plan upgrades by showing exact BNB needed
     * @param _levels Number of levels to upgrade (1-13)
     * @return totalCost Total BNB needed (including all fees)
     * @return breakdown Array of costs per level
     */
    function getUpgradeCost(uint _levels) external view returns (
        uint totalCost,
        uint[] memory breakdown
    ) {
        uint myId = id[msg.sender];
        require(myId > 0, "Not registered");
        
        uint currentLevel = userInfo[myId].level;
        require(currentLevel + _levels <= MAX_LEVELS, "Exceeds max level");
        
        breakdown = new uint[](_levels);
        totalCost = 0;
        
        for (uint i = 0; i < _levels; i++) {
            uint targetLevel = currentLevel + i;
            uint levelCost = levels[targetLevel];
            uint adminFee = (levelCost * percents[targetLevel]) / 100;
            uint cost = levelCost + adminFee;
            
            breakdown[i] = cost;
            totalCost += cost;
        }
        
        return (totalCost, breakdown);
    }
    
    /**
     * @notice Get exact cost to register (Level 1 + fee)
     * @dev Shows new users how much BNB they need to join
     * @return cost Total BNB needed to register
     * @return levelCost Base level 1 cost
     * @return adminFee Admin fee amount
     */
    function getRegistrationCost() external view returns (
        uint cost,
        uint levelCost,
        uint adminFee
    ) {
        levelCost = levels[0];
        adminFee = (levelCost * percents[0]) / 100;
        cost = levelCost + adminFee;
        
        return (cost, levelCost, adminFee);
    }
    
    /**
     * @notice Check your royalty tier eligibility and claimable amounts
     * @dev Returns status for all 4 royalty tiers
     * @return eligible Array: tier is unlocked for you
     * @return claimed Array: tier has been claimed
     * @return amounts Array: claimable amount per tier
     * @return tierNames Array: tier name strings
     */
    function getMyRoyaltyStatus() external view returns (
        bool[4] memory eligible,
        bool[4] memory claimed,
        uint[4] memory amounts,
        string[4] memory tierNames
    ) {
        uint myId = id[msg.sender];
        require(myId > 0, "Not registered");
        
        for (uint i = 0; i < 4; i++) {
            (uint amount, bool taken, bool active) = royaltyAddr.getUserRoyaltyData(myId, i);
            
            eligible[i] = active;
            claimed[i] = taken;
            amounts[i] = amount;
            
            if (i == 0) tierNames[i] = "Level 10 Tier";
            else if (i == 1) tierNames[i] = "Level 11 Tier";
            else if (i == 2) tierNames[i] = "Level 12 Tier";
            else tierNames[i] = "Level 13 Tier";
        }
        
        return (eligible, claimed, amounts, tierNames);
    }
    
    /**
     * @notice Check if an address is registered in the system
     * @dev Quick lookup for any address
     * @param _address Address to check
     * @return registered True if address is registered
     * @return userId Their user ID (0 if not registered)
     */
    function isRegistered(address _address) external view returns (
        bool registered,
        uint userId
    ) {
        userId = id[_address];
        registered = userId > 0;
        return (registered, userId);
    }
    
    function getGovernanceAddresses() external view returns(address dao, address ownerAddr, address emergency) {
        return (daoAddress, owner, emergencyAdmin);
    }
}
